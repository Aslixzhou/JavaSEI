<!doctype html>
<html>
<head>
<meta charset='UTF-8'><meta name='viewport' content='width=device-width initial-scale=1'>
<title>JavaSEI</title><link href='https://fonts.loli.net/css?family=Open+Sans:400italic,700italic,700,400&subset=latin,latin-ext' rel='stylesheet' type='text/css' /><style type='text/css'>html {overflow-x: initial !important;}:root { --bg-color:#ffffff; --text-color:#333333; --select-text-bg-color:#B5D6FC; --select-text-font-color:auto; --monospace:"Lucida Console",Consolas,"Courier",monospace; }
html { font-size: 14px; background-color: var(--bg-color); color: var(--text-color); font-family: "Helvetica Neue", Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; }
body { margin: 0px; padding: 0px; height: auto; bottom: 0px; top: 0px; left: 0px; right: 0px; font-size: 1rem; line-height: 1.42857; overflow-x: hidden; background: inherit; tab-size: 4; }
iframe { margin: auto; }
a.url { word-break: break-all; }
a:active, a:hover { outline: 0px; }
.in-text-selection, ::selection { text-shadow: none; background: var(--select-text-bg-color); color: var(--select-text-font-color); }
#write { margin: 0px auto; height: auto; width: inherit; word-break: normal; word-wrap: break-word; position: relative; white-space: normal; overflow-x: visible; padding-top: 40px; }
#write.first-line-indent p { text-indent: 2em; }
#write.first-line-indent li p, #write.first-line-indent p * { text-indent: 0px; }
#write.first-line-indent li { margin-left: 2em; }
.for-image #write { padding-left: 8px; padding-right: 8px; }
body.typora-export { padding-left: 30px; padding-right: 30px; }
.typora-export .footnote-line, .typora-export li, .typora-export p { white-space: pre-wrap; }
@media screen and (max-width: 500px) {
  body.typora-export { padding-left: 0px; padding-right: 0px; }
  #write { padding-left: 20px; padding-right: 20px; }
  .CodeMirror-sizer { margin-left: 0px !important; }
  .CodeMirror-gutters { display: none !important; }
}
#write li > figure:first-child { margin-top: -20px; }
#write ol, #write ul { position: relative; }
img { max-width: 100%; vertical-align: middle; }
button, input, select, textarea { color: inherit; font-style: inherit; font-variant: inherit; font-weight: inherit; font-stretch: inherit; font-size: inherit; line-height: inherit; font-family: inherit; }
input[type="checkbox"], input[type="radio"] { line-height: normal; padding: 0px; }
*, ::after, ::before { box-sizing: border-box; }
#write h1, #write h2, #write h3, #write h4, #write h5, #write h6, #write p, #write pre { width: inherit; }
#write h1, #write h2, #write h3, #write h4, #write h5, #write h6, #write p { position: relative; }
h1, h2, h3, h4, h5, h6 { break-after: avoid-page; break-inside: avoid; orphans: 2; }
p { orphans: 4; }
h1 { font-size: 2rem; }
h2 { font-size: 1.8rem; }
h3 { font-size: 1.6rem; }
h4 { font-size: 1.4rem; }
h5 { font-size: 1.2rem; }
h6 { font-size: 1rem; }
.md-math-block, .md-rawblock, h1, h2, h3, h4, h5, h6, p { margin-top: 1rem; margin-bottom: 1rem; }
.hidden { display: none; }
.md-blockmeta { color: rgb(204, 204, 204); font-weight: 700; font-style: italic; }
a { cursor: pointer; }
sup.md-footnote { padding: 2px 4px; background-color: rgba(238, 238, 238, 0.7); color: rgb(85, 85, 85); border-radius: 4px; cursor: pointer; }
sup.md-footnote a, sup.md-footnote a:hover { color: inherit; text-transform: inherit; text-decoration: inherit; }
#write input[type="checkbox"] { cursor: pointer; width: inherit; height: inherit; }
figure { overflow-x: auto; margin: 1.2em 0px; max-width: calc(100% + 16px); padding: 0px; }
figure > table { margin: 0px !important; }
tr { break-inside: avoid; break-after: auto; }
thead { display: table-header-group; }
table { border-collapse: collapse; border-spacing: 0px; width: 100%; overflow: auto; break-inside: auto; text-align: left; }
table.md-table td { min-width: 32px; }
.CodeMirror-gutters { border-right: 0px; background-color: inherit; }
.CodeMirror-linenumber { user-select: none; }
.CodeMirror { text-align: left; }
.CodeMirror-placeholder { opacity: 0.3; }
.CodeMirror pre { padding: 0px 4px; }
.CodeMirror-lines { padding: 0px; }
div.hr:focus { cursor: none; }
#write pre { white-space: pre-wrap; }
#write.fences-no-line-wrapping pre { white-space: pre; }
#write pre.ty-contain-cm { white-space: normal; }
.CodeMirror-gutters { margin-right: 4px; }
.md-fences { font-size: 0.9rem; display: block; break-inside: avoid; text-align: left; overflow: visible; white-space: pre; background: inherit; position: relative !important; }
.md-diagram-panel { width: 100%; margin-top: 10px; text-align: center; padding-top: 0px; padding-bottom: 8px; overflow-x: auto; }
#write .md-fences.mock-cm { white-space: pre-wrap; }
.md-fences.md-fences-with-lineno { padding-left: 0px; }
#write.fences-no-line-wrapping .md-fences.mock-cm { white-space: pre; overflow-x: auto; }
.md-fences.mock-cm.md-fences-with-lineno { padding-left: 8px; }
.CodeMirror-line, twitterwidget { break-inside: avoid; }
.footnotes { opacity: 0.8; font-size: 0.9rem; margin-top: 1em; margin-bottom: 1em; }
.footnotes + .footnotes { margin-top: 0px; }
.md-reset { margin: 0px; padding: 0px; border: 0px; outline: 0px; vertical-align: top; background: 0px 0px; text-decoration: none; text-shadow: none; float: none; position: static; width: auto; height: auto; white-space: nowrap; cursor: inherit; -webkit-tap-highlight-color: transparent; line-height: normal; font-weight: 400; text-align: left; box-sizing: content-box; direction: ltr; }
li div { padding-top: 0px; }
blockquote { margin: 1rem 0px; }
li .mathjax-block, li p { margin: 0.5rem 0px; }
li { margin: 0px; position: relative; }
blockquote > :last-child { margin-bottom: 0px; }
blockquote > :first-child, li > :first-child { margin-top: 0px; }
.footnotes-area { color: rgb(136, 136, 136); margin-top: 0.714rem; padding-bottom: 0.143rem; white-space: normal; }
#write .footnote-line { white-space: pre-wrap; }
@media print {
  body, html { border: 1px solid transparent; height: 99%; break-after: avoid; break-before: avoid; }
  #write { margin-top: 0px; padding-top: 0px; border-color: transparent !important; }
  .typora-export * { -webkit-print-color-adjust: exact; }
  html.blink-to-pdf { font-size: 13px; }
  .typora-export #write { padding-left: 32px; padding-right: 32px; padding-bottom: 0px; break-after: avoid; }
  .typora-export #write::after { height: 0px; }
  @page { margin: 20mm 0px; }
}
.footnote-line { margin-top: 0.714em; font-size: 0.7em; }
a img, img a { cursor: pointer; }
pre.md-meta-block { font-size: 0.8rem; min-height: 0.8rem; white-space: pre-wrap; background: rgb(204, 204, 204); display: block; overflow-x: hidden; }
p > .md-image:only-child:not(.md-img-error) img, p > img:only-child { display: block; margin: auto; }
p > .md-image:only-child { display: inline-block; width: 100%; }
#write .MathJax_Display { margin: 0.8em 0px 0px; }
.md-math-block { width: 100%; }
.md-math-block:not(:empty)::after { display: none; }
[contenteditable="true"]:active, [contenteditable="true"]:focus { outline: 0px; box-shadow: none; }
.md-task-list-item { position: relative; list-style-type: none; }
.task-list-item.md-task-list-item { padding-left: 0px; }
.md-task-list-item > input { position: absolute; top: 0px; left: 0px; margin-left: -1.2em; margin-top: calc(1em - 10px); border: none; }
.math { font-size: 1rem; }
.md-toc { min-height: 3.58rem; position: relative; font-size: 0.9rem; border-radius: 10px; }
.md-toc-content { position: relative; margin-left: 0px; }
.md-toc-content::after, .md-toc::after { display: none; }
.md-toc-item { display: block; color: rgb(65, 131, 196); }
.md-toc-item a { text-decoration: none; }
.md-toc-inner:hover { text-decoration: underline; }
.md-toc-inner { display: inline-block; cursor: pointer; }
.md-toc-h1 .md-toc-inner { margin-left: 0px; font-weight: 700; }
.md-toc-h2 .md-toc-inner { margin-left: 2em; }
.md-toc-h3 .md-toc-inner { margin-left: 4em; }
.md-toc-h4 .md-toc-inner { margin-left: 6em; }
.md-toc-h5 .md-toc-inner { margin-left: 8em; }
.md-toc-h6 .md-toc-inner { margin-left: 10em; }
@media screen and (max-width: 48em) {
  .md-toc-h3 .md-toc-inner { margin-left: 3.5em; }
  .md-toc-h4 .md-toc-inner { margin-left: 5em; }
  .md-toc-h5 .md-toc-inner { margin-left: 6.5em; }
  .md-toc-h6 .md-toc-inner { margin-left: 8em; }
}
a.md-toc-inner { font-size: inherit; font-style: inherit; font-weight: inherit; line-height: inherit; }
.footnote-line a:not(.reversefootnote) { color: inherit; }
.md-attr { display: none; }
.md-fn-count::after { content: "."; }
code, pre, samp, tt { font-family: var(--monospace); }
kbd { margin: 0px 0.1em; padding: 0.1em 0.6em; font-size: 0.8em; color: rgb(36, 39, 41); background: rgb(255, 255, 255); border: 1px solid rgb(173, 179, 185); border-radius: 3px; box-shadow: rgba(12, 13, 14, 0.2) 0px 1px 0px, rgb(255, 255, 255) 0px 0px 0px 2px inset; white-space: nowrap; vertical-align: middle; }
.md-comment { color: rgb(162, 127, 3); opacity: 0.8; font-family: var(--monospace); }
code { text-align: left; vertical-align: initial; }
a.md-print-anchor { white-space: pre !important; border-width: initial !important; border-style: none !important; border-color: initial !important; display: inline-block !important; position: absolute !important; width: 1px !important; right: 0px !important; outline: 0px !important; background: 0px 0px !important; text-decoration: initial !important; text-shadow: initial !important; }
.md-inline-math .MathJax_SVG .noError { display: none !important; }
.html-for-mac .inline-math-svg .MathJax_SVG { vertical-align: 0.2px; }
.md-math-block .MathJax_SVG_Display { text-align: center; margin: 0px; position: relative; text-indent: 0px; max-width: none; max-height: none; min-height: 0px; min-width: 100%; width: auto; overflow-y: hidden; display: block !important; }
.MathJax_SVG_Display, .md-inline-math .MathJax_SVG_Display { width: auto; margin: inherit; display: inline-block !important; }
.MathJax_SVG .MJX-monospace { font-family: var(--monospace); }
.MathJax_SVG .MJX-sans-serif { font-family: sans-serif; }
.MathJax_SVG { display: inline; font-style: normal; font-weight: 400; line-height: normal; zoom: 90%; text-indent: 0px; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px; }
.MathJax_SVG * { transition: none; }
.MathJax_SVG_Display svg { vertical-align: middle !important; margin-bottom: 0px !important; }
.os-windows.monocolor-emoji .md-emoji { font-family: "Segoe UI Symbol", sans-serif; }
.md-diagram-panel > svg { max-width: 100%; }
[lang="mermaid"] svg, [lang="flow"] svg { max-width: 100%; }
[lang="mermaid"] .node text { font-size: 1rem; }
table tr th { border-bottom: 0px; }
video { max-width: 100%; display: block; margin: 0px auto; }
iframe { max-width: 100%; width: 100%; border: none; }
.highlight td, .highlight tr { border: 0px; }


.CodeMirror { height: auto; }
.CodeMirror.cm-s-inner { background: inherit; }
.CodeMirror-scroll { overflow-y: hidden; overflow-x: auto; z-index: 3; }
.CodeMirror-gutter-filler, .CodeMirror-scrollbar-filler { background-color: rgb(255, 255, 255); }
.CodeMirror-gutters { border-right: 1px solid rgb(221, 221, 221); background: inherit; white-space: nowrap; }
.CodeMirror-linenumber { padding: 0px 3px 0px 5px; text-align: right; color: rgb(153, 153, 153); }
.cm-s-inner .cm-keyword { color: rgb(119, 0, 136); }
.cm-s-inner .cm-atom, .cm-s-inner.cm-atom { color: rgb(34, 17, 153); }
.cm-s-inner .cm-number { color: rgb(17, 102, 68); }
.cm-s-inner .cm-def { color: rgb(0, 0, 255); }
.cm-s-inner .cm-variable { color: rgb(0, 0, 0); }
.cm-s-inner .cm-variable-2 { color: rgb(0, 85, 170); }
.cm-s-inner .cm-variable-3 { color: rgb(0, 136, 85); }
.cm-s-inner .cm-string { color: rgb(170, 17, 17); }
.cm-s-inner .cm-property { color: rgb(0, 0, 0); }
.cm-s-inner .cm-operator { color: rgb(152, 26, 26); }
.cm-s-inner .cm-comment, .cm-s-inner.cm-comment { color: rgb(170, 85, 0); }
.cm-s-inner .cm-string-2 { color: rgb(255, 85, 0); }
.cm-s-inner .cm-meta { color: rgb(85, 85, 85); }
.cm-s-inner .cm-qualifier { color: rgb(85, 85, 85); }
.cm-s-inner .cm-builtin { color: rgb(51, 0, 170); }
.cm-s-inner .cm-bracket { color: rgb(153, 153, 119); }
.cm-s-inner .cm-tag { color: rgb(17, 119, 0); }
.cm-s-inner .cm-attribute { color: rgb(0, 0, 204); }
.cm-s-inner .cm-header, .cm-s-inner.cm-header { color: rgb(0, 0, 255); }
.cm-s-inner .cm-quote, .cm-s-inner.cm-quote { color: rgb(0, 153, 0); }
.cm-s-inner .cm-hr, .cm-s-inner.cm-hr { color: rgb(153, 153, 153); }
.cm-s-inner .cm-link, .cm-s-inner.cm-link { color: rgb(0, 0, 204); }
.cm-negative { color: rgb(221, 68, 68); }
.cm-positive { color: rgb(34, 153, 34); }
.cm-header, .cm-strong { font-weight: 700; }
.cm-del { text-decoration: line-through; }
.cm-em { font-style: italic; }
.cm-link { text-decoration: underline; }
.cm-error { color: red; }
.cm-invalidchar { color: red; }
.cm-constant { color: rgb(38, 139, 210); }
.cm-defined { color: rgb(181, 137, 0); }
div.CodeMirror span.CodeMirror-matchingbracket { color: rgb(0, 255, 0); }
div.CodeMirror span.CodeMirror-nonmatchingbracket { color: rgb(255, 34, 34); }
.cm-s-inner .CodeMirror-activeline-background { background: inherit; }
.CodeMirror { position: relative; overflow: hidden; }
.CodeMirror-scroll { height: 100%; outline: 0px; position: relative; box-sizing: content-box; background: inherit; }
.CodeMirror-sizer { position: relative; }
.CodeMirror-gutter-filler, .CodeMirror-hscrollbar, .CodeMirror-scrollbar-filler, .CodeMirror-vscrollbar { position: absolute; z-index: 6; display: none; }
.CodeMirror-vscrollbar { right: 0px; top: 0px; overflow: hidden; }
.CodeMirror-hscrollbar { bottom: 0px; left: 0px; overflow: hidden; }
.CodeMirror-scrollbar-filler { right: 0px; bottom: 0px; }
.CodeMirror-gutter-filler { left: 0px; bottom: 0px; }
.CodeMirror-gutters { position: absolute; left: 0px; top: 0px; padding-bottom: 30px; z-index: 3; }
.CodeMirror-gutter { white-space: normal; height: 100%; box-sizing: content-box; padding-bottom: 30px; margin-bottom: -32px; display: inline-block; }
.CodeMirror-gutter-wrapper { position: absolute; z-index: 4; background: 0px 0px !important; border: none !important; }
.CodeMirror-gutter-background { position: absolute; top: 0px; bottom: 0px; z-index: 4; }
.CodeMirror-gutter-elt { position: absolute; cursor: default; z-index: 4; }
.CodeMirror-lines { cursor: text; }
.CodeMirror pre { border-radius: 0px; border-width: 0px; background: 0px 0px; font-family: inherit; font-size: inherit; margin: 0px; white-space: pre; word-wrap: normal; color: inherit; z-index: 2; position: relative; overflow: visible; }
.CodeMirror-wrap pre { word-wrap: break-word; white-space: pre-wrap; word-break: normal; }
.CodeMirror-code pre { border-right: 30px solid transparent; width: fit-content; }
.CodeMirror-wrap .CodeMirror-code pre { border-right: none; width: auto; }
.CodeMirror-linebackground { position: absolute; left: 0px; right: 0px; top: 0px; bottom: 0px; z-index: 0; }
.CodeMirror-linewidget { position: relative; z-index: 2; overflow: auto; }
.CodeMirror-wrap .CodeMirror-scroll { overflow-x: hidden; }
.CodeMirror-measure { position: absolute; width: 100%; height: 0px; overflow: hidden; visibility: hidden; }
.CodeMirror-measure pre { position: static; }
.CodeMirror div.CodeMirror-cursor { position: absolute; visibility: hidden; border-right: none; width: 0px; }
.CodeMirror div.CodeMirror-cursor { visibility: hidden; }
.CodeMirror-focused div.CodeMirror-cursor { visibility: inherit; }
.cm-searching { background: rgba(255, 255, 0, 0.4); }
@media print {
  .CodeMirror div.CodeMirror-cursor { visibility: hidden; }
}


:root { --side-bar-bg-color: #fafafa; --control-text-color: #777; }
html { font-size: 16px; -webkit-font-smoothing: antialiased; }
body { font-family: "Open Sans", "Clear Sans", "Helvetica Neue", Helvetica, Arial, "Segoe UI Emoji", sans-serif; color: rgb(0, 64, 80); line-height: 1.6; }
#write { max-width: 860px; margin: 0px auto; padding: 30px 30px 100px; }
@media only screen and (min-width: 1400px) {
  #write { max-width: 1024px; }
}
@media only screen and (min-width: 1800px) {
  #write { max-width: 1200px; }
}
#write > ul:first-child, #write > ol:first-child { margin-top: 30px; }
a { color: rgb(65, 131, 196); }
h1, h2, h3, h4, h5, h6 { position: relative; margin-top: 1rem; margin-bottom: 1rem; font-weight: bold; line-height: 1.4; cursor: text; }
h1:hover a.anchor, h2:hover a.anchor, h3:hover a.anchor, h4:hover a.anchor, h5:hover a.anchor, h6:hover a.anchor { text-decoration: none; }
h1 tt, h1 code { font-size: inherit; }
h2 tt, h2 code { font-size: inherit; }
h3 tt, h3 code { font-size: inherit; }
h4 tt, h4 code { font-size: inherit; }
h5 tt, h5 code { font-size: inherit; }
h6 tt, h6 code { font-size: inherit; }
h1 { font-size: 2.25em; line-height: 1.2; border-bottom: 1px solid rgb(238, 238, 238); }
h2 { font-size: 1.75em; line-height: 1.225; border-bottom: 1px solid rgb(238, 238, 238); }
h3 { font-size: 1.5em; line-height: 1.43; }
h4 { font-size: 1.25em; }
h5 { font-size: 1em; }
h6 { font-size: 1em; color: rgb(119, 119, 119); }
p, blockquote, ul, ol, dl, table { margin: 0.8em 0px; }
li > ol, li > ul { margin: 0px; }
hr { height: 2px; padding: 0px; margin: 16px 0px; background-color: rgb(231, 231, 231); border: 0px none; overflow: hidden; box-sizing: content-box; }
li p.first { display: inline-block; }
ul, ol { padding-left: 30px; }
ul:first-child, ol:first-child { margin-top: 0px; }
ul:last-child, ol:last-child { margin-bottom: 0px; }
blockquote { border-left: 5px solid rgb(66, 185, 131); padding: 8px 15px; color: rgb(33, 93, 66); background-color: rgb(243, 245, 247); }
blockquote blockquote { padding-right: 0px; }
table { padding: 0px; word-break: initial; }
table tr { border: 1px solid rgb(223, 226, 229); margin: 0px; padding: 0px; }
table tr:nth-child(2n), thead { background-color: rgb(248, 248, 248); }
table th { font-weight: bold; border-width: 1px 1px 0px; border-top-style: solid; border-right-style: solid; border-left-style: solid; border-top-color: rgb(223, 226, 229); border-right-color: rgb(223, 226, 229); border-left-color: rgb(223, 226, 229); border-image: initial; border-bottom-style: initial; border-bottom-color: initial; margin: 0px; padding: 6px 13px; }
table td { border: 1px solid rgb(223, 226, 229); margin: 0px; padding: 6px 13px; }
table th:first-child, table td:first-child { margin-top: 0px; }
table th:last-child, table td:last-child { margin-bottom: 0px; }
.CodeMirror-lines { padding-left: 4px; }
.code-tooltip { box-shadow: rgba(0, 28, 36, 0.3) 0px 1px 1px 0px; border-top: 1px solid rgb(238, 242, 242); }
.md-fences, code, tt { border: 1px solid rgb(231, 234, 237); background-color: rgb(248, 248, 248); border-radius: 3px; padding: 2px 4px 0px; font-size: 0.9em; }
code { background-color: rgb(243, 244, 244); padding: 2px; color: rgb(209, 37, 115); }
.md-fences { margin-bottom: 15px; margin-top: 15px; padding-top: 8px; padding-bottom: 6px; }
.md-task-list-item > input { margin-left: -1.3em; }
@media print {
  html { font-size: 13px; }
  table, pre { break-inside: avoid; }
  pre { word-wrap: break-word; }
}
.md-fences { background-color: rgb(248, 248, 248); }
#write pre.md-meta-block { padding: 1rem; font-size: 85%; line-height: 1.45; background-color: rgb(247, 247, 247); border: 0px; border-radius: 3px; color: rgb(119, 119, 119); margin-top: 0px !important; }
.mathjax-block > .code-tooltip { bottom: 0.375rem; }
.md-mathjax-midline { background: rgb(250, 250, 250); }
#write > h3.md-focus::before { left: -1.5625rem; top: 0.375rem; }
#write > h4.md-focus::before { left: -1.5625rem; top: 0.285714rem; }
#write > h5.md-focus::before { left: -1.5625rem; top: 0.285714rem; }
#write > h6.md-focus::before { left: -1.5625rem; top: 0.285714rem; }
.md-image > .md-meta { border-radius: 3px; padding: 2px 0px 0px 4px; font-size: 0.9em; color: inherit; }
.md-tag { color: rgb(167, 167, 167); opacity: 1; }
.md-toc { margin-top: 20px; padding-bottom: 20px; }
.sidebar-tabs { border-bottom: none; }
#typora-quick-open { border: 1px solid rgb(221, 221, 221); background-color: rgb(248, 248, 248); }
#typora-quick-open-item { background-color: rgb(250, 250, 250); border-color: rgb(254, 254, 254) rgb(229, 229, 229) rgb(229, 229, 229) rgb(238, 238, 238); border-style: solid; border-width: 1px; }
.on-focus-mode blockquote { border-left-color: rgba(85, 85, 85, 0.12); }
header, .context-menu, .megamenu-content, footer { font-family: "Segoe UI", Arial, sans-serif; }
.file-node-content:hover .file-node-icon, .file-node-content:hover .file-node-open-state { visibility: visible; }
.mac-seamless-mode #typora-sidebar { background-color: var(--side-bar-bg-color); }
.md-lang { color: rgb(180, 101, 77); }
#md-notification .btn { border: 0px; }
.dropdown-menu .divider { border-color: rgb(229, 229, 229); opacity: 0.4; }
.ty-preferences .window-content { background-color: rgb(250, 250, 250); }
.ty-preferences .nav-group-item.active { color: white; background: rgb(153, 153, 153); }
.menu-item-container a.menu-style-btn { background-color: rgb(245, 248, 250); background-image: linear-gradient(rgba(255, 255, 255, 0.8), rgba(255, 255, 255, 0)); }
#write mark { background: transparent; color: rgb(216, 105, 105); font-weight: bold; }
p .md-image:only-child { width: auto; text-align: left; }


.cm-s-inner { background-color: rgb(38, 50, 56); color: rgb(233, 237, 237); }
.cm-s-inner .CodeMirror-gutters { background: rgb(38, 50, 56); color: rgb(83, 127, 126); border: none; }
.cm-s-inner .CodeMirror-guttermarker, .cm-s-inner .CodeMirror-guttermarker-subtle, .cm-s-inner .CodeMirror-linenumber { color: rgb(83, 127, 126); }
.cm-s-inner .CodeMirror-cursor { border-left: 1px solid rgb(248, 248, 240); }
.cm-s-inner div.CodeMirror-selected { background: rgba(255, 255, 255, 0.15); }
.cm-s-inner.CodeMirror-focused div.CodeMirror-selected { background: rgba(255, 255, 255, 0.1); }
.cm-s-inner .CodeMirror-line::selection, .cm-s-inner .CodeMirror-line > span::selection, .cm-s-inner .CodeMirror-line > span > span::selection { background: rgba(255, 255, 255, 0.1); }
.cm-s-inner .CodeMirror-activeline-background { background: rgba(0, 0, 0, 0); }
.cm-s-inner .cm-keyword { color: rgb(199, 146, 234); }
.cm-s-inner .cm-operator { color: rgb(233, 237, 237); }
.cm-s-inner .cm-variable-2 { color: rgb(128, 203, 196); }
.cm-s-inner .cm-variable-3 { color: rgb(158, 255, 255); }
.cm-s-inner .cm-builtin { color: rgb(222, 203, 107); }
.cm-s-inner .cm-atom { color: rgb(247, 118, 105); }
.cm-s-inner .cm-number { color: rgb(247, 118, 105); }
.cm-s-inner .cm-def { color: rgb(233, 237, 237); }
.cm-s-inner .cm-string { color: rgb(195, 232, 141); }
.cm-s-inner .cm-string-2 { color: rgb(128, 203, 196); }
.cm-s-inner .cm-comment { color: rgb(84, 110, 122); }
.cm-s-inner .cm-variable { color: rgb(158, 255, 255); }
.cm-s-inner .cm-tag { color: rgb(128, 203, 196); }
.cm-s-inner .cm-meta { color: rgb(128, 203, 196); }
.cm-s-inner .cm-attribute { color: rgb(255, 203, 107); }
.cm-s-inner .cm-property { color: rgb(128, 203, 174); }
.cm-s-inner .cm-qualifier { color: rgb(222, 203, 107); }
.cm-s-inner .cm-variable-3 { color: rgb(222, 203, 107); }
.cm-s-inner .cm-tag { color: rgb(255, 83, 112); }
.cm-s-inner .cm-error { color: rgb(255, 255, 255); background-color: rgb(236, 95, 103); }
.cm-s-inner .CodeMirror-matchingbracket { text-decoration: underline; color: white !important; }
.md-fences { background-color: rgb(38, 50, 56); color: rgb(233, 237, 237); border: none; }
.md-fences .code-tooltip { background-color: rgb(38, 50, 56); }




</style>
</head>
<body class='typora-export os-windows' >
<div  id='write'  class = 'is-node first-line-indent'><h1><a name='header-n0' class='md-header-anchor '></a>JavaSE</h1><blockquote><p>Author：Zhry</p><p>Email：<a href='mailto:2553179694@qq.com' target='_blank' class='url'>2553179694@qq.com</a></p><p>Version：1.0.3</p></blockquote><p>﻿</p><div class='md-toc' mdtype='toc'><p class="md-toc-content"><span class="md-toc-item md-toc-h1" data-ref="n0"><a class="md-toc-inner" href="#header-n0">JavaSE</a></span><span class="md-toc-item md-toc-h2" data-ref="n10"><a class="md-toc-inner" href="#header-n10">1. Hello World</a></span><span class="md-toc-item md-toc-h2" data-ref="n13"><a class="md-toc-inner" href="#header-n13">2. 标识符</a></span><span class="md-toc-item md-toc-h2" data-ref="n24"><a class="md-toc-inner" href="#header-n24">3. 常量</a></span><span class="md-toc-item md-toc-h2" data-ref="n42"><a class="md-toc-inner" href="#header-n42">4. 基本数据类型</a></span><span class="md-toc-item md-toc-h2" data-ref="n73"><a class="md-toc-inner" href="#header-n73">5. 变量</a></span><span class="md-toc-item md-toc-h2" data-ref="n108"><a class="md-toc-inner" href="#header-n108">6. 数据类型转换</a></span><span class="md-toc-item md-toc-h2" data-ref="n117"><a class="md-toc-inner" href="#header-n117">7. 强制类型转换</a></span><span class="md-toc-item md-toc-h2" data-ref="n147"><a class="md-toc-inner" href="#header-n147">8. 数字与字符的对照关系</a></span><span class="md-toc-item md-toc-h2" data-ref="n165"><a class="md-toc-inner" href="#header-n165">9. 运算符</a></span><span class="md-toc-item md-toc-h2" data-ref="n180"><a class="md-toc-inner" href="#header-n180">10. '+'的三种用法</a></span><span class="md-toc-item md-toc-h2" data-ref="n195"><a class="md-toc-inner" href="#header-n195">11. 自增运算符</a></span><span class="md-toc-item md-toc-h2" data-ref="n224"><a class="md-toc-inner" href="#header-n224">12. 赋值运算符</a></span><span class="md-toc-item md-toc-h2" data-ref="n253"><a class="md-toc-inner" href="#header-n253">13. 比较运算符</a></span><span class="md-toc-item md-toc-h2" data-ref="n269"><a class="md-toc-inner" href="#header-n269">14. 逻辑运算符</a></span><span class="md-toc-item md-toc-h2" data-ref="n300"><a class="md-toc-inner" href="#header-n300">15. 三元运算符</a></span><span class="md-toc-item md-toc-h2" data-ref="n325"><a class="md-toc-inner" href="#header-n325">16. 方法的定义</a></span><span class="md-toc-item md-toc-h2" data-ref="n350"><a class="md-toc-inner" href="#header-n350">17. 编译器的优化</a></span><span class="md-toc-item md-toc-h2" data-ref="n381"><a class="md-toc-inner" href="#header-n381">18. 选择结构</a></span><span class="md-toc-item md-toc-h2" data-ref="n385"><a class="md-toc-inner" href="#header-n385">19. switch语句</a></span><span class="md-toc-item md-toc-h2" data-ref="n398"><a class="md-toc-inner" href="#header-n398">20. 循环结构</a></span><span class="md-toc-item md-toc-h2" data-ref="n414"><a class="md-toc-inner" href="#header-n414">21. 循环控制语句</a></span><span class="md-toc-item md-toc-h2" data-ref="n431"><a class="md-toc-inner" href="#header-n431">22. IDEA常用快捷键</a></span><span class="md-toc-item md-toc-h2" data-ref="n453"><a class="md-toc-inner" href="#header-n453">23. 初识方法</a></span><span class="md-toc-item md-toc-h2" data-ref="n485"><a class="md-toc-inner" href="#header-n485">24. 方法的调用</a></span><span class="md-toc-item md-toc-h2" data-ref="n524"><a class="md-toc-inner" href="#header-n524">25. 方法的重载</a></span><span class="md-toc-item md-toc-h2" data-ref="n552"><a class="md-toc-inner" href="#header-n552">26. 数组及初始化</a></span><span class="md-toc-item md-toc-h2" data-ref="n621"><a class="md-toc-inner" href="#header-n621">27. 访问数组元素</a></span><span class="md-toc-item md-toc-h2" data-ref="n688"><a class="md-toc-inner" href="#header-n688">28. 面向对象与面向过程</a></span><span class="md-toc-item md-toc-h2" data-ref="n697"><a class="md-toc-inner" href="#header-n697">29. 类</a></span><span class="md-toc-item md-toc-h2" data-ref="n726"><a class="md-toc-inner" href="#header-n726">30. 局部变量和成员变量</a></span><span class="md-toc-item md-toc-h2" data-ref="n730"><a class="md-toc-inner" href="#header-n730">31. 面向对象的三大特征</a></span><span class="md-toc-item md-toc-h2" data-ref="n753"><a class="md-toc-inner" href="#header-n753">32. this方法介绍</a></span><span class="md-toc-item md-toc-h2" data-ref="n762"><a class="md-toc-inner" href="#header-n762">33. 构造方法</a></span><span class="md-toc-item md-toc-h2" data-ref="n785"><a class="md-toc-inner" href="#header-n785">34. 定义一个标准类</a></span><span class="md-toc-item md-toc-h2" data-ref="n803"><a class="md-toc-inner" href="#header-n803">35. Scanner简单使用</a></span><span class="md-toc-item md-toc-h2" data-ref="n819"><a class="md-toc-inner" href="#header-n819">36. 匿名对象</a></span><span class="md-toc-item md-toc-h2" data-ref="n831"><a class="md-toc-inner" href="#header-n831">37. Random基本使用</a></span><span class="md-toc-item md-toc-h2" data-ref="n846"><a class="md-toc-inner" href="#header-n846">38. 对象数组</a></span><span class="md-toc-item md-toc-h2" data-ref="n849"><a class="md-toc-inner" href="#header-n849">39. ArrayList</a></span><span class="md-toc-item md-toc-h2" data-ref="n946"><a class="md-toc-inner" href="#header-n946">40. 字符串概述</a></span><span class="md-toc-item md-toc-h2" data-ref="n1030"><a class="md-toc-inner" href="#header-n1030">41. static关键字</a></span><span class="md-toc-item md-toc-h2" data-ref="n1055"><a class="md-toc-inner" href="#header-n1055">42. 静态代码块和非静态代码块</a></span><span class="md-toc-item md-toc-h2" data-ref="n1097"><a class="md-toc-inner" href="#header-n1097">43. 数组工具类</a></span><span class="md-toc-item md-toc-h2" data-ref="n1110"><a class="md-toc-inner" href="#header-n1110">43. Math类</a></span><span class="md-toc-item md-toc-h2" data-ref="n1127"><a class="md-toc-inner" href="#header-n1127">44. 继承</a></span><span class="md-toc-item md-toc-h2" data-ref="n1180"><a class="md-toc-inner" href="#header-n1180">45. Override重写</a></span><span class="md-toc-item md-toc-h2" data-ref="n1217"><a class="md-toc-inner" href="#header-n1217">46. 子父类构造方法的特点</a></span><span class="md-toc-item md-toc-h2" data-ref="n1229"><a class="md-toc-inner" href="#header-n1229">47. super关键字</a></span><span class="md-toc-item md-toc-h2" data-ref="n1252"><a class="md-toc-inner" href="#header-n1252">48. 抽象类和抽象方法</a></span><span class="md-toc-item md-toc-h2" data-ref="n1290"><a class="md-toc-inner" href="#header-n1290">48. ==运算符、equals、toString()使用</a></span><span class="md-toc-item md-toc-h2" data-ref="n1310"><a class="md-toc-inner" href="#header-n1310">49. 包装类</a></span><span class="md-toc-item md-toc-h2" data-ref="n1321"><a class="md-toc-inner" href="#header-n1321">50. final关键字</a></span><span class="md-toc-item md-toc-h2" data-ref="n1340"><a class="md-toc-inner" href="#header-n1340">51. 四种权限修饰符比较</a></span><span class="md-toc-item md-toc-h2" data-ref="n1342"><a class="md-toc-inner" href="#header-n1342">52. 抽象类的匿名子类</a></span><span class="md-toc-item md-toc-h2" data-ref="n1345"><a class="md-toc-inner" href="#header-n1345">53. 多态多态的概述：一个对象拥有多种形态</a></span><span class="md-toc-item md-toc-h2" data-ref="n1391"><a class="md-toc-inner" href="#header-n1391">54. 对象的向上转型和向下转型</a></span><span class="md-toc-item md-toc-h2" data-ref="n1422"><a class="md-toc-inner" href="#header-n1422">55. instanceof使用instanceof关键字进行类型判断</a></span><span class="md-toc-item md-toc-h2" data-ref="n1433"><a class="md-toc-inner" href="#header-n1433">56. USB接口举例</a></span><span class="md-toc-item md-toc-h2" data-ref="n1435"><a class="md-toc-inner" href="#header-n1435">57. 接口</a></span><span class="md-toc-item md-toc-h2" data-ref="n1575"><a class="md-toc-inner" href="#header-n1575">58. 接口匿名实现类的对象</a></span><span class="md-toc-item md-toc-h2" data-ref="n1577"><a class="md-toc-inner" href="#header-n1577">60. 接口应用：代理模式</a></span><span class="md-toc-item md-toc-h2" data-ref="n1579"><a class="md-toc-inner" href="#header-n1579">61. 实现接口和继承父类重名</a></span><span class="md-toc-item md-toc-h2" data-ref="n1581"><a class="md-toc-inner" href="#header-n1581">61. 内部类</a></span><span class="md-toc-item md-toc-h2" data-ref="n1662"><a class="md-toc-inner" href="#header-n1662">62. 类作成员变量</a></span><span class="md-toc-item md-toc-h2" data-ref="n1664"><a class="md-toc-inner" href="#header-n1664">63. 接口作成员变量、形参和返回值</a></span><span class="md-toc-item md-toc-h2" data-ref="n1673"><a class="md-toc-inner" href="#header-n1673">64. 发红包案例</a></span><span class="md-toc-item md-toc-h2" data-ref="n1677"><a class="md-toc-inner" href="#header-n1677">65. 异常处理</a></span><span class="md-toc-item md-toc-h2" data-ref="n1720"><a class="md-toc-inner" href="#header-n1720">66. finally代码块</a></span><span class="md-toc-item md-toc-h2" data-ref="n1727"><a class="md-toc-inner" href="#header-n1727">67. 异常注意事项</a></span><span class="md-toc-item md-toc-h2" data-ref="n1740"><a class="md-toc-inner" href="#header-n1740">68. 自定义异常类</a></span><span class="md-toc-item md-toc-h2" data-ref="n1750"><a class="md-toc-inner" href="#header-n1750">69. Date类</a></span><span class="md-toc-item md-toc-h2" data-ref="n1791"><a class="md-toc-inner" href="#header-n1791">70. DateFormat类</a></span><span class="md-toc-item md-toc-h2" data-ref="n1821"><a class="md-toc-inner" href="#header-n1821">71. Calendar类</a></span><span class="md-toc-item md-toc-h2" data-ref="n1879"><a class="md-toc-inner" href="#header-n1879">72. System类</a></span><span class="md-toc-item md-toc-h2" data-ref="n1888"><a class="md-toc-inner" href="#header-n1888">73. String类</a></span><span class="md-toc-item md-toc-h2" data-ref="n1958"><a class="md-toc-inner" href="#header-n1958">74. StringBuilder类</a></span><span class="md-toc-item md-toc-h2" data-ref="n1963"><a class="md-toc-inner" href="#header-n1963">75. StringBuffer类</a></span><span class="md-toc-item md-toc-h2" data-ref="n1981"><a class="md-toc-inner" href="#header-n1981">76.  Collection集合</a></span><span class="md-toc-item md-toc-h2" data-ref="n2018"><a class="md-toc-inner" href="#header-n2018">77. Iterator接口介绍：</a></span><span class="md-toc-item md-toc-h2" data-ref="n2042"><a class="md-toc-inner" href="#header-n2042">78. 增强for循环</a></span><span class="md-toc-item md-toc-h2" data-ref="n2050"><a class="md-toc-inner" href="#header-n2050">79. LocalDate LocalTime LocalDateTime类</a></span><span class="md-toc-item md-toc-h2" data-ref="n2064"><a class="md-toc-inner" href="#header-n2064">80. Instant类</a></span><span class="md-toc-item md-toc-h2" data-ref="n2078"><a class="md-toc-inner" href="#header-n2078">81. DateTimeFormatter类</a></span><span class="md-toc-item md-toc-h2" data-ref="n2091"><a class="md-toc-inner" href="#header-n2091">82. Java比较器</a></span><span class="md-toc-item md-toc-h2" data-ref="n2132"><a class="md-toc-inner" href="#header-n2132">83. System类成员方法</a></span><span class="md-toc-item md-toc-h2" data-ref="n2143"><a class="md-toc-inner" href="#header-n2143">84. Math类</a></span><span class="md-toc-item md-toc-h2" data-ref="n2172"><a class="md-toc-inner" href="#header-n2172">85. BigInteger和BigDecimal类</a></span><span class="md-toc-item md-toc-h2" data-ref="n2219"><a class="md-toc-inner" href="#header-n2219">86. 枚举类</a></span><span class="md-toc-item md-toc-h2" data-ref="n2245"><a class="md-toc-inner" href="#header-n2245">87. Annotation注解</a></span><span class="md-toc-item md-toc-h2" data-ref="n2249"><a class="md-toc-inner" href="#header-n2249">88. Collection集合</a></span><span class="md-toc-item md-toc-h2" data-ref="n2254"><a class="md-toc-inner" href="#header-n2254">89. Collection接口中的方法</a></span><span class="md-toc-item md-toc-h2" data-ref="n2289"><a class="md-toc-inner" href="#header-n2289">90. Iterator迭代器</a></span><span class="md-toc-item md-toc-h2" data-ref="n2301"><a class="md-toc-inner" href="#header-n2301">91. List</a></span><span class="md-toc-item md-toc-h2" data-ref="n2347"><a class="md-toc-inner" href="#header-n2347">92. LinkedList</a></span><span class="md-toc-item md-toc-h2" data-ref="n2386"><a class="md-toc-inner" href="#header-n2386">93. Set</a></span><span class="md-toc-item md-toc-h2" data-ref="n2426"><a class="md-toc-inner" href="#header-n2426">94. LinkedHashSet</a></span><span class="md-toc-item md-toc-h2" data-ref="n2433"><a class="md-toc-inner" href="#header-n2433">95. TreeSet</a></span><span class="md-toc-item md-toc-h2" data-ref="n2452"><a class="md-toc-inner" href="#header-n2452">96. 可变参数</a></span><span class="md-toc-item md-toc-h2" data-ref="n2488"><a class="md-toc-inner" href="#header-n2488">97. Map集合</a></span><span class="md-toc-item md-toc-h2" data-ref="n2551"><a class="md-toc-inner" href="#header-n2551">98. TreeMap</a></span><span class="md-toc-item md-toc-h2" data-ref="n2562"><a class="md-toc-inner" href="#header-n2562">99. Properties</a></span><span class="md-toc-item md-toc-h2" data-ref="n2567"><a class="md-toc-inner" href="#header-n2567">100. 新特性</a></span><span class="md-toc-item md-toc-h2" data-ref="n2593"><a class="md-toc-inner" href="#header-n2593">101. Collections工具类</a></span><span class="md-toc-item md-toc-h2" data-ref="n2626"><a class="md-toc-inner" href="#header-n2626">102. Arrays工具类</a></span><span class="md-toc-item md-toc-h2" data-ref="n2640"><a class="md-toc-inner" href="#header-n2640">103. 多线程</a></span><span class="md-toc-item md-toc-h2" data-ref="n2674"><a class="md-toc-inner" href="#header-n2674">104. 创建多线程</a></span><span class="md-toc-item md-toc-h2" data-ref="n2731"><a class="md-toc-inner" href="#header-n2731">105. 线程安全问题</a></span><span class="md-toc-item md-toc-h2" data-ref="n2814"><a class="md-toc-inner" href="#header-n2814">106. 线程的通信</a></span><span class="md-toc-item md-toc-h2" data-ref="n2842"><a class="md-toc-inner" href="#header-n2842">107. Callable和线程池</a></span><span class="md-toc-item md-toc-h2" data-ref="n2868"><a class="md-toc-inner" href="#header-n2868">108. 泛型</a></span><span class="md-toc-item md-toc-h2" data-ref="n2942"><a class="md-toc-inner" href="#header-n2942">109. 通配符?</a></span><span class="md-toc-item md-toc-h2" data-ref="n2950"><a class="md-toc-inner" href="#header-n2950">110. File文件</a></span><span class="md-toc-item md-toc-h2" data-ref="n3052"><a class="md-toc-inner" href="#header-n3052">111. 文件过滤器</a></span><span class="md-toc-item md-toc-h2" data-ref="n3106"><a class="md-toc-inner" href="#header-n3106">112. IO流</a></span><span class="md-toc-item md-toc-h2" data-ref="n3462"><a class="md-toc-inner" href="#header-n3462">113. 网络编程</a></span><span class="md-toc-item md-toc-h2" data-ref="n3514"><a class="md-toc-inner" href="#header-n3514">114. 反射</a></span><span class="md-toc-item md-toc-h2" data-ref="n3667"><a class="md-toc-inner" href="#header-n3667">115. 代理模式与动态代理</a></span><span class="md-toc-item md-toc-h2" data-ref="n3693"><a class="md-toc-inner" href="#header-n3693">116. Lambda表达式</a></span><span class="md-toc-item md-toc-h2" data-ref="n3744"><a class="md-toc-inner" href="#header-n3744">117. 函数式接口</a></span><span class="md-toc-item md-toc-h2" data-ref="n3776"><a class="md-toc-inner" href="#header-n3776">118. 方法引用与构造器引用</a></span><span class="md-toc-item md-toc-h2" data-ref="n3819"><a class="md-toc-inner" href="#header-n3819">119. Stream流</a></span><span class="md-toc-item md-toc-h2" data-ref="n3889"><a class="md-toc-inner" href="#header-n3889">120. Stream API : Collectors</a></span><span class="md-toc-item md-toc-h2" data-ref="n3910"><a class="md-toc-inner" href="#header-n3910">121. Properties</a></span><span class="md-toc-item md-toc-h2" data-ref="n3943"><a class="md-toc-inner" href="#header-n3943">122. Optional类</a></span><span class="md-toc-item md-toc-h2" data-ref="n4008"><a class="md-toc-inner" href="#header-n4008">123. 集合工厂方法创建只读集合</a></span><span class="md-toc-item md-toc-h2" data-ref="n4026"><a class="md-toc-inner" href="#header-n4026">124. InputStream中的transferTo方法</a></span><span class="md-toc-item md-toc-h2" data-ref="n4031"><a class="md-toc-inner" href="#header-n4031">125. 局部变量类型推断</a></span><span class="md-toc-item md-toc-h2" data-ref="n4066"><a class="md-toc-inner" href="#header-n4066">126. Java11String中的新增方法</a></span><span class="md-toc-item md-toc-h1" data-ref="n4080"><a class="md-toc-inner" href="#header-n4080">后会有期</a></span></p></div><p>&nbsp;</p><hr /><h2><a name='header-n10' class='md-header-anchor '></a>1. Hello World</h2><pre spellcheck="false" class="md-fences md-end-block ty-contain-cm modeLoaded" lang="java"><div class="CodeMirror cm-s-inner CodeMirror-wrap" lang="java"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 0px; left: 8.16406px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation" style=""><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-comment">//Java：</span></span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-comment">//第一行的第三个单词必须和所在的文件夹名称完全一样 大小写也要一样</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-comment">//public class后面定义一个类的名称 类是Java中所有源代码的基本组织单位</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-keyword">public</span> <span class="cm-keyword">class</span> <span class="cm-def">HELLOWORLD</span>{</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-comment">//第二行的内容是万年不变的固定写法 代表main方法</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-comment">//这一行代表程序执行的起点</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-keyword">public</span> <span class="cm-keyword">static</span> <span class="cm-variable-3">void</span> <span class="cm-variable">main</span>(<span class="cm-variable-3">String</span>[] <span class="cm-variable">args</span>){</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-comment">//第三行代表打印输出语句</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-variable">System</span>.<span class="cm-variable">out</span>.<span class="cm-variable">println</span>(<span class="cm-string">"HELLOWORLD"</span>);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span>}</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">}</span></pre></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 248px;"></div><div class="CodeMirror-gutters" style="display: none; height: 248px;"></div></div></div></pre><hr /><h2><a name='header-n13' class='md-header-anchor '></a>2. 标识符</h2><ul><li>标识符：包含英文26字母区分大小写 0-9数字 $ _ 不能以数字开头 标识符不能是关键字 </li><li>命名规范：类：首字母大写以后每个单词首字母大写</li><li>变量名：首字母小写，以后每个单词首字母大写 </li><li>方法名：同变量名</li></ul><hr /><h2><a name='header-n24' class='md-header-anchor '></a>3. 常量</h2><ul><li>常量：不变的量</li><li>1.字符串常量 用双引号引起来的</li><li>2.整数常量：直接写上数字没有小数点</li><li>3.浮点数常量：-3.14 0.0</li><li>4.字符常量：单引号引起来的单个字符 &#39;中&#39;</li><li>5.布尔常量： true false 真假常量</li><li>6.空常量：NULL 代表没有任何数据</li></ul><pre spellcheck="false" class="md-fences md-end-block ty-contain-cm modeLoaded" lang="java" style="break-inside: unset;"><div class="CodeMirror cm-s-inner CodeMirror-wrap" lang="java"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 0px; left: 8.16406px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation" style=""><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-keyword">public</span> <span class="cm-keyword">class</span> <span class="cm-def">HELLO</span>{</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-keyword">public</span> <span class="cm-keyword">static</span> <span class="cm-variable-3">void</span> <span class="cm-variable">main</span>(<span class="cm-variable-3">String</span>[] <span class="cm-variable">args</span>){</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-comment">//字符串常量</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-variable">System</span>.<span class="cm-variable">out</span>.<span class="cm-variable">println</span>(<span class="cm-string">"ABC"</span>);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-variable">System</span>.<span class="cm-variable">out</span>.<span class="cm-variable">println</span>(<span class="cm-string">""</span>);<span class="cm-comment">//字符串的两个双引号中间的内容为空</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-variable">System</span>.<span class="cm-variable">out</span>.<span class="cm-variable">println</span>(<span class="cm-string">"Xyz"</span>);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" class="cm-tab-wrap-hack" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-comment">//整数常量</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-variable">System</span>.<span class="cm-variable">out</span>.<span class="cm-variable">println</span>(<span class="cm-number">30</span>);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-variable">System</span>.<span class="cm-variable">out</span>.<span class="cm-variable">println</span>(<span class="cm-operator">-</span><span class="cm-number">50</span>);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" class="cm-tab-wrap-hack" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-comment">//浮点数常量</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-variable">System</span>.<span class="cm-variable">out</span>.<span class="cm-variable">println</span>(<span class="cm-number">3.14</span>);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-variable">System</span>.<span class="cm-variable">out</span>.<span class="cm-variable">println</span>(<span class="cm-operator">-</span><span class="cm-number">0.0</span>);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" class="cm-tab-wrap-hack" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-comment">//字符常量</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-variable">System</span>.<span class="cm-variable">out</span>.<span class="cm-variable">println</span>(<span class="cm-string">'A'</span>);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-variable">System</span>.<span class="cm-variable">out</span>.<span class="cm-variable">println</span>(<span class="cm-string">'6'</span>);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-comment">//System.out.println('');两个单引号中间必须有且仅有一个字符 没有不行</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-comment">//System.out.println('ABC');</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" class="cm-tab-wrap-hack" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-comment">//布尔常量</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-variable">System</span>.<span class="cm-variable">out</span>.<span class="cm-variable">println</span>(<span class="cm-atom">true</span>);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-variable">System</span>.<span class="cm-variable">out</span>.<span class="cm-variable">println</span>(<span class="cm-atom">false</span>);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" class="cm-tab-wrap-hack" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-comment">//空常量</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-comment">//空常量不能直接用来打印输出</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-variable">System</span>.<span class="cm-variable">out</span>.<span class="cm-variable">println</span>(<span class="cm-atom">null</span>);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span>}</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">}</span></pre></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 675px;"></div><div class="CodeMirror-gutters" style="display: none; height: 675px;"></div></div></div></pre><hr /><h2><a name='header-n42' class='md-header-anchor '></a>4. 基本数据类型</h2><ul><li><p>基本数据类型：</p><ul><li>整数型： byte short float int long</li><li>浮点型：float double</li><li>字符型：char</li><li>布尔型：boolean</li></ul></li><li><p>引用数据类型：</p><ul><li>字符串 数组 类 接口 Lambda</li></ul></li><li><p>注意事项：</p></li><li><p>1.字符串不是基本类型 而是引用类型</p></li><li><p>2.浮点型可能只是一个近似值 而非精确值</p></li><li><p>3.数据范围与字节不一定相关 如float数据范围比long更加广泛 而float是4个字节 long为8个字节</p></li><li><p>4.浮点数默认类型为double 如果用float应加上后缀F</p></li><li><p>5.整数默认类型是int 如果用long类型应加上L后缀，如：<strong>System.out.println(100L);</strong></p></li></ul><hr /><h2><a name='header-n73' class='md-header-anchor '></a>5. 变量</h2><ul><li><p>变量：</p><ul><li>程序运行期间，内容可以发生改变的量</li></ul></li><li><p>创建一个变量并使用的格式：</p><ul><li>数据类型 变量名称; //创建了一个变量</li><li>变量名称=数据值;//赋值 将右边的数据值赋值交给左边的变量</li></ul></li><li><p>一步到位格式：</p></li><li><p>数据类型 变量名称 =数据值;//在创建一个变量的同时,立刻放入指定的数据值（初始化）</p></li></ul><pre spellcheck="false" class="md-fences md-end-block ty-contain-cm modeLoaded" lang="java" style="break-inside: unset;"><div class="CodeMirror cm-s-inner CodeMirror-wrap" lang="java"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 0px; left: 7.99481px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation" style=""><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-comment">//变量的使用：</span></span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-comment">//创建一个变量</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-comment">//格式：数据类型 变量名称;</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-variable-3">int</span> <span class="cm-variable">num1</span>;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-comment">//向变量中存入一个数据</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-comment">//格式：变量名称=数据值</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-variable">num1</span><span class="cm-operator">=</span><span class="cm-number">10</span>;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-comment">//当打印输出变量名称的时候 显示出来的是变量的内容</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-variable">System</span>.<span class="cm-variable">out</span>.<span class="cm-variable">println</span>(<span class="cm-variable">num1</span>);<span class="cm-comment">// 10</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" class="cm-tab-wrap-hack" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-comment">//改变变量中原本的数字 变成新的数字</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-variable">num1</span><span class="cm-operator">=</span><span class="cm-number">20</span>;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-variable">System</span>.<span class="cm-variable">out</span>.<span class="cm-variable">println</span>(<span class="cm-variable">num1</span>);<span class="cm-comment">// 20</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" class="cm-tab-wrap-hack" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-comment">//使用一步到位格式定义变量</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-comment">//格式：数据类型 变量名称=数据值;</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-variable-3">int</span> <span class="cm-variable">num2</span><span class="cm-operator">=</span><span class="cm-number">45</span>;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-variable">System</span>.<span class="cm-variable">out</span>.<span class="cm-variable">println</span>(<span class="cm-variable">num2</span>);<span class="cm-comment">// 45</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-variable">num2</span><span class="cm-operator">=</span><span class="cm-number">35</span>;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-variable">System</span>.<span class="cm-variable">out</span>.<span class="cm-variable">println</span>(<span class="cm-variable">num2</span>);<span class="cm-comment">// 35</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" class="cm-tab-wrap-hack" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-variable-3">byte</span> <span class="cm-variable">num3</span><span class="cm-operator">=</span><span class="cm-number">30</span>;<span class="cm-comment">//注意 右侧的数值范围不能超过左侧数据类型的取值范围</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-comment">//byte num4=400;//超出了byte的数据范围 发生错误</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-variable-3">short</span> <span class="cm-variable">num5</span><span class="cm-operator">=</span><span class="cm-number">50</span>;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-variable">System</span>.<span class="cm-variable">out</span>.<span class="cm-variable">println</span>(<span class="cm-variable">num5</span>);<span class="cm-comment">// 50</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" class="cm-tab-wrap-hack" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-variable-3">long</span> <span class="cm-variable">num6</span><span class="cm-operator">=</span><span class="cm-number">3000000000L</span>;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-variable">System</span>.<span class="cm-variable">out</span>.<span class="cm-variable">println</span>(<span class="cm-variable">num6</span>);<span class="cm-comment">// 3000000000</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" class="cm-tab-wrap-hack" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-keyword">float</span> <span class="cm-variable">num7</span><span class="cm-operator">=</span><span class="cm-number">2.5F</span>;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-variable">System</span>.<span class="cm-variable">out</span>.<span class="cm-variable">println</span>(<span class="cm-variable">num7</span>);<span class="cm-comment">// 2.5</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" class="cm-tab-wrap-hack" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-variable-3">double</span> <span class="cm-variable">num8</span><span class="cm-operator">=</span><span class="cm-number">1.2</span>;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-variable">System</span>.<span class="cm-variable">out</span>.<span class="cm-variable">println</span>(<span class="cm-variable">num8</span>);<span class="cm-comment">// 1.2</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" class="cm-tab-wrap-hack" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-variable-3">char</span> <span class="cm-variable">zifu1</span><span class="cm-operator">=</span><span class="cm-string">'A'</span>;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-variable">System</span>.<span class="cm-variable">out</span>.<span class="cm-variable">println</span>(<span class="cm-variable">zifu1</span>);<span class="cm-comment">// A</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" class="cm-tab-wrap-hack" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-variable">zifu1</span><span class="cm-operator">=</span><span class="cm-string">'中'</span>;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-variable">System</span>.<span class="cm-variable">out</span>.<span class="cm-variable">println</span>(<span class="cm-variable">zifu1</span>);<span class="cm-comment">// 中</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" class="cm-tab-wrap-hack" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-variable-3">boolean</span> <span class="cm-variable">var1</span><span class="cm-operator">=</span><span class="cm-atom">true</span>;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-variable">System</span>.<span class="cm-variable">out</span>.<span class="cm-variable">println</span>(<span class="cm-variable">var1</span>);<span class="cm-comment">// true</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-variable">var1</span><span class="cm-operator">=</span><span class="cm-atom">false</span>;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-variable">System</span>.<span class="cm-variable">out</span>.<span class="cm-variable">println</span>(<span class="cm-variable">var1</span>);<span class="cm-comment">// false</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" class="cm-tab-wrap-hack" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-variable-3">boolean</span> <span class="cm-variable">var2</span>;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-variable">var2</span><span class="cm-operator">=</span><span class="cm-variable">var1</span>;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-variable">System</span>.<span class="cm-variable">out</span>.<span class="cm-variable">println</span>(<span class="cm-variable">var2</span>);<span class="cm-comment">// false</span></span></pre></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 1103px;"></div><div class="CodeMirror-gutters" style="display: none; height: 1103px;"></div></div></div></pre><p><strong>使用变量时的注意事项：</strong></p><ul><li>1.如果创建多个变量 变量之间的名称不可以重复</li><li>2.对于float和long类型 字母后缀L F 不要丢掉</li><li>3.如果使用byte 和 short类型的变量 右侧的数值范围不能超过左侧数据类型的取值范围</li><li>4.没有进行赋值的变量不能直接使用</li><li>5.变量使用不能超出作用域范围<em>【作用域】：从定义变量开始 直到所属的大括号结束为止</em></li><li>6.可以通过一个语句创建多个变量 一般不推荐</li></ul><pre spellcheck="false" class="md-fences md-end-block ty-contain-cm modeLoaded" lang="java" style="break-inside: unset;"><div class="CodeMirror cm-s-inner CodeMirror-wrap" lang="java"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 0px; left: 7.99481px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation" style=""><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-variable-3">int</span> <span class="cm-variable">num9</span><span class="cm-operator">=</span><span class="cm-number">10</span>;<span class="cm-comment">//创建了一个新的变量 num9</span></span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-comment">//int num9=20;又创建了一个新的变量名字也为num9错误！</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-variable-3">int</span> <span class="cm-variable">num10</span><span class="cm-operator">=</span><span class="cm-number">20</span>;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-variable-3">int</span> <span class="cm-variable">num11</span>;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-variable">num11</span><span class="cm-operator">=</span><span class="cm-number">30</span>;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" class="cm-tab-wrap-hack" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-variable-3">int</span> <span class="cm-variable">num12</span>;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-comment">//System.out.println(num12);没有赋值直接打印出错</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" class="cm-tab-wrap-hack" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-comment">//System.out.println(num13);创建变量之前 不能使用</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-variable-3">int</span> <span class="cm-variable">num13</span><span class="cm-operator">=</span><span class="cm-number">500</span>;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-variable">System</span>.<span class="cm-variable">out</span>.<span class="cm-variable">println</span>(<span class="cm-variable">num13</span>);<span class="cm-comment">// 500</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" class="cm-tab-wrap-hack" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span>{</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-variable-3">int</span> <span class="cm-variable">num14</span><span class="cm-operator">=</span><span class="cm-number">60</span>;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-variable">System</span>.<span class="cm-variable">out</span>.<span class="cm-variable">println</span>(<span class="cm-variable">num14</span>);<span class="cm-comment">// 60</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span>}</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-comment">//System.out.println(num14);// 超出大括号范围 变量不能再使用</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-variable-3">int</span> <span class="cm-variable">num14</span>;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" class="cm-tab-wrap-hack" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-comment">//同时创建三个全部都是int类型的变量</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-variable-3">int</span> <span class="cm-variable">a</span>,<span class="cm-variable">b</span>,<span class="cm-variable">c</span>;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-variable">a</span><span class="cm-operator">=</span><span class="cm-number">10</span>;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-variable">b</span><span class="cm-operator">=</span><span class="cm-number">20</span>;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-variable">c</span><span class="cm-operator">=</span><span class="cm-number">30</span>;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-variable">System</span>.<span class="cm-variable">out</span>.<span class="cm-variable">println</span>(<span class="cm-variable">a</span>);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-variable">System</span>.<span class="cm-variable">out</span>.<span class="cm-variable">println</span>(<span class="cm-variable">b</span>);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-variable">System</span>.<span class="cm-variable">out</span>.<span class="cm-variable">println</span>(<span class="cm-variable">c</span>);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" class="cm-tab-wrap-hack" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-comment">//同时创建三个全部都是int类型的变量 并各自赋值</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-variable-3">int</span> <span class="cm-variable">x</span><span class="cm-operator">=</span><span class="cm-number">100</span>,<span class="cm-variable">y</span><span class="cm-operator">=</span><span class="cm-number">200</span>,<span class="cm-variable">z</span><span class="cm-operator">=</span><span class="cm-number">300</span>;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-variable">System</span>.<span class="cm-variable">out</span>.<span class="cm-variable">println</span>(<span class="cm-variable">x</span>);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-variable">System</span>.<span class="cm-variable">out</span>.<span class="cm-variable">println</span>(<span class="cm-variable">y</span>);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-variable">System</span>.<span class="cm-variable">out</span>.<span class="cm-variable">println</span>(<span class="cm-variable">z</span>);</span></pre></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 765px;"></div><div class="CodeMirror-gutters" style="display: none; height: 765px;"></div></div></div></pre><hr /><h2><a name='header-n108' class='md-header-anchor '></a>6. 数据类型转换</h2><ul><li><p>数据类型转换：</p><ul><li>自动类型转换：
<span>	</span>- 1.特点：代码不需要特殊处理 自动完成
<span>	</span>- 2.规则：数据范围从小到大</li></ul></li></ul><pre spellcheck="false" class="md-fences md-end-block ty-contain-cm modeLoaded" lang="java" style="break-inside: unset;"><div class="CodeMirror cm-s-inner CodeMirror-wrap" lang="java"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 0px; left: 7.99481px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation" style=""><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-variable">System</span>.<span class="cm-variable">out</span>.<span class="cm-variable">println</span>(<span class="cm-number">1024</span>);<span class="cm-comment">// 这就是一个整数 默认int型</span></span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-variable">System</span>.<span class="cm-variable">out</span>.<span class="cm-variable">println</span>(<span class="cm-number">3.14</span>);<span class="cm-comment">// 这就是一个浮点数 默认double型</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" class="cm-tab-wrap-hack" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-comment">// 左边是long类型 右边是默认int型 左右不一样</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-comment">//一个等号代表赋值 将右侧的int常量交给左侧的long变量进行存储</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-comment">//int--&gt;long 符合数据范围从小到大的要求</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-comment">//这一行代码发生了自动类型转换</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-variable-3">long</span> <span class="cm-variable">num15</span><span class="cm-operator">=</span><span class="cm-number">100</span>;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-variable">System</span>.<span class="cm-variable">out</span>.<span class="cm-variable">println</span>(<span class="cm-variable">num15</span>);<span class="cm-comment">// 100</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" class="cm-tab-wrap-hack" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-comment">//左边是double类型 右边是float类型 左右不一样</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-comment">//float--&gt;double 符合数据范围从小到大的要求</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-comment">//发生了自动类型转换</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-variable-3">double</span> <span class="cm-variable">num16</span><span class="cm-operator">=</span><span class="cm-number">2.5F</span>;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-variable">System</span>.<span class="cm-variable">out</span>.<span class="cm-variable">println</span>(<span class="cm-variable">num16</span>);<span class="cm-comment">// 2.5</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" class="cm-tab-wrap-hack" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-comment">//左边是float类型 右边是long类型 左右不一样</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-comment">//long--&gt;float float范围更大一些 符合数据范围从小到大的要求</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-comment">//发生了自动类型转换</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-keyword">float</span> <span class="cm-variable">num17</span><span class="cm-operator">=</span><span class="cm-number">30L</span>;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-variable">System</span>.<span class="cm-variable">out</span>.<span class="cm-variable">println</span>(<span class="cm-variable">num17</span>);<span class="cm-comment">// 30.0</span></span></pre></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 473px;"></div><div class="CodeMirror-gutters" style="display: none; height: 473px;"></div></div></div></pre><hr /><h2><a name='header-n117' class='md-header-anchor '></a>7. 强制类型转换</h2><ul><li><p>强制类型转换：</p><ul><li><p>1.特点：代码需要特殊的格式处理 不能自动完成</p></li><li><p>2.格式：范围小的类型 范围小的变量名 = （范围小的类型）原本范围大的数据;</p><ul><li>左边是int类型 右边是long类型 左右不一样</li><li>long--&gt;int 不是从小到大</li><li>不能自动类型转换</li><li>格式：范围小的类型 范围小的变量名 = （范围小的类型）原本范围大的数据;
int num18=(int)100L;
System.out.println(num18);</li></ul></li></ul></li></ul><p><strong><em>注意事项：</em></strong></p><ul><li>1.强制类型转换一般不推荐使用 因为有可能发生精度损失 数据溢出</li><li>2.byte/short/char这三种类型都可以发生数学运算</li><li>3.byte/short/char这三种类型在运算时都会先被提升为int型后再计算</li><li>4.boolean类型不能发生数据类型转换</li></ul><pre spellcheck="false" class="md-fences md-end-block ty-contain-cm modeLoaded" lang="java" style="break-inside: unset;"><div class="CodeMirror cm-s-inner CodeMirror-wrap" lang="java"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 0px; left: 7.99481px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation" style=""><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-comment">//long强制转换为int类型</span></span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-variable-3">int</span> <span class="cm-variable">num19</span><span class="cm-operator">=</span>(<span class="cm-variable-3">int</span>)<span class="cm-number">60000000000L</span>;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-variable">System</span>.<span class="cm-variable">out</span>.<span class="cm-variable">println</span>(<span class="cm-variable">num19</span>);<span class="cm-comment">//1705032704</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" class="cm-tab-wrap-hack" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-comment">//double--&gt;int 强制类型转换</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-variable-3">int</span> <span class="cm-variable">num20</span><span class="cm-operator">=</span>(<span class="cm-variable-3">int</span>)<span class="cm-number">3.99</span>;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-variable">System</span>.<span class="cm-variable">out</span>.<span class="cm-variable">println</span>(<span class="cm-variable">num20</span>);<span class="cm-comment">// 3 所有小数位都会被舍弃</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" class="cm-tab-wrap-hack" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-variable-3">char</span> <span class="cm-variable">zifu2</span><span class="cm-operator">=</span><span class="cm-string">'A'</span>;<span class="cm-comment">//这是一个字符型变量 里面是大写字母A</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-variable">System</span>.<span class="cm-variable">out</span>.<span class="cm-variable">println</span>(<span class="cm-variable">zifu2</span><span class="cm-operator">+</span><span class="cm-number">1</span>);<span class="cm-comment">// 66 也就是大写字母A被当做65来处理</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" class="cm-tab-wrap-hack" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-variable-3">byte</span> <span class="cm-variable">num21</span><span class="cm-operator">=</span><span class="cm-number">40</span>;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-variable-3">byte</span> <span class="cm-variable">num22</span><span class="cm-operator">=</span><span class="cm-number">50</span>;<span class="cm-comment">// 注意 右侧的数值范围不能超过左侧数据类型的取值范围</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-comment">//byte+byte--&gt;int+int--&gt;int</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-variable-3">int</span> <span class="cm-variable">result1</span><span class="cm-operator">=</span><span class="cm-variable">num21</span><span class="cm-operator">+</span><span class="cm-variable">num22</span>;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-variable">System</span>.<span class="cm-variable">out</span>.<span class="cm-variable">println</span>(<span class="cm-variable">result1</span>);<span class="cm-comment">// 90</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" class="cm-tab-wrap-hack" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-variable-3">short</span> <span class="cm-variable">num23</span><span class="cm-operator">=</span><span class="cm-number">60</span>;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-comment">//byte+short--&gt;int+int--&gt;int</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-comment">//int强制转换为short 注意必须保证逻辑上真实大小本来就没有超过short范围否则会发生数据溢出</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-variable-3">short</span> <span class="cm-variable">result2</span><span class="cm-operator">=</span>(<span class="cm-variable-3">short</span>)(<span class="cm-variable">num23</span><span class="cm-operator">+</span><span class="cm-variable">num22</span>);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-variable">System</span>.<span class="cm-variable">out</span>.<span class="cm-variable">println</span>(<span class="cm-variable">result2</span>); <span class="cm-comment">// 100</span></span></pre></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 495px;"></div><div class="CodeMirror-gutters" style="display: none; height: 495px;"></div></div></div></pre><hr /><h2><a name='header-n147' class='md-header-anchor '></a>8. 数字与字符的对照关系</h2><ul><li><p>数字和字符对照关系表： </p><ul><li>ASCII码表： American Standard Code for Information Interchange 美国信息交换标准代码</li><li>Unicode码：万国码</li></ul></li></ul><ol start='' ><li>48-&#39;0&#39;</li><li>65-&#39;A&#39;</li><li>97-&#39;a&#39;</li></ol><pre spellcheck="false" class="md-fences md-end-block ty-contain-cm modeLoaded" lang="java"><div class="CodeMirror cm-s-inner CodeMirror-wrap" lang="java"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 0px; left: 7.99481px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation" style=""><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-variable-3">char</span> <span class="cm-variable">zifu3</span><span class="cm-operator">=</span><span class="cm-string">'1'</span>;</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-variable">System</span>.<span class="cm-variable">out</span>.<span class="cm-variable">println</span>(<span class="cm-variable">zifu3</span><span class="cm-operator">+</span><span class="cm-number">0</span>);<span class="cm-comment">// 49</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" class="cm-tab-wrap-hack" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-variable-3">char</span> <span class="cm-variable">zifu4</span><span class="cm-operator">=</span><span class="cm-string">'c'</span>;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-comment">//左侧是int型 右侧是char型</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-comment">//char--&gt;int 数据从小到大</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-comment">//发生了自动类型转换</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-variable-3">int</span> <span class="cm-variable">num24</span><span class="cm-operator">=</span><span class="cm-variable">zifu4</span>;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-variable">System</span>.<span class="cm-variable">out</span>.<span class="cm-variable">println</span>(<span class="cm-variable">num24</span>);<span class="cm-comment">// 99</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" class="cm-tab-wrap-hack" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-variable-3">char</span> <span class="cm-variable">zifu5</span><span class="cm-operator">=</span><span class="cm-string">'佳'</span>;<span class="cm-comment">//正确写法</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-variable">System</span>.<span class="cm-variable">out</span>.<span class="cm-variable">println</span>(<span class="cm-variable">zifu5</span><span class="cm-operator">+</span><span class="cm-number">0</span>);</span></pre></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 270px;"></div><div class="CodeMirror-gutters" style="display: none; height: 270px;"></div></div></div></pre><hr /><h2><a name='header-n165' class='md-header-anchor '></a>9. 运算符</h2><ul><li><p>运算符：进行特定操作的符号
四则运算：+ - * /
取模 mod %
首先计算得到表达式的结果，然后再打印输出这个结果</p></li><li><p>对于一个整数的表达式来说 除法为整除</p></li><li><p>只有对于整数的除法来说取模运算符才有意义</p></li><li><p>注意事项：</p><ul><li>一旦运算当中有不同类型的数据 那么结果将会是数据类型范围大的那种。</li></ul></li></ul><pre spellcheck="false" class="md-fences md-end-block ty-contain-cm modeLoaded" lang="java" style="break-inside: unset;"><div class="CodeMirror cm-s-inner CodeMirror-wrap" lang="java"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 0px; left: 7.99481px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation" style=""><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-comment">//两个常量之间可以进行数学运算</span></span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-variable">System</span>.<span class="cm-variable">out</span>.<span class="cm-variable">println</span>(<span class="cm-number">20</span><span class="cm-operator">+</span><span class="cm-number">30</span>);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" class="cm-tab-wrap-hack" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-comment">//两个变量之间可以数学运算</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-variable-3">int</span> <span class="cm-variable">a</span><span class="cm-operator">=</span><span class="cm-number">20</span>;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-variable-3">int</span> <span class="cm-variable">b</span><span class="cm-operator">=</span><span class="cm-number">30</span>;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-variable">System</span>.<span class="cm-variable">out</span>.<span class="cm-variable">println</span>(<span class="cm-variable">a</span><span class="cm-operator">-</span><span class="cm-variable">b</span>);<span class="cm-comment">// -10</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" class="cm-tab-wrap-hack" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-comment">//变量和常量之间可以混合使用</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-variable">System</span>.<span class="cm-variable">out</span>.<span class="cm-variable">println</span>(<span class="cm-variable">a</span><span class="cm-operator">*</span><span class="cm-number">10</span>);<span class="cm-comment">// 200</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" class="cm-tab-wrap-hack" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-variable-3">int</span> <span class="cm-variable">x</span><span class="cm-operator">=</span><span class="cm-number">10</span>;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-variable-3">int</span> <span class="cm-variable">y</span><span class="cm-operator">=</span><span class="cm-number">3</span>;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-variable-3">int</span> <span class="cm-variable">result3</span><span class="cm-operator">=</span><span class="cm-variable">x</span><span class="cm-operator">/</span><span class="cm-variable">y</span>;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-variable">System</span>.<span class="cm-variable">out</span>.<span class="cm-variable">println</span>(<span class="cm-variable">result3</span>);<span class="cm-comment">// 3</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" class="cm-tab-wrap-hack" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-variable-3">int</span> <span class="cm-variable">result4</span><span class="cm-operator">=</span><span class="cm-variable">x</span><span class="cm-operator">%</span><span class="cm-variable">y</span>;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-variable">System</span>.<span class="cm-variable">out</span>.<span class="cm-variable">println</span>(<span class="cm-variable">result4</span>);<span class="cm-comment">// 1 mod</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" class="cm-tab-wrap-hack" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-comment">//int+double--&gt;double+double--&gt;double</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-variable-3">double</span> <span class="cm-variable">result5</span><span class="cm-operator">=</span><span class="cm-variable">x</span><span class="cm-operator">+</span><span class="cm-number">2.5</span>;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-variable">System</span>.<span class="cm-variable">out</span>.<span class="cm-variable">println</span>(<span class="cm-variable">result5</span>);<span class="cm-comment">// 12.5</span></span></pre></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 495px;"></div><div class="CodeMirror-gutters" style="display: none; height: 495px;"></div></div></div></pre><hr /><h2><a name='header-n180' class='md-header-anchor '></a>10. &#39;+&#39;的三种用法</h2><ul><li><p>&#39;+&#39;的三种用法：</p><ul><li>1.对于数值 相加</li><li>2.对于字符char 计算之前 char会被提升为int后计算</li><li>3.对于字符串String（首字母大写 并不是关键字） 加号代表字符串连接操作</li><li>任何数据类型和字符串进行连接 结果都会变成字符串</li></ul></li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n193" mdtype="fences" style="break-inside: unset;">		//字符串类型变量的基本使用
		//数据类型 变量名称 = 数据值;
		String str1="HELLO";
		System.out.println(str1);// HELLO
		
		System.out.println("HELLO"+"world");// HELLOworld
		
		String str2="Java";
		//String + int --&gt;String
		System.out.println(str2+20);// Java20
		
		//优先级问题
		//String + int + int
		//String	   + int
		//String
		System.out.println(str2+20+30);// Java2030
		
		System.out.println(str2+(20+30));// Java50

</pre><hr /><h2><a name='header-n195' class='md-header-anchor '></a>11. 自增运算符</h2><ul><li><p>自增运算符：++ 自减运算符：--</p></li><li><p>基本含义：让一个变量涨一个数字1 或 降一个数字1</p></li><li><p>使用格式：写在变量前后 ++num，num++，--num，num--</p></li><li><p>使用方式：</p><ul><li>1.单独使用 不和其他任何操作混合 自己独立成为一个步骤</li><li>2.混合使用 和其他操作混合</li></ul></li><li><p>使用区别：</p><ul><li>1.单独使用时 前++后++无任何区别 ++num与num++完全一样</li></ul></li><li><p>2.混合使用时 A.前++ 变量立刻马上+1 然后拿着结果进行使用 【先加后用】B.后++ 首先使用变量本来的数值使用 然后再+1 【先用后加】</p></li><li><p>注意事项：</p><ul><li>只有变量才能自增自减 常量不可以改变 所以不能用</li></ul></li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n222" mdtype="fences" style="break-inside: unset;">		int num25=10;
		System.out.println(num25);// 10
		++num25;// 单独使用 前++
		System.out.println(num25);// 11
		num25++;// 单独使用 后++
		System.out.println(num25);// 12
		System.out.println("================");
		
		//与打印操作混合使用
		int num26=20;
		//混合使用 先++ 立刻马上变成21 打印结果21
		System.out.println(++num26);// 21
		System.out.println(num26);// 21
		System.out.println("================");
		
		int num27=30;
		//混合使用 后++ 首先使用变量本来的30 然后变量加1得到31
		System.out.println(num27++);// 30
		System.out.println(num27);// 31
		System.out.println("================");
		
		int num28=40;
		//与赋值操作混合
		//混合使用 前-- 变量立刻马上-1变成39 将39给result6
		int result6=--num28;
		System.out.println(result6);// 39
		System.out.println(num28);// 39
		System.out.println("================");
		
		int num29=50;
		//混合使用 后-- 首先把原来的数值50给result7 然后自己-1变为49
		int result7=num29--;
		System.out.println(result7);// 50
		System.out.println(num29);// 49
		System.out.println("================");
		
		int x=10;
		int y=20;
		// 11 + 20 = 31
		int result8=++x+y--;
		System.out.println(result8);// 31
		System.out.println(x);// 11 
		System.out.println(y);// 19

</pre><hr /><h2><a name='header-n224' class='md-header-anchor '></a>12. 赋值运算符</h2><ul><li><p>赋值运算符：</p><ul><li><p>基本赋值运算符： = 代表将右侧的数据交给左侧的变量 int a=10;</p></li><li><p>复合赋值运算符：</p><ul><li>+=<span>		</span>a+=3<span>	</span>相当于<span>		</span>a = a+3</li><li>-=<span>		</span>b-=4<span>	</span>相当于<span>		</span>b = b-4</li><li>×=<span>		</span>c× =5<span>	</span>相当于<span>		</span>c = c*5</li><li>/=<span>		</span>d/=6<span>	</span>相当于<span>		</span>d = d/6</li><li>%=<span>		</span>e%=7<span>	</span>相当于<span>		</span>e = e%7</li></ul></li></ul></li><li><p>注意事项：</p><ul><li>1.只有变量才能使用赋值运算符 常量不能进行赋值</li><li>2.复合赋值运算符其中隐含了一个强制类型转换</li></ul></li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n251" mdtype="fences" style="break-inside: unset;">		int a=10;
		//按照公式进行翻译 a=a+5
		//a = a+5
		//a = 15
		//a本来是10 现在重新赋值得15
		a+=5;
		System.out.println(a);// 15
		
		int x=10;
		//x=x%3;
		//x=10%3;
		//x=1;
		//x本来是10 现在重新赋值得1
		x%=3;
		System.out.println(x);// 1
		
		//50=30;常量不能进行赋值 不能写在赋值运算符的左边 错误写法！
		//隐含强制类型转换
		byte num=30;
		//num=num+5;
		//num=byte+int;
		//num=int+int;
		//num=int;
		//num=(byte)int;
		num+=5;
		System.out.println(num);// 35

</pre><hr /><h2><a name='header-n253' class='md-header-anchor '></a>13. 比较运算符</h2><ul><li><p>比较运算符：</p><ul><li>大于&gt;小于&lt; 等于== 大于等于&gt;= 小于等于&lt;= 不等于!=</li></ul></li><li><p>注意事项：</p><ul><li>1.比较运算符的结果一定是一个boolean值 成立为true 否则为false</li><li>2.多次判断 不能连着写 不允许1&lt;x&lt;3写法</li></ul></li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n267" mdtype="fences" style="break-inside: unset;">		System.out.println(10 &gt; 5);// true
		int num30=10;
		int num31=12;
		System.out.println(num30 &lt; num31);// true
		System.out.println(num31 &gt;= 100);// false
		System.out.println(num31 &lt;= 100);//true
		System.out.println(num31 &lt;= 12);// true
		System.out.println("============");
		System.out.println(10 == 10);// true
		System.out.println(20 != 25);// true
		System.out.println(20 != 20);// false
		
		int x=3;
		//System.out.println(1&lt;x&lt;5);错误写法 编译报错 不能连着写

</pre><hr /><h2><a name='header-n269' class='md-header-anchor '></a>14. 逻辑运算符</h2><ul><li><p>逻辑运算符：</p><ul><li>与&amp;&amp; 全都是true才是true 否则就是false</li><li>或|| 至少一个是true就是true 全都是false才是false</li><li>非！ 取反 本来是true 取反后为false 本来是false 取反变成true</li><li>&amp;&amp; || 有短路效果 ：如果根据左边已经可以判断到最终结果 那么右边的代码将不再执行</li></ul></li><li><p>注意事项：</p><ul><li><p>1.逻辑运算符只能用于boolean值</p></li><li><p>2.与 或 需要左右各自有一个boolean值 但是取反只要有唯一一个boolean值即可</p></li><li><p>3.与 或 两种运算符 入伙有多个条件 可以连续写</p><ul><li>条件A&amp;&amp;条件B&amp;&amp;条件C</li><li>对于1&lt;c&lt;3的情况 int c=2;</li><li>1&lt;c&amp;&amp;c&lt;2;</li></ul></li></ul></li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n298" mdtype="fences" style="break-inside: unset;">		System.out.println(true &amp;&amp; false);// false
		//true&amp;&amp;true--&gt;true
		System.out.println(3&lt;4&amp;&amp;10&gt;5);// true
		System.out.println("============");
		
		System.out.println(true||false);// false
		System.out.println(true||true);// true
		System.out.println(false||false);// false
		System.out.println("============");
		
		System.out.println(true);// true
		System.out.println(!true);// false
		System.out.println("============");
		
		int a=10;
		//false &amp;&amp; ...
		System.out.println(3&gt;4&amp;&amp;++a&lt;10);// false
		System.out.println(a);// 10
		System.out.println("============");
		
		int b=20;
		//true || ...
		System.out.println(3&lt;4||++b&lt;100);// true
		System.out.println(b);// 20

</pre><hr /><h2><a name='header-n300' class='md-header-anchor '></a>15. 三元运算符</h2><ul><li><p>三元运算符： 需要三个数据才可以进行操作的运算符</p><ul><li><p>格式：数据类型 变量名称 = 判断条件 ? 表达式A : 表达式B;</p></li><li><p>流程：</p><ul><li>首先判断条件是否成立：</li><li>如果成立为true 那么将表达式A的值给左侧的变量</li><li>如果不成立为false 那么将表达式B的值给左侧的变量</li></ul></li></ul></li><li><p>注意事项：</p><ul><li>1.必须同时保证表达式A和表达B都符合左侧数据类型的要求</li><li>2.三元运算符的结果必须被使用</li></ul></li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n323" mdtype="fences">		int a=10;
		int b=20;
		//数据类型 变量名称 = 判断条件 ? 表达式A : 表达式B;
		//判断a&gt;b是否成立 如果成立则将a的值赋给max 否则将b的值给max 二者选其一
		int max=a&gt;b?a:b;// 最大值的变量
		System.out.println("最大值："+max);// 20
		
		//int result=3&gt;4?2.5:10; 错误写法！
		System.out.println(a&gt;b?a:b);//正确写法
		//a&gt;b?a:b; 错误写法！

</pre><hr /><h2><a name='header-n325' class='md-header-anchor '></a>16. 方法的定义</h2><ul><li>定义一个方法的格式： </li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n329" mdtype="fences">public static void 方法名称(){
	方法体;
}

</pre><ul><li>方法名称的命名规则和变量一样 使用小驼峰</li><li>方法体：也就是大括号当中可以包含任意语句</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n335" mdtype="fences">public static void cook(){
	//me;
}

</pre><ul><li><p>注意事项：</p><ul><li>1.方法定义的先后顺序无所谓</li><li>2.方法的定义不能产生嵌套包含关系</li><li>3.方法定义之后不会执行 如果要执行 一定要进行方法的【调用】</li></ul></li><li><p>调用方法的格式：</p></li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n348" mdtype="fences">方法名称();

</pre><hr /><h2><a name='header-n350' class='md-header-anchor '></a>17. 编译器的优化</h2><ul><li><p>编译器的优化：</p><ul><li><p>对于byte/short/char三种类型来说 如果右侧赋值没有超出范围</p></li><li><p>那么javac编译器将会自动隐含地为我们补上一个(byte)(short)(char)</p><ul><li>1.如果没有超出左侧范围 编译器补上强转</li><li>2.如果右侧超出了左侧范围 那么编译器直接报错</li></ul></li></ul></li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n364" mdtype="fences">		//右侧确实是一个int 数字 但是没有超出左侧的范围 就是正确的
		//int--&gt;byte 不是自动类型转换
		byte num32=/*byte*/ 30;// 右侧没有超出左侧范围
		System.out.println(num32);// 30
		
		//byte num33=128; 右侧超出了左侧的范围
		
		//int--&gt;char 没有超出范围
		//编译器自动补上一个隐含的(char)
		char zifu6=/*char*/ 65;
		System.out.println(zifu6);// A

</pre><ul><li><p>编译器的优化：</p><ul><li>在给编译器进行赋值的时候 如果右侧的表达式中全为常量 没有任何变量</li><li>那么编译器javac将会直接将若干个常量表达式计算得到结果</li><li>short result=5+8;//等号右边都是常量</li><li>相当于short result=13; 右侧没有超出左侧范围 所以正确</li><li>但要注意：一旦表达式中有变量参与 就没有这种优化了</li></ul></li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n379" mdtype="fences">		short num34=10;// 正确写法 右侧没有超出左侧范围
		short a=5;
		short b=10;
		//short+short--&gt;int+int--&gt;int
		//short result=a+b; 错误写法 左侧需要是int类型
		
		//右侧不用变量 采用常量时
		short result9=5+8;
		System.out.println(result9);// 13
		
		//short result10=5+a+8; 错误写法！

</pre><hr /><h2><a name='header-n381' class='md-header-anchor '></a>18. 选择结构</h2><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n382" mdtype="fences" style="break-inside: unset;">if(表达式){
	语句体;
}

if(关系表达式){
	语句体 1 ;
} else {
	语句体 2 ;
}

if(判断条件1){
	执行语句1;
} else if (判断条件2) {
	执行语句2;
} else if (判断条件3) {
	执行语句3;
}...
  else if (判断条件n) {
	执行语句n;
} else {
	执行语句n+1;
}

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n383" mdtype="fences" style="break-inside: unset;">		if(num%2==0){
			System.out.println("odd");
		} else {
			System.out.println("ji");
		}
		int x=-10;
		int y;
		if(x&gt;=3){
			y=2*x+3;
		} else if (-1&lt;x&amp;&amp;x&lt;3) {
			y=2*x;
		} else {
			y=2*x-1;
		}
		System.out.println("结果是"+y);

</pre><hr /><h2><a name='header-n385' class='md-header-anchor '></a>19. switch语句</h2><ul><li><p>注意事项：</p><ul><li>1.多个case后面的数值不可以重复</li><li>2.switch后面的小括号中只能是下列数据类型：
基本数据类型：byte/short/int/char
引用数据类型：String字符串、enum枚举。</li><li>3.switch语句格式很灵活：前后顺序可以颠倒 break可以省略
&quot;匹配哪一个case就从哪一个位置向下执行 直到遇到break或整体结束为止&quot;</li></ul></li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n396" mdtype="fences" style="break-inside: unset;">选择语句 switch
	switch(表达式){
		case 常量值1:{
			语句体;
			break;
		}
		case 常量值2:{
			语句体;
			break;
		}
		default:{
			语句体;
			break;
		}
	}

</pre><hr /><h2><a name='header-n398' class='md-header-anchor '></a>20. 循环结构</h2><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n399" mdtype="fences">for循环：
for(初始化语句;判断条件;步进语句){
	循环体;
}

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n400" mdtype="fences">		for(int i=0;i&lt;100;i++){
			System.out.println("我想找对象"+i);
		}

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n401" mdtype="fences" style="break-inside: unset;">while循环标准格式：

while(条件判断){
	循环体;
}

扩展格式：

初始化语句;
while(条件判断){
	循环体;
	步进语句;
}

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n402" mdtype="fences">		int i=0;//初始化语句
		while(i&lt;10){// 判断条件
			System.out.println(i);// 循环体
			i++;// 步进语句
		}

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n403" mdtype="fences" style="break-inside: unset;">循环语句 do-while循环标准格式：

do{
	循环体;
} while (条件判断);

扩展格式：

初始化语句：
do{
	循环体;
	步进语句;
} while (条件判断);

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n404" mdtype="fences">		//1-100之间偶数和
		int sum=0;
		for(int i=1;i&lt;=100;i++){
			if(i%2==0)
				sum+=i;
		}
		System.out.println(sum);

</pre><ul><li><p>三种循环的区别：</p><ul><li>1.如果判断条件从来没有满足过 for while 将执行0次 do-while循环执行1次</li><li>2.for循环的变量在小括号内定义 只有在循环内部才可以使用 while 和 do-while循环初始化语句本来就在外面 所以出循环之后仍可以继续使用</li></ul></li></ul><hr /><h2><a name='header-n414' class='md-header-anchor '></a>21. 循环控制语句</h2><ul><li><p>循环控制语句：</p><ul><li><p>1.break：</p><ul><li>1.可以用在switch语句中 一旦执行 switch语句立刻结束</li><li>2.用于循环语句中 一旦执行 整个循环语句立刻结束 打断循环</li></ul></li><li><p>2.continue：一旦执行 立刻跳过当前循环 马上开始下一次循环</p></li></ul></li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n428" mdtype="fences">//死循环
while(true){
	循环体;
}
//死循环之后的语句在编译时将发生无法访问的错误!

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n429" mdtype="fences">//循环嵌套
for(int hour=0;hour&lt;24;hour++){
	for(int minute=0;minute&lt;60;minute++){
		for(int second=0;second&lt;60;second++){
			System.out.println(hour+"点"+minute+"分"+second+"秒");
		}
	}
}

</pre><hr /><h2><a name='header-n431' class='md-header-anchor '></a>22. IDEA常用快捷键</h2><ul><li><p>IDEA常用快捷键：</p><ul><li>Alt+Enter 导入包 自动修正代码</li><li>Ctrl+Y 删除光标所在行</li><li>Ctrl+D 复制光标所在行的内容 插入光标位置下面</li><li>Ctrl+Alt+L 格式化代码</li><li>Ctrl+/ 单行注释 再按取消注释</li><li>Ctrl+Shift+/ 选中代码注释 多行注释 再按取消注释</li><li>Alt+Ins 自动生成代码 toString get set 等方法</li><li>Alt+Shift+上下箭头 移动当前代码行</li></ul></li></ul><hr /><h2><a name='header-n453' class='md-header-anchor '></a>23. 初识方法</h2><ul><li>方法的定义完整格式：</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n457" mdtype="fences">修饰符 返回值类型 方法名称 (参数类型 参数名称, ...){
	方法体;
	return 返回值;
}

</pre><ul><li>修饰符：现阶段固定写法 public static</li><li>返回值类型：最终产生的数据结果的类型</li><li>方法名称：方法的名字 小驼峰式</li><li>参数类型：进入方法的数据的类型</li><li>参数名称：进入方法的数据对应的变量名称</li><li>参数如果有多个 用逗号进行分隔</li><li>方法体：方法需要做的事情 若干行代码</li><li>return：两个作用 第一停止当前方法 第二将后面的返回值还给调用处</li><li>返回值：方法执行后最终产生的数据结果</li><li>return 后面的返回值必须和方法名称前面的返回值类型保持一致</li><li>有参数：小括号中有内容 一个方法需要一些数据条件才能完成任务</li><li>无参数：小括号留空 一个方法不需要任何数据条件就能完成任务</li></ul><p><strong>举例</strong></p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n484" mdtype="fences">	//定义一个两数相加的方法：
    public static int add(int a,int b){
        int result=a+b;
        return result;
    }

</pre><h2><a name='header-n485' class='md-header-anchor '></a>24. 方法的调用</h2><ul><li><p>方法的调用：</p><ul><li>1.单独调用：方法名称(参数);</li><li>2.打印调用：System.out.println(方法名称(参数));</li><li>3.赋值调用：数据类型 变量名称 = 方法名称(参数);</li></ul></li><li><p>注意：返回值类型固定写为void 这种方法只能单独调用 不能打印调用或赋值调用，有返回值时 可以单独调用 打印调用 和 赋值调用</p></li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n498" mdtype="fences">System.out.println("==========");
//单独调用
add(10,20);
System.out.println("==========");
//打印调用
System.out.println(add(10,20));// 30
System.out.println("==========");
//赋值调用
int number=add(15,25);
number+=100;
System.out.println("变量的值"+number);

</pre><p><strong>举例</strong></p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n500" mdtype="fences">	//定义一个方法 判断两个数是否相同
	public static boolean isSame(int a,int b){
		//语句一：boolean same = a==b ? true : false; return same;
		//语句二：boolean same = a==b; return same;
		//语句三：boolean same; if(a==b){same=true}else{same=false} return same;
		//语句四：(执行)
		return a==b;
    }
	
	System.out.println(isSame(10,20));
    System.out.println(isSame(20,20));

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n501" mdtype="fences">    //定义一个方法 打印指定次数的HELLO WORLD
    public static void print(int a){
        for (int i=0;i&lt;a;i++){
            System.out.println("HELLO WORLD "+i);
        }
    }
    
	print(10);

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n502" mdtype="fences">    //定义一个方法求出1-100的和
    public static int sum(){
        int sum=0;
        for (int i = 1; i &lt;= 100; i++) {
            sum+=i;
        }
        return sum;
    }

    System.out.println("1-100的和为："+sum());

</pre><ul><li><p>使用方法的注意事项：</p><ul><li>1.方法应该定义在类中 但是不能在方法中再定义方法 不能嵌套</li><li>2.方法定义的前后顺序无所谓</li><li>3.方法定义之后不会执行 如果希望执行 一定要调用 单独调用 打印调用 赋值调用</li><li>4.如果方法有返回值 那么必须写上 return 返回值; 不能没有</li><li>5.return 后面的返回值必须和方法名称前面的返回值类型保持一致</li><li>6.对于一个void没有返回值的方法 不能写return后面的返回值 只能写return自己</li><li>7.对于void方法当中最后一行的return可以省略不写</li><li>8.一个方法当中可以有多个return语句 但是必须保证同时只有一个会被执行到 两个return不能连写</li></ul></li></ul><hr /><h2><a name='header-n524' class='md-header-anchor '></a>25. 方法的重载</h2><ul><li><p>方法的重载：
多个方法的名称一样 但是参数列表不一样</p></li><li><p>好处：
只需要记住一个方法名称 就可以实现类似的多个功能</p><p><strong>举例</strong></p></li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n531" mdtype="fences" style="break-inside: unset;">    //方法的重载：
    public static int sum(int a,int b){
        System.out.println("有两个参数的方法执行");
        return a+b;
    }
    public static int sum(int a,int b,int c){
        System.out.println("有三个参数的方法执行");
        return a+b+c;
    }
    public static int sum(int a,int b,int c,int d){
        System.out.println("有四个参数的方法执行");
        return a+b+c+d;
    }
    
    //方法重载
    System.out.println(sum(10,20));// 30
	System.out.println(sum(10,20,30));// 60
	System.out.println(sum(10,20,30,40));// 100

</pre><ul><li><p>方法重载与下列因素相关：</p><ul><li>1.参数个数不同</li><li>2.参数类型不同</li><li>3.参数的多类型顺序不同</li></ul></li><li><p>方法重载与下列因素无关：</p><ul><li>1.与参数的名称无关</li><li>2.与方法的返回值类型无关</li></ul></li></ul><p><strong>举例</strong></p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n550" mdtype="fences" style="break-inside: unset;">	//方法重载
    public static int sum(int a,int b){
        return a+b;
    }
	
	public static int sum(double a,double b){
        return a+b;
    }
	
	public static int sum(int a,int b,int c){
        return a+b+c;
    }

	public static int sum(double a,int b){
        return a+b;
    }

	public static int sum(int a,double b){
        return a+b;
    }
	
	//报错
	public static int sum(int x,int y){
        return x+y;
    }
	
	public static double sum(int a,int b){
        return (double)(a+b);
    }

</pre><hr /><h2><a name='header-n552' class='md-header-anchor '></a>26. 数组及初始化</h2><ul><li><p>数组：同时存放多个数据值</p></li><li><p>特点：</p><ul><li>1.数组是一种引用数据类型</li><li>2.数组当中的多个数据类型必须统一</li><li>3.数组的长度在程序运行期间不可改变</li></ul></li><li><p>两种常见的数组初始化：</p><ul><li>1.动态初始化(指定长度)</li><li>2.静态初始化(指定长度)</li></ul></li><li><p>动态初始化数组格式:</p><ul><li><p>数据类型[] 数组名称 = new 数据类型 [数组长度]</p></li><li><p>含义解析：</p><ul><li>左侧的数据类型：也就是数组中保存的数据 全都是统一的什么类型</li><li>左侧的中括号：代表一个数组</li><li>左侧数组名称：代表数组的名字</li><li>右侧的new：代表创建数组的动作</li><li>右侧的数据类型：必须和左边数据类型保持一致</li><li>右侧中括号的长度：也就是数组中到底可以保存多少个数据 是一个int类型数据</li></ul></li></ul></li></ul><p><strong>举例</strong></p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n593" mdtype="fences">		//创建一个数组 里面可以存放300个int数据
		//格式：数据类型[] 数组名称 = new 数据类型 [数组长度]
		int[] arrayA = new int[300];
		
		//创建一个数组 能存放10个double类型的数据
		double[] arrayB = new double[10];
		
		//创建一个数组 能存放5个字符串
		String[] ayyayC = new String[5];	

</pre><ul><li><p>静态初始化数组格式：</p><ul><li>数据类型[] 数组名称 = new 数据类型[] {元素1,元素2,....};</li></ul></li><li><p>注意事项：虽然静态初始化没有直接告诉长度 但可根据大括号里面的元素具体内容推算数组的长度</p></li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n602" mdtype="fences">	//直接创建一个数组 里面装的是int数字 具体为 5 15 25
	int[] arrayD = new int[] {5,15,25};
	
	//创建一个数组 存储字符串 "hello" "world" "java"
	String[] arrayE =new String[] {"hello","world","java"};

</pre><ul><li><p>静态初始化数组省略格式：</p><ul><li>数据类型[] 数组名称 = {元素1,元素2,....};</li></ul></li><li><p>注意事项：</p><ul><li>1.静态初始化没有指定长度 仍会自动推算得到长度</li><li>2.动态初始化 静态初始化都可以拆分为两个步骤</li><li>3.静态初始化一旦使用省略格式 则不能拆分为两个步骤</li></ul></li></ul><p><strong>举例</strong></p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n619" mdtype="fences">	//省略格式的静态初始化
	int[] arrayF = {10,20,30};
	
	//静态初始化 动态初始化 拆分为两个步骤
	int[] arrayG;
	arrayG = new int[] {10,20,30};
	int[] arrayH;
	arrayH = new int[5];
	
	//静态初始化的省略格式不能拆分为两个步骤
	int[] arrayI;
	arrayI = {10,20,30};//错误写法！

</pre><hr /><h2><a name='header-n621' class='md-header-anchor '></a>27. 访问数组元素</h2><ul><li><p>访问数组元素：</p><ul><li>直接打印数组名称 得到的是数组对应内存地址的哈希值 </li><li>访问数组元素的格式：数组名称[索引值];</li><li>索引值从0开始 一直到数组的长度-1为止</li></ul></li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n632" mdtype="fences">	//静态初始化的省略格式
	int[] array ={10,20,30};
	System.out.println(array);//打印数组对应内存地址哈希值
	System.out.println(array[0]);// 10
	System.out.println(array[1]);// 20
	System.out.println(array[2]);// 30
	
	int num=array[1];
	System.out.println(num);// 20

</pre><ul><li>使用动态初始化数组 其中的元素将会自动拥有一个默认值</li><li>整数类型：默认为0 浮点数类型：默认为0.0 字符类型：默认为&#39;\u0000&#39; </li><li>布尔类型：默认为false 引用类型：默认为null</li><li>注意事项：静态初始化也有默认值的过程 系统自动马上将默认值换成了大括号中的数值*</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n642" mdtype="fences">	//动态初始化一个数组
	int[] array=new int[3];
	System.out.println(array);//内存地址哈希值
	System.out.println(array[0]);// 0
	System.out.println(array[1]);// 0
	System.out.println(array[2]);// 0
	
	array[1]=123;
	System.out.println(array[0]);// 0
	System.out.println(array[1]);// 123
	System.out.println(array[2]);// 0

</pre><ul><li>Java的内存划分为5个部分：</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n646" mdtype="fences">	1.栈(Stack)：存放的都是方法中的局部变量 方法的运行一定要在栈中运行
	  局部变量：方法的参数 或者说方法{}内部的变量
	  作用域：一旦超出作用域 立刻从栈内存当中消失
	2.堆(Heap)：凡是new出的东西都在堆中
	  堆内存里面的东西都有一个地址值：16进制
	  堆内存里面的数据 都有默认值
	  整数类型：默认为0 浮点数类型：默认为0.0 字符类型：默认为'\u0000' 
	  布尔类型：默认为false 引用类型：默认为null
	3.方法区(Method Area):存储.class相关信息 包含方法的信息
	4.本地方法栈(Native Method Stack)：与操作系统相关
	5.寄存器(pc Register):与CPU相关

</pre><ul><li>数组索引编号从0开始到数组长度-1为止</li><li>如果访问数组元素索引编号并不存在 则将发生数组索引越界异常 
<code>ArrayIndexOutOfBoundsException</code></li><li>所有的引用类型变量 都可以赋值为一个null 但是代表其中什么都没有</li><li>数组必须进行new初始化才能使用其中的元素</li><li>如果只是赋值了一个null没有进行new创建 则将发生空指针异常
<code>NullPointerException</code></li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n658" mdtype="fences">	int[] array = null;
	array = new int[3];
	System.out.println(array[0]

</pre><ul><li>获取数组长度：数组名称.length 得到一个int数字</li><li>数组一旦创建 程序运行期间 长度不可改变</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n664" mdtype="fences">        int[] arrayA={1,2,3,5,6,88,9,48,4,4,7,9,2,7,10,88,54,1};
        int len= arrayA.length;
        System.out.println("arrayA的长度是"+len);
        int[] arrayB=new int[3];
        System.out.println(arrayB.length);// 3
        System.out.println(arrayB);
        System.out.println("==============");
        arrayB=new int[5];
        System.out.println(arrayB.length);// 5
        System.out.println(arrayB);
        System.out.println("==============");

</pre><ul><li>数组遍历</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n668" mdtype="fences">        int[] arrayA={1,2,3,5,6,88,9,48,4,4,7,9,2,7,10,88,54,1};
		int len= arrayA.length;
		for循环 次数就是数组的长度
        for (int i = 0; i &lt; arrayA.length; i++) {
			System.out.print(" "+arrayA[i]);
        }

</pre><ul><li>数组最值问题</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n672" mdtype="fences" style="break-inside: unset;">        int min=arrayA[0],max=arrayA[0];
        for (int i = 1; i &lt; arrayA.length; i++) {
            System.out.print(" "+arrayA[i]);
            if(min&gt;arrayA[i]){
                min=arrayA[i];
            }
            if(max&lt;arrayA[i]){
                max=arrayA[i];
            }
        }
        System.out.println();
        System.out.println("arrayA的最小值为"+min);
        System.out.println("arrayA的最大值为"+max);

</pre><ul><li>数组元素反转</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="[1,2,3,4]-->[4,3,2,1]" contenteditable="false" cid="n676" mdtype="fences">	初始化语句：int min=0,int max =array.length-1
	条件判断：min&lt;max
	步进表达式：min++,max--
	循环体：int temp 交换array[min] array[max]

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n677" mdtype="fences" style="break-inside: unset;">        for (int i = 0; i &lt; arrayA.length; i++) {
            System.out.print(" "+arrayA[i]);
        }
        System.out.println();
        for (int min = 0,max=arrayA.length-1; min &lt;max; min++,max--) {
            int temp;
            temp=arrayA[min];
            arrayA[min]=arrayA[max];
            arrayA[max]=temp;
        }
        for (int i = 0; i &lt; arrayA.length; i++) {
            System.out.print(" "+arrayA[i]);
        }

</pre><ul><li><p>数组作为方法参数_传址</p></li><li><p>数组作为方法返回值_返回地址</p><ul><li>数组作为方法参数 向小括号里进行传参 传递的是数组的地址</li></ul></li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n686" mdtype="fences" style="break-inside: unset;"> public static void printarrayA(int[] array) {

        System.out.println("传递的参数是："+array);
        for (int i = 0; i &lt; array.length; i++) {
            System.out.print(" " + array[i]);
        }
    }
	printarrayA(arrayA);// 调用

	//如果希望一个方法中可以返回多个相同类型的返回值 可以使用一个数组作为返回值类型即可

    public static int[] calculate(int a,int b,int c){
        int sum=a+b+c;
        int avg=sum/3;
        
        //int[] array=new int[2];
        //array[0]=sum;
        //array[1]=avg;
        //return array;
        
        int[] array={sum,avg};
        System.out.println("array of address is:"+array);
        return array;
		
		int[] result=calculate(10,20,30);
        System.out.println("result of address is:"+result);
        System.out.println("sum="+result[0]);
        System.out.println("avg="+result[1]);

</pre><hr /><h2><a name='header-n688' class='md-header-anchor '></a>28. 面向对象与面向过程</h2><ul><li>面向过程：当需要实现一个功能的时候 具体每一步都要亲力亲为 详细处理每一个细节</li><li>面向对象：当需要实现一个功能的时候 不关心具体步骤 只是找一个可以实现该功能的对象</li></ul><p><strong>示例</strong></p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n695" mdtype="fences" style="break-inside: unset;">	//打印输出 [10,20,30,40,50]
	//面向过程：
   //打印[10,20,30,40,50]
      int[] array={10,20,30,40,50};
      System.out.print("[");
      for (int i = 0; i &lt; array.length; i++) {
          if(i==array.length-1){
              System.out.println(array[i]+"]");
          } else {
              System.out.print(array[i]+",");
          }
      }
      System.out.println("================");
      //面向对象 打印[10,20,30,40,50]
      System.out.println(Arrays.toString(array));

</pre><hr /><h2><a name='header-n697' class='md-header-anchor '></a>29. 类</h2><ul><li><p>类的定义：</p><ul><li>成员变量：
String name;
int age;</li><li>成员行为：
public void eat(){}
public void sleep(){}</li></ul></li><li><p>成员变量直接定义在类中 在方法外</p></li><li><p>成员方法不要写static关键字</p></li><li><p>通常情况下 一个类不能直接使用 需要根据类创建一个对象才能使用</p><ul><li>1.导包： 指出需要使用的类在什么位置
import 包名称.类名称;
import demos.democlass;</li><li>对于和当前类属于同一个包的情况 可以省略包语句不写</li><li>2.创建格式：
类名称 对象名 = new 类名称();
democlass stu = new democlass();</li><li>3.使用：
使用成员变量：对象名.成员变量名
使用成员方法：对象名.成员方法名(参数);</li></ul></li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n721" mdtype="fences" style="break-inside: unset;"> 		//导包
        //创建：类名称 对象名 = new 类名称();
        democlass stu = new democlass();
        //使用成员变量
        System.out.println(stu.name);// null
        System.out.println(stu.age);// 0

        System.out.println();
        //改变对象当中的成员变量内容
        //将右侧的字符串赋值交给stu对象当中的name成员变量
        stu.name="cow";
        stu.age=20;
        System.out.println(stu.name);
        System.out.println(stu.age);

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n722" mdtype="fences" style="break-inside: unset;">		public class Phone {
		    public String brand;
		    public double price;
		    public String color;
		    //成员方法
		    public void call(String who) {
		        System.out.println("给" + who + "打电话");
		    }
		    public void sendMessage(){
		        System.out.println("群发短信");
		    }
		}

		import demodemos.Phone;//导入包
        Phone iphone = new Phone();
        iphone.call("1234567890");
        iphone.sendMessage();

        System.out.println(iphone.price);
        System.out.println(iphone.color);

        iphone.brand="iphone";
        iphone.price=4222;
        iphone.color="green";
        System.out.println(iphone.brand);
        System.out.println(iphone.price);
        System.out.println(iphone.color);

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n723" mdtype="fences">    //对象作为形参
    public static void method(Phone iphone){
        System.out.println(iphone);// 传址 demodemos.Phone@5b480cf9
        System.out.println(iphone.brand);
        System.out.println(iphone.price);
        System.out.println(iphone.color);
    }

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n724" mdtype="fences" style="break-inside: unset;">    public static Phone getPhone(){
        Phone xiaomi = new Phone();
        xiaomi.brand="xiaomi";
        xiaomi.price=1999;
        xiaomi.color="Green";
        return xiaomi;
    }
    
	//使用对象类型作为方法返回值：
    Phone xiaomi = getPhone();
    System.out.println(xiaomi.brand);
    System.out.println(xiaomi.color);
    System.out.println(xiaomi.price);

</pre><hr /><h2><a name='header-n726' class='md-header-anchor '></a>30. 局部变量和成员变量</h2><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n727" mdtype="fences" style="break-inside: unset;"> 1.定义置不一样
 	局部变量：在方法的内部
 	成员变量：在方法的外部 直接写在类中
 2.作用范围不一样
 	局部变量：只有在方法当中才可以使用 除了方法就不能再用
 	成员变量:整个类全都可以通用
 3.默认值不一样：
 	局部变量：没有默认值 如果想要使用必须手动进行赋值
 	成变量：如果没有赋值 会有默认值
 4.内存位置不一样：
 	局部变量：位于栈内存
 	成员变量：位于堆内存
 5.生命周期不一样：
 	局部变量：随着方法进栈而诞生 随着方法出栈而消失
 	成员变量：随着对象的创建而诞生 随着对象被垃圾回收而消失

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n728" mdtype="fences" style="break-inside: unset;">public class Demo{
	String name;// 成员变量
	public void methodA(){
		int num=20;// 局部变量
		System.out.println(num);
		System.out.println(name);
	}
	public void methodB(int param){//方法的参数就是局部变量
		//参数在方法调用的时候 必然会被赋值
		System.out.println(param);
		int age;// 局部变量
		System.out.println(age);// 错误写法 没有赋值不能用
		System.out.println(num);// 错误写法 超出使用范围
		System.out.println(name);
	}	
}

</pre><hr /><h2><a name='header-n730' class='md-header-anchor '></a>31. 面向对象的三大特征</h2><ul><li>面向对象的三大特征： 封装 继承 多态</li><li>封装性在Java的体现：
方法就是一种封装 关键字private也是一种封装
封装就是将一些细节信息隐藏起来 对于外界不可见</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n736" mdtype="fences" style="break-inside: unset;">      public static  int getMax(int[] array){
          int max=array[0];
          for (int i = 0; i &lt; array.length; i++) {
              if(array[i]&gt;max){
                  max=array[i];
              }
          }
          return max;
      }
      
      int[] array={5,15,50,100};
      int max=getMax(array);
      System.out.println("最大值："+max);

</pre><ul><li><p>private的作用及使用：</p><ul><li>用private关键字来修饰需要保护的成员变量</li><li>一旦使用了private进行修饰 那么本类当中仍然可以随意访问；但是 超出了本类范围之外就不能直接访问了</li></ul></li><li><p>间接访问private成员变量 就是定义一对Getter/Setter方法</p></li><li><p>对于boolean值 Getter方法一定要写成isXxx形式 而setXxx规则不变</p></li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n749" mdtype="fences" style="break-inside: unset;">public class Person{
    String name;// 姓名
    private int age;// 年龄
    public void show(){
        System.out.println("My name is"+name+", I am "+age+" years old.");
    }

    //这个成员方法 专门用来向age设置数据 必须是setAge 必须有参数无返回值
    public void setAge(int num){
        if(num&gt;0){
            age=num;
        } else{
            System.out.println("数据不合理");
        }
    }
    //这个成员方法 专门用来获取age的数据 必须是getAge 必须无参数有返回值
    public int getAge(){
        return age;
    }
}

public class coding{
    public static void main(String[] args) {
        Person person = new Person();
        person.show();
        person.name="lix";
        //person.age=-20;
        //直接访问private的内容 错误写法
        person.setAge(20);//间接访问age赋值
        person.show();
        person.setAge(-20);//数据不合理
        person.show();
    }
}

</pre><p><strong>练习：使用private定义学生类</strong></p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n751" mdtype="fences" style="break-inside: unset;">public class Student{

    private String name;// 姓名
    private int age;// 年龄
    private  boolean male;// 性别

    public void setMale(boolean b){
        male=b;
    }
    public boolean isMale(){
        return male;
    }
    public void setName(String str){
        name=str;
    }
    public String getName(){
        return name;
    }
    public void setAge(int num){
        if(num&gt;0){
            age=num;
        } else{
            System.out.println("数据不合理");
        }
    }
    public int getAge(){
        return age;
    }
}

Student stu = new Student();
stu.setName("myname");
set.setAge(20);
set.setMale(true);
System.out.println("姓名"+stu.getName());
System.out.println("年龄"+stu.getAge());
System.out.println("性别"+stu.isMale());

</pre><hr /><h2><a name='header-n753' class='md-header-anchor '></a>32. this方法介绍</h2><ul><li>当方法的局部变量和类成员变量重名的时候 根据就近原则 优先使用局部变量</li><li>如果需要访问本类的成员变量 需要使用格式：this.成员变量名</li><li>通过谁调用的方法 谁就是this</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n761" mdtype="fences" style="break-inside: unset;">public class Person{
    String name;// 自己的名字
    //参数name是对方的名字 成员变量name是自己的名字
    public void sayHello(String name){
        System.out.println(name+",hello. I am "+this.name);
        System.out.println(this);//打印this地址
    }
}

public static void main(String[] args) {
    Person person = new Person();
    //设置自己的名字
    person.name="myname";
    person.sayHello("yourname");
    System.out.println(person);//地址值 这里和this的地址值相同
    //即 通过谁调用的方法 谁就是this
}

</pre><h2><a name='header-n762' class='md-header-anchor '></a>33. 构造方法</h2><ul><li>构造方法是专门用来创建对象的方法 当我们通过关键字new来创建对象时 其实就是在调用构造方法</li><li>格式 ：</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n768" mdtype="fences">public 类名称(参数类型 参数名称,...){
	方法体;
}

</pre><p><strong>注意事项：</strong></p><ul><li>1.构造方法的名称必须和所在的类名称完全一样</li><li>2.构造方法不要写返回值类型 void不要写</li><li>3.构造方法不能return一个具体的返回值</li><li>4.如果没有编写任何构造方法 那么编译器会默认赠送一个构造方法 没有参数 方法体 什么事情都不做-public Student(){}</li><li>5.一旦编写了至少一个构造方法 那么编译器将不再赠送</li><li>6.构造方法也可以进行重载 - 重载：方法名称相同 参数列表不同</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n783" mdtype="fences" style="break-inside: unset;">public class Student{
    //成员变量
    private String name;
    private  int age;

    //无参数的构造方法
    public Student(){
        System.out.println("无参数的构造方法执行");
    }
    //全参数的构造方法
    public Student(String name,int age){
        System.out.println("全参数的构造方法执行");
        this.name=name;
        this.age=age;
    }

    //Getter Setter
    public void setName(String name){
        this.name=name;
    }
    public String getName(){
        return name;
    }
    public void setAge(int age){
        this.age=age;
    }
    public int getAge(){
        return age;
    }
}

public static void main(String[] args) {
    Student stu1 = new Student();// 无参构造
    System.out.println();
    Student stu2 = new Student("myname",20);// 全参构造
    System.out.println("姓名："+stu2.getName()+",年龄："+stu2.getAge());
    //如果需要改变对象中的成员变量的数据 仍需要使用setXxx的方法
    stu2.setAge(21);// 改变年龄
    System.out.println("姓名："+stu2.getName()+",年龄："+stu2.getAge());
}

</pre><hr /><h2><a name='header-n785' class='md-header-anchor '></a>34. 定义一个标准类</h2><ul><li><p>一个标准的类通常要拥有下面四个组成部分： </p><ul><li>1.所有的成员变量都要使用private关键字修饰</li><li>2.为每一个成员变量编写一对儿Getter/Setter方法</li><li>3.编写一个无参数的构造方法</li><li>4.编写一个全参数的构造方法</li></ul></li><li><p>快捷键 Alt+Insert</p></li></ul><p><strong>代码示例</strong></p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n801" mdtype="fences" style="break-inside: unset;">public class Student{
    private String name;// 姓名
    private int age;// 年龄

    public Student(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public Student() {
    }

    public void setName(String name) {
        this.name = name;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public int getAge() {
        return age;
    }
}

public static void main(String[] args) {
    Student stu1 = new Student();
    stu1.setName("myname");
    stu1.setAge(21);
    System.out.println("姓名："+stu1.getName()+",年龄："+stu1.getAge());
    System.out.println();
    Student stu2 = new Student("myname",18);
    System.out.println("姓名："+stu1.getName()+",年龄："+stu1.getAge());
    stu2.setAge(19);
    System.out.println("姓名："+stu1.getName()+",年龄："+stu1.getAge());
}

</pre><hr /><h2><a name='header-n803' class='md-header-anchor '></a>35. Scanner简单使用</h2><ul><li>Scanner类的功能：可以实现键盘输入数据到程序中</li><li>引用类型的一般步骤：
1.导包
<strong>import 包路径.类名称;</strong>
如果需要使用的目标类和当前类位于同一个包下 则可以省略包语句不写
只有java.lang包下的内容不需要导包 其他的包都需要import语句</li><li>2.创建
类名称 对象名 = new 类名称();</li><li>3.使用
对象名.成员方法名()</li></ul><p><em>导包 import java.util.Scanner;</em>
<em>获取键盘输入的一个int数字: int num = sc.nextInt();
获取键盘输入的一个字符串：String str = sc.next();</em></p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n814" mdtype="fences">	//2.创建 System.in代表从键盘进行输入
    Scanner sc = new Scanner(System.in);
    //3.获取键盘输入的int数字
    int num = sc.nextInt();
    System.out.println("输入的int数字是："+num);
    //4.获取键盘输入的字符串
    String str = sc.next();
    System.out.println("输入的字符串是："+str);

</pre><p><strong>输入两个数并求和</strong></p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n816" mdtype="fences">        Scanner sc = new Scanner(System.in);
        System.out.print("请输入第一个int数字a：");
        int a = sc.nextInt();
        System.out.print("请输入第二个数字b：");
        int b = sc.nextInt();
        int result=a+b;
        System.out.println("a+b的结果是："+result);

</pre><p><strong>输入三个值求最大值</strong></p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n818" mdtype="fences">        Scanner sc = new Scanner(System.in);
        System.out.print("请输入第一个int数字a：");
        int a = sc.nextInt();
        System.out.print("请输入第二个int数字b：");
        int b = sc.nextInt();
        System.out.print("请输入第三个int数字c：");
        int c = sc.nextInt();
        int temp = a&gt;b?a:b;
        int max = temp&gt;c?temp:c;
        System.out.println("a b c 三者的最大值是："+max);

</pre><h2><a name='header-n819' class='md-header-anchor '></a>36. 匿名对象</h2><ul><li>创建对象的标准格式：
类名称 对象名 = new 类名称();</li><li>匿名对象就是只有右边的对象 没有左边的名字和赋值运算符 即 new 类名称();</li><li>注意事项：
匿名对象只能使用唯一的一次 下次再用不得不再创建一个新的对象</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n827" mdtype="fences" style="break-inside: unset;">        public class Person{
            String name;
            public void showName(){
                System.out.println("My name is :"+name);
            }
        }
        //左边person就是对象的名字
        Person person = new Person();
        person.name="myname";
        person.showName();//My name is :myname
        //匿名对象
        new Person().name="yourname";
        new Person().showName();// My name is :null.

</pre><p><strong>匿名对象作为参数和返回值</strong></p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n829" mdtype="fences" style="break-inside: unset;">        //普通使用方式
        //Scanner sc = new Scanner(System.in);
        //int num = sc.nextInt();

        //匿名对象方式
        //int num = new Scanner(System.in).nextInt();
        //System.out.println("输入的int数字是： "+num);

        //使用一般写法传入参数
        //Scanner sc = new Scanner(System.in);
        //mehtodParam(sc);

        //使用匿名对象进行传参
        //methodParam(new Scanner(System.in));

        //返回值的一般写法
        Scanner sc = methodReturn();
        int num = sc.nextInt();
        System.out.println("输入的int数字是： "+num);
		
	    public static void mehtodParam(Scanner sc){
			int num = sc.nextInt();
			System.out.println("输入的int数字是： "+num);
		}
	
	    public static Scanner methodReturn(){
			//Scanner sc = new Scanner(System.in);
			//return sc;
			return new Scanner(System.in);
		}

</pre><hr /><h2><a name='header-n831' class='md-header-anchor '></a>37. Random基本使用</h2><ul><li><p>Random类来生成随机数字 </p><ul><li>1.导包： import java.util.Random; </li><li>2.创建： Random r = new Random();</li><li>3.使用： 获取随机一个数字(范围是int类的所有范围 有正负两种)：int num = r.nextInt();</li></ul></li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n842" mdtype="fences" style="break-inside: unset;"> 	Random r = new Random();
    int num = r.nextInt();
    System.out.println("产生的随机数是： "+num);

	//获取一个随机int类数字 (参数代表了范围 左闭右开区间)：int num = r.nextInt();
	//实际代表的是 [0,3) 也就是0~2
    Random r = new Random();
    for (int i = 0; i &lt; 100; i++) {
        int num = r.nextInt(10);// 范围实际上是0~9的int值
        System.out.print(" "+num);
    }
    System.out.println();


    //打印随机数字
    Scanner sc = new Scanner(System.in);
    int n = sc.nextInt();
    Random r = new Random();
    for (int i = 0; i &lt; 10; i++) {
        //本来范围是[0,n) 整体+1之后就变成了[1,n+1) 也就是[1,n];
        int num = r.nextInt(n)+1;
        System.out.print(" "+num);
    }

</pre><p><strong>猜数字</strong></p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n844" mdtype="fences" style="break-inside: unset;">    //猜随机数字
    Random r = new Random();
    int randomNum = r.nextInt(100)+1;// [1,100]
    Scanner sc = new Scanner(System.in);
    System.out.print("请输入猜测的数字：");
    while (true){
        int guessNum = sc.nextInt();// 键盘输入猜测的数字
        if(guessNum &gt; randomNum){
            System.out.print("数字太大 请重新输入：");
        } else if(guessNum &lt; randomNum){
            System.out.print("数字太小 请重新输入：");
        } else{
            System.out.println("猜对了");
            break;
        }
    }

</pre><hr /><h2><a name='header-n846' class='md-header-anchor '></a>38. 对象数组</h2><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n847" mdtype="fences" style="break-inside: unset;">public class Person{
    private String name;
    private int age;

    public Person() {
    }
    
    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }
    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }



    public void setAge(int age) {
        this.age = age;
    }
}

		//定义一个数组 来存储3个Person对象 一旦创建 程序运行期间数组长度不可改变
        //首先创建一个长度为3的数组 里面用来存放Person类型的对象
        Person[] array = new Person[3];
        Person one = new Person("onename",18);
        Person two = new Person("twoname",19);
        Person three = new Person("threename",17);
        //将地址值赋值到数组元素的位置
        array[0]=one;
        array[1]=two;
        array[2]=three;
        System.out.println(array[0]);// 地址值
        System.out.println(array[1]);// 地址值
        System.out.println(array[2]);// 地址值

        System.out.println(array[0].getName());// onename
        System.out.println(array[2].getAge());// 17

</pre><hr /><h2><a name='header-n849' class='md-header-anchor '></a>39. ArrayList</h2><p>ArrayList集合概述和基本使用：</p><ul><li><p>数组的长度不可以发生改变 但是ArrayList集合的长度可以随意变化</p></li><li><p>对于 ArrayList 有一个<E> 代表泛类型 也就是装在集合当中的元素的类型 只能是引用类型 不能是基本类型</p><ul><li>注意事项：对于 ArrayList来说 直接打印得到的不是地址值 而是内容 如果 内容为空 则得到 []</li></ul></li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n859" mdtype="fences">     //创建一个ArrayList集合 集合名称为list 里面全部都是String字符串类型的数据
       //从JDK1.7+开始 右侧的尖括号内可以不写内容
       ArrayList&lt;String&gt; list =new ArrayList&lt;&gt;();
       System.out.println(list);// []
       //向集合中增加数据 用到add方法
       list.add("java");
       System.out.println(list);// java
       list.add("demo");
       list.add("code");
       list.add("javademo");
       System.out.println(list);// [java, demo, code, javademo]

</pre><p>ArrayList常用方法：</p><ul><li>public boolean add(E e)：向集合中添加元素 参数的类型和泛型一致 返回值代表是否添加成功- </li><li>对于ArrayList集合来说 add添加动作一定是成功的 所以返回值可用可不用 而对于其他集合来说add添加动作不一定成功</li><li>public E get(int index)：从集合中获取元素 参数是索引编号 返回值就是对应位置的元素</li><li>public E remove(int index)：从集合中删除元素 参数是索引编号 返回值就是被删除的元素</li><li>public int size()：获取集合的尺寸长度 返回值是集合中包含的元素个数</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n872" mdtype="fences" style="break-inside: unset;">       ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();
       System.out.println(list);// []
       //向集合中添加元素：add
       boolean isSuccess = list.add("myfirstname");
       System.out.println(list);// myfirstname
       System.out.println("添加动作是否成功："+isSuccess);// true
       list.add("mysecondname");
       list.add("mythirdname");
       list.add("myfourthname");
       list.add("myfifthname");
       System.out.println(list);//
       //从集合中获取元素：get 索引值从0开始
       String name = list.get(2);
       System.out.println("第二索引位置name为："+name);// mtyhirdname
       //从集合中删除元素：remove 索引值从0开始
       String whichnameisRemoved = list.remove(3);
       System.out.println("被删除的name为："+whichnameisRemoved);// myfourthname
       System.out.println(list);// [myfirstname, mysecondname, mythirdname, myfifthname]
       //获取集合的尺寸长度 也就是其中元素的个数
       int size = list.size();
       System.out.println("list集合的长度为："+size);// 4

</pre><p>ArrayList集合遍历：</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n874" mdtype="fences">	ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();
	list.add("onename");
	list.add("twoname");
	list.add("threename");
	//遍历集合
	for(int i = 0 ;i&lt;list.size();i++){
		System.out.println(list.get(i));
	}

</pre><p>ArrayList存储基本类型数据：</p><ul><li><p>import java.util.ArrayList;</p></li><li><p>如果希望向集合ArrayList中存储基本类型数据 必须使用基本类型对应的包装类</p></li><li><p>基本类型 包装类(引用类型 包装类都位于java.lang包下)</p><ul><li>byte--&gt;Byte</li><li>short--&gt;Short</li><li>int--&gt;Integer</li><li>long--&gt;Long</li><li>float--&gt;Float</li><li>double--&gt;Double</li><li>char--&gt;Character</li><li>boolean--&gt;Boolean</li></ul></li><li><p>从JDK1.5+开始 支持自动装箱 自动拆箱
自动装箱：基本类型--&gt;包装类型 自动拆箱：包装类型--&gt;基本类型</p></li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n902" mdtype="fences">       ArrayList&lt;String&gt; listA = new ArrayList&lt;&gt;();
       //错误写法 泛型只能是引用类型 不能是基本类型
       //ArrayList&lt;int&gt; listB = new ArrayList&lt;int&gt;();
       ArrayList&lt;Integer&gt; listC = new ArrayList&lt;&gt;();
       listC.add(100);
       listC.add(200);
       System.out.println(listC);// [100, 200]

       int num = listC.get(1);
       System.out.println("第1号元素是： "+num);// 200

</pre><p><strong>存储随机数字 生成6个1~33的随机整数 添加到集合 并遍历集合</strong></p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n904" mdtype="fences">       ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();
       Random r = new Random();
       for (int i = 0; i &lt; 6; i++) {
           int num = r.nextInt(33)+1;
           list.add(num);
       }
       //遍历集合并打印
       for (int i = 0; i &lt; list.size(); i++) {
           System.out.print(" "+list.get(i));
       }

</pre><p>自定义4个学生对象 添加到集合 并遍历集合：</p><ul><li>1.自定义学生类 四个部分</li><li>2.创建一个ArrayList集合 用来存储学生对象 <Student></li><li>3.根据类 创建4个学生对象</li><li>4.将4个学生对象添加到集合中 add</li><li>5.遍历集合 for size get..</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n917" mdtype="fences" style="break-inside: unset;">public class Student{
    private String name;// 姓名
    private int age;// 年龄

    public Student(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public Student() {
    }

    public void setName(String name) {
        this.name = name;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public int getAge() {
        return age;
    }
}

    ArrayList&lt;Student&gt; list = new ArrayList&lt;&gt;();
    Student one = new Student("myfirstname",17);
    Student two = new Student("mysecondname",18);
    Student three = new Student("mythirdname",19);
    Student four = new Student("myfourthname",20);
    list.add(one);
    list.add(two);
    list.add(three);
    list.add(four);
    //遍历集合
    for (int i = 0; i &lt; list.size(); i++) {
        Student stu = new list.get(i);
        System.out.println("姓名："+stu.getName()+" 年龄："+stu.getAge());
    }

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n918" mdtype="fences" style="break-inside: unset;">public static void printArrayList(ArrayList&lt;String&gt; list) {
        //{元素@元素@元素}
        System.out.print("{");
        for (int i = 0; i &lt; list.size(); i++) {
            String element =list.get(i);
            if (i== list.size()-1){
                System.out.println(element+"}");
            } else {
                System.out.print(element+" @ ");
            }
        }
}
    //以指定格式打印集合{元素 @ 元素 @ 元素}
    ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();
    list.add("first");
    list.add("second");
    list.add("third");
    list.add("fourth");
    list.add("fifth");
    System.out.println(list);// [first, second, third, fourth, fifth]
    
    //定义方法三要素 返回值类型 void 方法名称 printArrayList 参数列表 ArrayList&lt;String&gt; list 
    printArrayList(list);

</pre><p>练习：用一个大集合存入20个随机数字 筛选其中的偶数元素放入小集合</p><ul><li><p>1.需要创建一个大集合 存储int型数字 <Integer></p></li><li><p>2.随机int型数字 Random nextInt</p></li><li><p>3.循环20次 把随机数字放入大集合 for add</p></li><li><p>4.定义筛选方法：</p><ul><li>4.1筛选：根据大集合 筛选符合要求的元素 放入小集合</li><li>4.2返回值类型：ArrayList小集合(元素个数不确定)</li><li>4.3方法名称：getSmallList</li><li>4.4参数列表：ArrayList大集合(元素20个数字)</li></ul></li><li><p>5.if判断偶数 num%2==0</p></li><li><p>6.如果为偶数 则放入小集合</p></li><li><p>7.遍历小集合</p></li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n944" mdtype="fences" style="break-inside: unset;">	public static ArrayList&lt;Integer&gt; getSmallList(ArrayList&lt;Integer&gt; bigList){
        //创建一个小集合 用来装偶数结果
        ArrayList&lt;Integer&gt; smallList = new ArrayList&lt;&gt;();
        for (int i = 0; i &lt; bigList.size(); i++) {
            int num = bigList.get(i);
            if(num % 2 == 0){
                smallList.add(num);
            }
        }
        return smallList;
    }
	
	public static void main(String[] args) {
        ArrayList&lt;Integer&gt; bigList = new ArrayList&lt;&gt;();
        Random r = new Random();
        for (int i = 0; i &lt; 20; i++) {
            int num = r.nextInt(100)+1;// 1~100
            bigList.add(num);
        }
        System.out.print("产生的20个随机数是： ");
        for (int i = 0; i &lt; bigList.size(); i++) {
            System.out.print(bigList.get(i)+" ");
        }
        ArrayList&lt;Integer&gt; smallList = new ArrayList&lt;&gt;();
        smallList = getSmallList(bigList);
        System.out.println();
        System.out.println("产生的随机偶数总共有："+smallList.size()+"个");
        System.out.print("产生的"+smallList.size()+"个随机偶数是： ");
        for (int i = 0; i &lt; smallList.size(); i++) {
            System.out.print(smallList.get(i)+" ");
        }
    }

</pre><hr /><h2><a name='header-n946' class='md-header-anchor '></a>40. 字符串概述</h2><p><strong>字符串概述</strong></p><p><strong>java.lang.String类代表字符串</strong></p><ul><li><p>特点：</p><ul><li>1.字符串的内容永不可变</li><li>2.正是因为字符串不可改变 所以字符串是可以共享使用的</li><li>3.字符串效果上相当于是char[]字符数组 但是底层原理是byte[]字节数组</li></ul></li></ul><p><strong>创建字符串的3+1种方式</strong></p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n960" mdtype="fences">//三种构造方法：
- 1.public String();// 创建一个空白字符串 不含有任何内容
- 2.public String(char[] array);// 根据字符数组的内容创建对应的字符串
- 3.public String(byte[] array);// 根据字节数组的内容来创建对应的字符串
//一种直接创建：
- String str = "hellojava";// 右边直接引用双引号
- 直接写上双引号 就是字符串对象

</pre><p>举例：</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n962" mdtype="fences" style="break-inside: unset;">    //使用空参构造
    String str1 = new String();// 小括号留空 说明字符串什么都没有
    System.out.println("第一个字符串："+str1);
    System.out.println();
    //根据字符数组创建字符串
    char[] charArray = {'A','B','C'};
    String str2 = new String(charArray);
    System.out.println("第二个字符串："+str2);
    System.out.println();
    //根据字节数组创建字符串
    byte[] byteArray = {97,98,99};
    String str3 = new String(byteArray);
    System.out.println("第三个字符串："+str3);
    System.out.println();
    String str4 = "hello";
    System.out.println("第四个字符串："+str4);

</pre><p><strong>字符串比较</strong></p><blockquote><p>对于基本类型来说 ==进行的是数值的比较
对于引用类型来说 ==进行的是地址值的比较
双引号直接写的字符串在常量池中 而new的不在常量池中</p></blockquote><p>参考代码：</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n967" mdtype="fences" style="break-inside: unset;">    String str1 = "abc";
    String str2 = "abc";
    char[] charArray1 = {'a','b','c'};
    String str3 = new String(charArray1);

    char[] charArray2 = {'a','b','c'};
    String str4 = new String(charArray1);
    String str5 = new String(charArray2);
    System.out.println(str1==str2);// true
    System.out.println(str1==str3);// false
    System.out.println(str2==str3);// false
    System.out.println(str3==str4);// false
    System.out.println(str3==str5);// false

</pre><p>&quot;==&quot;是进行对象的地址值比较 如果确实需要比较字符串的内容 有两个方法:</p><ol start='' ><li><p>public boolean equals(Object obj):参数可以是任何对象 只有参数是一个字符串并且内容相同才会给出true值 否则为false
注意事项：</p><ul><li>任何对象都能用Object进行接收</li><li>equals方法具有对称性 也就是a.equals(b) 和 b.equals(a) 效果一样</li><li>如果比较对方是一个常量和一个变量 推荐把常量字符串写在前面：推荐：&quot;abc&quot;.equals(str)  不推荐：str.equals(&quot;abc&quot;)</li></ul></li><li><p>public boolean equalsIgnoreCase(String str)：忽略大小写 进行内容比较</p></li></ol><p>示例代码</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n982" mdtype="fences" style="break-inside: unset;">    String str1 = "Hello";
    String str2 = "Hello";
    char[] charArray = {'H','e','l','l','o'};
    String str3 = new String(charArray);
    System.out.println(str1.equals(str2));// true
    System.out.println(str2.equals(str3));// true
    System.out.println(str3.equals("Hello"));// true
    System.out.println("Hello".equals(str1));// true
    String str4 = "hello";
    System.out.println(str1.equals(str4));// false
    String str5 = null;
    System.out.println("abc".equals(str5));// false 推荐
    System.out.println(str5.equals("abc"));// 不推荐 报错 空指针异常 NullPointerException
    String strA = "JAVA";
    String strB = "java";
    System.out.println(strA.equals(strB));// false 严格区分大小写
    System.out.println(strA.equalsIgnoreCase(strB));// true 忽略大小写
    //注意：只有英文字母区分大小写 其他都不区分大小写
    System.out.println("abc二123".equalsIgnoreCase("abc贰123"));// false

</pre><p><strong>String中与获取相关的常用方法</strong></p><ul><li>public int length() 获取字符串中含有的字符个数 拿到字符串长度</li><li>public String concat(String str) 将当前字符串和参数字符串拼接 为返回新的字符串</li><li>public char charAt(int index) 获取指定索引位置的单个字符 (索引从0开始)</li><li>public int indexOf(String str) 查找参数字符串在本字符串当中首次出现的索引位置 如果没有则返回-1值</li></ul><p>示例代码：</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n994" mdtype="fences" style="break-inside: unset;">    //获取字符串的长度
    int length = "awgjaojohzbamayeopeokzdgaaeg".length();//1个汉字算一个长度
    System.out.println("字符串的长度是："+length);

    //拼接字符串
    String str1 = "Hello";
    String str2 = "World";
    String str3 = str1.concat(str2);
    System.out.println(str1);// Hello 原封不动
    System.out.println(str2);// World 原封不动
    System.out.println(str3);// HelloWorld 新的字符串
    System.out.println();
    //获取指定索引位置的单个字符
    char ch = "Hello".charAt(1);
    System.out.println("在1号索引位置的字符是："+ch);
    System.out.println();
    //查找参数字符串在本来字符串当中出现的第一次索引位置
    //如果根本么有 返回-1值
    String original = "HelloWorldHelloWorld";
    int index = original.indexOf("llo");
    System.out.println("第一次索引值是："+index);// 2
    System.out.println("HelloJava".indexOf("abxc"));// -1

</pre><p><strong>字符串的截取方法</strong></p><ul><li>public String substring(int index) 截取从参数位置一直到字符串结尾 返回新字符串</li><li>public String substring(int begin,int end) 截取从begin开始 一直到end结束 中间的字符串</li><li>备注：[begin,end)左闭右开区间</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n1003" mdtype="fences" style="break-inside: unset;">    String str1 = "HELLOWORLD";
    String str2 = str1.substring(5);
    System.out.println(str1);// HELLOWORLD 原封不动
    System.out.println(str2);// WORLD 新字符串
    System.out.println();
    String str3 = str1.substring(4,7);
    System.out.println(str3);// oWo
    System.out.println();
    //下面这种写法 字符串的内容任然是没有改变的
    //下面有两个字符串 "HELLO" "JAVA"
    //strA当中保存的是地址值
    //本来地址值是HELLO的0x666
    //后来地址值变成了JAVA的0x999
    String strA = "HELLO";
    System.out.println(strA);// HELLO
    strA = "JAVA";
    System.out.println(strA);// JAVA

</pre><p><strong>String转换相关常用方法</strong></p><ul><li>public char[] toCharArray() 将当前字符串拆分成字符数组作为返回值</li><li>public byte[] getBytes() 获得当前字符串底层的字节数组</li><li>public String replace(CharSequence oldString,CharSequence newString)
将所有老的字符串替换成新的字符串 返回替换后结果的新字符串
备注：CharSequence意思就是可以接受字符串类型</li></ul><p>示例代码：</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n1013" mdtype="fences" style="break-inside: unset;">    //转换为字符数组
    char[] chars = "Hello".toCharArray();
    System.out.println(chars[0]);// H
    System.out.println(chars.length);// 5
    //转化为字节数组
    byte[] bytes = "Hello".getBytes();
    for (int i = 0; i &lt; bytes.length; i++) {
        System.out.print(bytes[i]+" ");
    }
    System.out.println();
    //新老字符串替换
    String str1 = "fuck your mother";
    String str2 = str1.replace("fuck","****");
    System.out.println(str1);// fuck your mother
    System.out.println(str2);// **** your mother

</pre><p><strong>分割字符串的方法</strong></p><ul><li><p>public String[] split(String regex) 按照参数的规则 将字符串切分成若干部分</p><ul><li><p>注意事项：</p><ul><li>split方法的参数其实是一个正则表达式 如果按照英文句点&#39;.&#39;切分 必须要写成&quot;\.&quot;</li></ul></li></ul></li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n1024" mdtype="fences">    String str1 = "ABC.XYE.ZLX";
    String[] strArray = str1.split("\\.");
    System.out.println(strArray.length);// 3
    for (int i = 0; i &lt; strArray.length; i++) {
    System.out.println(strArray[i]);

</pre><p><strong>练习：</strong> 定义一个方法将数组{1,2,3,4}按照指定格式拼接成一个字符串[word1#word2#word3]</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n1026" mdtype="fences" style="break-inside: unset;">public static String fromArraytoString(int[] array){
    String str = "[";
    for (int i = 0; i &lt; array.length; i++) {
        if(i== array.length-1){
            str += "word"+array[i]+"]";
        } else {
            str += "word"+array[i]+"#";
        }
    }
    return str;
}

int[] intArray = {1,2,3,4};
String resultArray = fromArraytoString(intArray);
System.out.println(resultArray);

</pre><p><strong>练习：</strong> 统计字符串的字符类型个数</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n1028" mdtype="fences" style="break-inside: unset;">    Scanner sc = new Scanner(System.in);
    System.out.print("请输入一个字符串：");
    String inputString = sc.next();// 键盘输入一个字符串
    int couutUpper = 0;
    int countLower = 0;
    int countNumber = 0;
    int countOther = 0;
    char[] charArray = inputString.toCharArray();
    for (int i = 0; i &lt; charArray.length; i++) {
        char ch = charArray[i];// 当前单个字符
        if('A'&lt;=ch&amp;&amp;ch&lt;='Z'){
            couutUpper++;
        } else if ('a'&lt;=ch&amp;&amp;ch&lt;='z'){
            countLower++;
        } else if ('0'&lt;=ch&amp;&amp;ch&lt;='9'){
            countNumber++;
        } else {
            countOther++;
        }
    }
    System.out.println("大写字母有："+couutUpper+"个");
    System.out.println("小写字母有："+countLower+"个");
    System.out.println("数字字符有："+countNumber+"个");
    System.out.println("其他字符有："+countOther+"个");

</pre><hr /><h2><a name='header-n1030' class='md-header-anchor '></a>41. static关键字</h2><ul><li>如果一个成员变量使用了static关键字 那么这个变量不在属于自己 而是属于所在的类 多个对象共用一份数据。</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n1034" mdtype="fences" style="break-inside: unset;">public class democlassStudents {

    private int id;// 学号
    private String name;// 姓名
    private int age;// 年龄
    static String room;// 教室
    private static int idCounter = 0;//学号计数器 new一个新对象 计数器加1

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public static String getRoom() {
        return room;
    }

    public static void setRoom(String room) {
        democlassStudents.room = room;
    }

    public static int getIdCounter() {
        return idCounter;
    }

    public democlassStudents() {
        this.id = ++idCounter;
    }

    public democlassStudents(String name, int age) {
        this.id = ++idCounter;
        this.name = name;
        this.age = age;
    }
    public static void setIdCounter(int idCounter) {
        democlassStudents.idCounter = idCounter;
    }
}


    System.out.println();
    democlassStudents one = new democlassStudents("name1",19);
    one.room = "101house";
    System.out.println("学号："+one.getId()+" 姓名："+one.getName()+" 年龄："+one.getAge()+" 教室："+one.room);
    democlassStudents two = new democlassStudents("name2",16);
    System.out.println("学号："+two.getId()+" 姓名："+two.getName()+" 年龄："+two.getAge()+" 教室："+two.room);

</pre><ul><li>一旦使用static修饰成员方法 那么这就成为了静态方法 静态方法不属于对象 而是属于类的</li><li>如果没有static关键字 那么必须首先创建对象 然后通过对象才能使用它</li><li>如果有了static关键字 则不需要创建对象 直接就能通过类名称来使用它</li><li>无论是成员变量还是成员方法 如果有了static关键字 都推荐使用类名称进行调用</li><li>静态变量：类名称.静态变量</li><li>静态方法：类名称.静态方法();</li><li>注意：</li><li>静态不能直接访问非静态</li><li>静态方法当中不能使用this</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n1054" mdtype="fences" style="break-inside: unset;">public class democlassStatic {
    private int num;// 成员变量
    static int numStatic;// 静态变量

    public int getNum() {
        return num;
    }

    public void setNum(int num) {
        this.num = num;
    }

    public democlassStatic(int num) {
        this.num = num;
    }

    public democlassStatic() {
    }

    //成员方法
    public void method(){
        System.out.println("这是一个成员方法");
        //成员方法可以访问成员变量
        System.out.println(num);
        //成员方法可以访问静态变量
        System.out.println(numStatic);
    }
    //静态方法
    public static void methodStatic(){
        System.out.println("这是一个静态方法");
        //静态方法可以访问静态变量
        System.out.println(numStatic);
        //静态方法不可以直接访问非静态
        //System.out.println(num);
        //System.out.println(this);// 错误写法
    }
}

	import demos.democlassStatic;
	public static void main(String[] args){
        democlassStatic obj = new democlassStatic();// 首先创建对象
        //然后才能使用没有static关键字的内容
        obj.method();
        //对于静态方法来说 可以通过对象名进行调用 也可以直接通过类名称来调用
        obj.methodStatic();// 正确 但不推荐
        democlassStatic.methodStatic();// 推荐
        //对于本类当中的静态方法 可以省略名称
        myMethod();
}
	public static void myMethod(){
		System.out.println("自己的方法");
	}

</pre><h2><a name='header-n1055' class='md-header-anchor '></a>42. 静态代码块和非静态代码块</h2><ul><li>静态代码块：随着类的加载而执行，且只执行一次</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n1059" mdtype="fences">public class 类名称 {
	static {
		//静态代码块内容
	}
}

</pre><ul><li>特点：第一次用到本类时 静态代码块执行唯一的一次</li><li>多个静态代码块则按照省的先后顺序执行</li><li>静态代码块只能调用静态属性、静态方法</li><li>静态代码块优先于非静态代码块执行</li><li>静态内容总是先于非静态内容 所以静态代码块比构造方法先执行</li><li>典型用途：用来一次性地对静态成员变量进行复制，初始化类的信息</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n1073" mdtype="fences" style="break-inside: unset;">public class Person {
    static {
        System.out.println("静态代码块执行");
    }
    public Person(){
        System.out.println("构造方法执行");
    }
}

    Person one = new Person();
    Person two = new Person();
/*	执行效果：
		静态代码块执行
		构造方法执行
		构造方法执行
*/

</pre><ul><li>非静态代码块：随着对象的创建而执行，每创建一个对象，就执行依次非静态代码块</li><li>多个非静态代码块则按照省的先后顺序执行</li><li>非静态代码块可以调用静态属性、静态方法、非静态属性、非静态方法</li><li>用途：可以在创建对象时，对对象的属性进行初始化。</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n1083" mdtype="fences">public class 类名称 {
 	{
		//非静态代码块内容
	}
}

</pre><p><strong>总结：对属性可以赋值的位置：</strong></p><ol start='' ><li>默认初始化</li><li>显式初始化</li><li>构造器初始化</li><li>对象.属性 或 对象.方法赋值</li><li>代码块中赋值</li></ol><p>赋值执行顺序：1 =&gt; 2 / 5 =&gt; 3 =&gt; 4</p><h2><a name='header-n1097' class='md-header-anchor '></a>43. 数组工具类</h2><ul><li>数组工具类：</li><li>java.util.Arrays;是一个与数组相关的工具类 提供大量的静态方法 来实现数组常见的操作</li><li>public static String toString(数组) 将参数数组变成字符串 (默认格式：[元素1， 元素2， 元素3])</li><li>public static void sort(数组) 按照默认升序对数组元素进行排序</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n1107" mdtype="fences">        int[] intArray = {10,20,30};
        //将int[]数组按照默认格式变成字符串
        String intStr = Arrays.toString(intArray);
        System.out.println(intStr);// [10, 20, 30]
        int[] array1 = {1,2,3,4,6,10,5,3,8,9,4,6,7};
        Arrays.sort(array1);
        System.out.println(Arrays.toString(array1));
        String[] array2 = {"awgaha","aivahe","ieitjn"};
        Arrays.sort(array2);
        System.out.println(Arrays.toString(array2));;

</pre><p><strong>使用：</strong></p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n1109" mdtype="fences" style="break-inside: unset;">//题目：
//使用Arrays 将随机字符串升序排列 倒序打印

        Scanner sc = new Scanner(System.in);
        System.out.print("请输入需要排序的字符串：");
        String str = sc.next();
        //如何进行升序排列 sort
        //必须是一个数组 String--&gt;数组 toCharArray
        char[] chars =str.toCharArray();
        Arrays.sort(chars);//对字符数组升序排列
        //倒序遍历输出
        for (int i = chars.length - 1; i &gt;= 0; i--) {
            System.out.print(chars[i]);
        }

</pre><h2><a name='header-n1110' class='md-header-anchor '></a>43. Math类</h2><ul><li>java.util.Math 类是数学相关的工具类 里面提供了大量的静态方法 完成与数学运算相关的操作</li><li>public static double abs(double num) 取绝对值 有多种重载</li><li>public static double ceil(double num) 向上取整</li><li>public static double floor(double num) 向下取整</li><li>public static long round(double num) 四舍五入</li><li>Math.PI代表近似的圆周率常量(double)</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n1124" mdtype="fences">        //获取绝对值
        System.out.println(Math.abs(-2.5));// 2.5
        //向上取整
        System.out.println(Math.ceil(3.9));// 4.0
        System.out.println(Math.ceil(3.1));// 4.0
        //向下取整 抹零
        System.out.println(Math.floor(3.1));// 3.0
        System.out.println(Math.floor(5.9));// 5.0
        //四舍五入
        System.out.println(Math.round(20.4));// 20
        System.out.println(Math.round(11.9));// 12

</pre><p>  <strong>练习：</strong></p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n1126" mdtype="fences" style="break-inside: unset;">/**
计算在-10.8到5.9之间的 绝对值大于6或小于2.1的整数 个数
分析：
1.确定了范围 使用for循环
2.起点位置-10.8应转换为-10 两种方法：
	2.1可以使用Math.ceil方法 向上取整
	2.2可以强制为int 自动舍弃所有小数位
3.每一个数字都是整数 步进表达式num++;
4.Math.ceil方法拿到绝对值
5.一旦发现一个数字 counter计数器++;
备注：如果使用Math.ceil方法 -10.8可以变成-10.0 注意double也是可以进行++的
*/

    int counter = 0;// 计数器
    double min = -10.8;
    double max = 5.9;
    //这样处理 变量i就是区间内的所有整数
    for(double i = Math.ceil(min);i&lt;max;i++){
        if(Math.abs(i)&gt;6||Math.abs(i)&lt;2.1){
            counter++;
        }
    }
    System.out.println("总共有："+counter+"个符合条件的数字");

</pre><h2><a name='header-n1127' class='md-header-anchor '></a>44. 继承</h2><ul><li>Java继承的三个特点：</li></ul><ol start='' ><li>Java语言是单继承的</li></ol><ul><li>一个类的直接父类只能有唯一一个</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n1137" mdtype="fences">- class A{}
- class B extends A{}// 正确写法
- class C{}
- class D extends A,C{}// 错误写法

</pre><ol start='2' ><li>Java语言可以多级继承</li></ol><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n1141" mdtype="fences">class A{}
class B extends A{}// 正确写法
class C extends B{}// 正确写法

</pre><ol start='3' ><li>一个子类的直接父类是唯一的 但是一个父类可以有多个子类</li></ol><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n1145" mdtype="fences">class A{}
class B extends A{}// 正确写法
class C extends A{}// 正确写法

</pre><ul><li>继承：</li><li>父子类定义：</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n1151" mdtype="fences">//定义一个父类的格式：(一个普通的类定义)
public class 父类名称{
	//....
}

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n1152" mdtype="fences">//定义子类的格式：
public class 子类名称 extends 父类名称{
	//....
}

</pre><p><strong>举例：</strong></p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n1154" mdtype="fences" style="break-inside: unset;">    //定义一个父类 员工
    public class Employee{
        public void method(){
            System.out.println("父类方法继承执行");
        }
    }
    
    //定义一个员工子类 讲师
    public class Teacher extends Employee{

    }
    
    //定义了一个员工子类 助教
    public class Assistant extends Employee{

    }

    public static void main(String[] args) {
        //创建一个子类对象
        Teacher teacher = new Teacher();
        //Teacher类当中虽然什么都没有写 但是会继承来自父类的method方法
        teacher.method();
        //创建另一个子类对象
        Assistant assistant = new Assistant();
        assistant.method();
    }

</pre><ul><li>在父子继承关系中 如果成员变量重名 则创建子类对象时 访问有两种方式</li><li>直接通过子类对象访问成员变量：等号左边是谁 就优先用谁 没有则向上找</li><li>间接通过成员方法访问成员变量：该方法属于谁 就优先用谁 没有则向上找</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n1162" mdtype="fences" style="break-inside: unset;">public class Fu{
        int numFu = 10;
        int num = 100;
        public void methodFu(){
            //使用的是本类当中的 不会向下找子类的
            System.out.println(num);
        }
    }

    public class Zi extends Fu{
        int numZi = 5;
        int num = 50;
        public void methodZi(){
            //因为本类中有num 所以这里用的是本类的num
            System.out.println(num);
        }
    }

    public static void main(String[] args) {
        Fu fu = new Fu();// 创建父类对象
        System.out.println(fu.numFu);// 只能使用父类的东西 没有任何子类内容
        Zi zi = new Zi();
        System.out.println(zi.numZi);// 20
        System.out.println(zi.numFu);//10
        //等号左边是谁就优先用谁
        System.out.println(zi.num);// 优先子类
        //System.out.println(zi.abc);// 都没有 编译报错
        //这个方法是子类的 优先用子类 没有再向上找
        zi.methodZi();
        //这个方法是在父类中定义的
        zi.methodFu();
    }

</pre><ul><li>局部变量：  直接写成员变量名</li><li>本类的成员变量：  this.成员变量名</li><li>父类的成员变量：  super.成员变量名</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n1170" mdtype="fences" style="break-inside: unset;">	public class Fu{
        int num = 10;
    }
    public class Zi extends Fu{
        int num = 20;
        public void method(){
            int num = 30;
            System.out.println(num);// 30局部变量
            System.out.println(this.num);// 20 本类的成员变量
            System.out.println(super.num);// 10 父类的成员变量
        }
    }

    public static void main(String[] args) {
        Zi zi = new Zi();
        zi.method();
    }

</pre><ul><li><p>在父子类的继承关系中 创建子类对象 访问成员方法的规则：</p><ul><li>创建的对象是谁 就优先用谁 如果没有则向上找</li></ul></li><li><p>注意事项：无论是成员变量还是成员方法 如果没有都是向上找父类 绝不会向下找子类</p></li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n1179" mdtype="fences" style="break-inside: unset;">	public class Fu{
        public void methodFu(){
            System.out.println("父类方法执行");
        }
        public void method(){
            System.out.println("父类重名方法执行");
        }
    }
    public class Zi extends Fu{
        public void methodZi(){
            System.out.println("子类方法执行");
        }
        public void method(){
            System.out.println("子类重名方法执行");
        }
    }

    public static void main(String[] args) {
        Zi zi = new Zi();
        zi.methodFu();// 父类方法执行
        zi.methodZi();// 子类方法执行
        zi.method();// 子类重名方法执行
    }

</pre><h2><a name='header-n1180' class='md-header-anchor '></a>45. Override重写</h2><ul><li>重写Override 又叫覆盖 覆写 在继承关系中 方法的名称一样 参数列表也一样</li><li>重载Overload 方法名称一样 参数列表不一样</li><li>方法重写的特点：创建的是子类对象 则优先使用子类方法</li><li>方法覆盖重写的注意事项：</li></ul><ol start='' ><li>必须保证父子类之间的方法名称相同 参数列表也相同</li></ol><ul><li>@Override 写在方法前面 用来检测是不是有效的正确覆盖重写</li><li>这个注释就算不写 只要满足要求 也是正确的方法覆盖重写</li></ul><ol start='2' ><li>子类方法的返回值必须小于等于父类方法的返回值范围</li></ol><ul><li>java.lang.Object类是所有类的公共最高父类（祖宗类）</li><li>java.lang.String就算Object的子类</li></ul><ol start='3' ><li>子类方法的权限必须大于等于父类方法的权限修饰符</li></ol><ul><li>public&gt;protected&gt;(default)&gt;private</li><li>(default)不是关键字default 而是什么都不写 留空</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n1214" mdtype="fences">	public class Fu{
        public Object method(){
            return null;
        }
    }
    public class Zi extends Fu{
        @Override
        public String method(){
            return null;
        }
    }

</pre><p><strong>覆盖重写的应用场景：</strong></p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n1216" mdtype="fences" style="break-inside: unset;">    //老款
    public class Phone{
        public void call(){
            System.out.println("打电话");
        }
        public void send(){
            System.out.println("发短信");
        }
        public void show(){
            System.out.println("显示号码");
        }
    }
    
    //新款
    public class NewPhone extends Phone{
        @Override
        public void show(){
            super.show();// 把父类的show方法拿过来重复利用
            //自己子类再来添加更多内容
            System.out.println("显示姓名");
            System.out.println("显示头像");
        }
    }
    
    //main
    public static void main(String[] args) {
        Phone phone = new Phone();
        phone.call();
        phone.send();
        phone.show();
        NewPhone newPhone = new NewPhone();
        newPhone.call();
        newPhone.send();
        newPhone.show();
    }

</pre><h2><a name='header-n1217' class='md-header-anchor '></a>46. 子父类构造方法的特点</h2><ul><li>继承关系中 父子类构造方法的访问特点：</li></ul><ol start='' ><li>子类构造方法当中有一个隐含的super();调用所以一定是先调用父类构造 后执行子类构造</li><li>子类构造可以通过super关键字来调用父类重载构造</li><li>super的父类构造调用 必须是子类构造方法的第一个语句，不能一个子类构造调用多次super构造子类必须调用父类构造方法，不写则默认赠送super(); 写了则用写的指定的super调用，super只能有一个 ，还必须是第一个。</li></ol><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n1228" mdtype="fences" style="break-inside: unset;">	public class Fu{
        public Fu(){
            System.out.println("父类无参构造");
        }
        public Fu(int num2,int num1){
            System.out.println("父类有参构造");
        }
    }
    
    public class Zi extends Fu{
        public Zi(){
            //super();// 在调用父类无参构造方法
            super(10,20);//在调用父类重载的构造方法
            System.out.println("子类构造方法");
        }
        public void method(){
            //super();//错误写法只有子类构造方法才能调用父类构造方法
        }
    }

    public static void main(String[] args) {
        Zi zi = new Zi();
    }

</pre><h2><a name='header-n1229' class='md-header-anchor '></a>47. super关键字</h2><ul><li>super关键字的三种用法：</li></ul><ol start='' ><li>在子类的成员方法中 访问父类的成员变量</li><li>在子类的成员方法中 访问父类的成员方法</li><li>在子类的构造方法中 访问父类的构造方法</li></ol><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n1240" mdtype="fences" style="break-inside: unset;"> 	public class Fu{
        int num = 10;
        public void method(){
            System.out.println("父类方法");
        }
    }
    public class Zi extends Fu{
        int num = 20;
        public Zi(){
            super();
        }
        public void methodZi(){
            System.out.println(num);
            System.out.println(super.num);// 父类中的num
        }
        public void method(){
            super.method();// 访问父类中的method
            System.out.println("子类方法");
        }
    }

</pre><ul><li>super关键字用来访问父类内容 而this关键字用来访问本类内容 用法也有三种</li></ul><ol start='4' ><li>在本类的成员方法中 访问本类的成员变量</li><li>在本类的成员方法中 访问本类的另一个成员方法</li><li>在本类的构造方法中 访问本类的另一个构造方法</li></ol><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n1251" mdtype="fences" style="break-inside: unset;">	public class Fu{
        int num = 30;
        public void method(){
            System.out.println("父类方法执行");
        }
    }
    
    public class Zi extends Fu{
        int num = 20;
        public void showNum(){
            int num = 10;
            System.out.println(num);// 局部变量
            System.out.println(this.num);// 本类中的成员变量
            System.out.println(super.num);// 父类中的成员变量
        }
        @Override
        public void method(){
            System.out.println("子类重写方法执行");
        }
        public void methodZi(){
            this.method();
            System.out.println("子类方法执行");
        }
        public Zi(){
            //super();// 这一行不再赠送
            this(123);// 本类的无参构造 调用本类的有参构造
            //this(1,2);// 错误写法
        }
        public Zi(int n)(){
            this(12,2);
        }
        public Zi(int a,int b)(){
            
        }
    }

</pre><h2><a name='header-n1252' class='md-header-anchor '></a>48. 抽象类和抽象方法</h2><ul><li>抽象方法：就是加上abstract关键字 直接分号结束</li><li>抽象类：抽象方法所在的类必须是抽象类才行 在class前加上abstract即可</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n1258" mdtype="fences">public abstract class Animal{
	//这是一个抽象方法 代表吃东西 但具体吃什么不确定
	public abstract void eat();
	//这是普通的成员方法
	public void normalMethod(){
		System.out.println("一个普通的成员方法");
	}
}

</pre><ul><li>抽象类和抽象方法的使用：</li></ul><ol start='' ><li>不能直接创建 new 抽象类对象</li><li>必须使用一个子类来继承抽象父类</li><li>子类必须覆盖重写抽象父类当中所有的抽象方法：覆盖重写(实现)：子类去掉抽象方法的abstract关键字 补上方法体大括号</li><li>创建子类对象进行使用</li></ol><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n1271" mdtype="fences" style="break-inside: unset;">	public abstract class Animal{
        //这是一个抽象方法 代表吃东西 具体吃什么不知道
        public abstract void eat();
    }
    public class Cat extends Animal{
        @Override
        public void eat(){
            System.out.println("猫吃鱼");
        }
    }

    public static void main(String[] args) {
        //Animal animal = new Animal();// 错误写法 不能直接创建抽象类对象
        Cat cat = new Cat();
        cat.eat();
    }

</pre><ul><li>注意事项：</li></ul><ol start='' ><li>抽象类不能创建对象 如果创建 编译器报错 只能创建其非抽象子类的对象</li><li>抽象类中 可以有构造方法 是提供子类创建对象时 初始化父类成员使用的</li><li>抽象类中 不一定包含抽象方法 但是有抽象方法的类必定是抽象类</li><li>抽象类的子类 必须重写抽象父类的所有抽象方法 除非该子类也是抽象类</li><li>abstract不能用来修饰属性、构造器等结构</li><li>abstract不能用来修饰私有方法、静态方法、final的方法、final的类</li></ol><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n1288" mdtype="fences" style="break-inside: unset;">	public abstract class Fu{
        public Fu(){
            System.out.println("抽象父类构造方法执行");
        }
        public abstract void eat();
    }
    
    public class Zi extends Fu{
        public Zi(){
            //super();
            System.out.println("子类构造方法执行");
        }
        @Override
        public void eat(){
            System.out.println("吃饭饭");
        }
    }

    public static void main(String[] args) {
        Zi zi = new Zi();
        zi.eat();
    }

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n1289" mdtype="fences" style="break-inside: unset;">    public abstract class MyAbstract{
    
    }
    //最高的抽象父类
    public abstract class Animal{
        public abstract void eat();
        public abstract void sleep();
    }
    //子类也是一个抽象类
    public abstract class Dog extends Animal{
        @Override
        public void eat(){
            System.out.println("狗吃骨头");
        }
        //public abstract void sleep();
    }
    
    public class DogGolden extends Dog{
        @Override
        public void sleep(){
            System.out.println("呼呼呼...");
        }
    }
    
    public class Dog2Ha extends Dog{
        @Override
        public void sleep(){
            System.out.println("嘿嘿嘿...");
        }
    }

    public static void main(String[] args) {
        //Animal animal = new Animal();//错误写法
        //Dog dog = new Dog();//错误写法
        Dog2Ha ha = new Dog2Ha();//这是普通类可以直接使用
        ha.eat();
        ha.sleep();
        System.out.println("==========");
        DogGolden golden = new DogGolden();
        golden.eat();
        golden.sleep();
    }
	

</pre><h2><a name='header-n1290' class='md-header-anchor '></a>48. ==运算符、equals、toString()使用</h2><ul><li>== 运算符：</li></ul><ol start='' ><li>可以使用在基本数据类型和引用数据类型变量中 </li></ol><ul><li><p>比较基本数据类型变量，比较保存的实际是否相等 (类型不一定要相同)</p></li><li><p>比较引用数据类型变量，比较两个对象的地址值是否相同，即两个引用是否指向同一个地址
           </p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n1302" mdtype="fences">* equals()方法的使用：
* 1. 是一个方法，而非运算符
* 2. 适用于引用数据类型
* object中定义的equals方法和==的作用是相同的
* 像String Date File 包装类等都重写了Object类中的equals方法。重写后，比较的是两个对象的实体内容是否相同。
*
* 通常情况下，我们需要在自定义类中对equals方法进行重新操作去判断实体内容是否相同

</pre></li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n1303" mdtype="fences"><br></pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n1304" mdtype="fences" style="break-inside: unset;">//Customer类：

import java.util.Objects;

public class Customer {
    private String name;
    private int age;

    public Customer(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public void setName(String name) {
        this.name = name;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public int getAge() {
        return age;
    }

    @Override
    public boolean equals(Object o) {	// 重写equals方法
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Customer customer = (Customer) o;
        return age == customer.age &amp;&amp; Objects.equals(name, customer.name);
    }

    @Override
    public int hashCode() {	//重写hashCode方法
        return Objects.hash(name, age);
    }

    @Override
    public String toString() {	//重写toString方法
        return "Customer{" +
                "name='" + name + '\'' +
                ", age=" + age +
                '}';
    }
}

</pre><ul><li>toString()方法的使用：</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n1308" mdtype="fences">* 1. 当输出一个对象的引用时，实际上就是调用的当前对象的toString()方法。
* 2. Object类中的toString()方法定义：
*     public String toString() {
*         return getClass().getName() + "@" + Integer.toHexString(hashCode());
*     }
* 像String Date File 包装类等都重写了Object类中的toString()方法，返回实体内容信息。
*
* 通常情况下，我们需要在自定义类中对toString方法进行重写操作返回实体内容信息

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n1309" mdtype="fences" style="break-inside: unset;">	int i = 65;
    int j = 65;
    System.out.println(i == j);// true
    boolean b = true;
    //System.out.println(i == b);// error
    char c = 65;
    System.out.println(c);// A
    System.out.println(c == i);// true

    String s1 = new String("string");
    String s2 = new String("string");
    System.out.println(s1==s2);// false
    System.out.println(s1.equals(s2));// true (重写过)

    Customer c1 = new Customer("NAME",29);
    Customer c2 = new Customer("NAME",29);
    System.out.println(c1==c2);// false
    System.out.println(c1.equals(c2));// true (equals方法重写)
    
    Customer c3 = new Customer("NAME",19);
    System.out.println(c3);// 重写toString前：JavaPackage_1.Customer@469e2a9
    System.out.println(c3.toString());// 重写toString后：Customer{name='NAME', age=19}

</pre><h2><a name='header-n1310' class='md-header-anchor '></a>49. 包装类</h2><ul><li>包装类的使用：</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n1314" mdtype="fences">* 基本数据类型：byte short int long float double boolean char
* 包装类：Byte Short Integer Long Float Double Boolean Character
*
* 基本数据类型--&gt;包装类：调用包装类的构造器
* 包装类--&gt;基本数据类型：调用包装类的xxxValue
* 基本数据类型、包装类--&gt;String：连接运算、调用String.valueOf()
* String--&gt;基本数据类型：调用包装类的parseXxx(String s)

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n1315" mdtype="fences">//Order类：

class Order{
    boolean isMale;
    Boolean isFemale;
}

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n1316" mdtype="fences" style="break-inside: unset;">	int num = 10;
    Integer integer1 = Integer.valueOf(num);
    System.out.println(integer1);// 10
    System.out.println(integer1.toString());// 10
    Integer integer2 = Integer.valueOf("123");
    System.out.println(integer2);// 123
    //Integer integer3 = Integer.valueOf("abx");
    //System.out.println(integer3);// error
    Boolean bool1 = new Boolean(true);// true
    Boolean bool2 = new Boolean("true");// true
    Boolean bool3 = new Boolean("123");// false
    System.out.println(bool3);

    Order order = new Order();
    System.out.println(order.isMale);// false
    System.out.println(order.isFemale);// null

    //包装类--&gt;基本数据类型：
    Integer integer4 = new Integer(123);
    int int4 = integer4.intValue();
    System.out.println(++int4);// 124

    //基本数据类型--&gt;String
    float f = 12.3f;
    String str1 = String.valueOf(f);
    System.out.println(str1);// 12.3
    System.out.println(f+"");// 12.3

    //String--&gt;基本数据类型
    String str2 = "12";
    int int7 = Integer.parseInt(str2);
    System.out.println(int7);// 12

</pre><ul><li>自动装箱和自动拆箱：</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n1320" mdtype="fences">// 自动装箱
    int int5 = 17;
    Integer integer5 = int5;
    System.out.println(integer5.toString());
    // 自动拆箱
    int int6 = integer5;
    System.out.println(int6);

</pre><h2><a name='header-n1321' class='md-header-anchor '></a>50. final关键字</h2><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n1322" mdtype="fences">final 关键字 代表最终的 不可改变的
常见四种用法 ： 可以用来修饰 类 方法 局部变量 成员变量

final关键字用来修饰类：
格式：public final class 类名称{
	//....
}
含义：当前这个类不能有任何的子类 
注意：一个类如果是final的 那么其中所有的成员方法都无法进行覆盖重写

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n1323" mdtype="fences">public final class MyClass{
	public void method(){
		System.out.println("方法执行");
	}
}

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n1324" mdtype="fences">final关键字用来修饰成员方法：
	这个方法就是最终方法 不能被覆盖重写
格式：
	修饰符 final 返回值类型 方法名称(参数列表){
		//方法体
	}
注意事项:对于类、方法来说 abstract关键字和final关键字不能同时使用 因为矛盾

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n1325" mdtype="fences" style="break-inside: unset;">    public abstract class Fu{
        public final void method(){
            System.out.println("父类方法执行");
        }
        public abstract void methodAbs();
    }
	
    public class Zi extends Fu{
        @Override
        public void methodAbs(){
            System.out.println("子类方法覆盖重写");
        }
        //错误写法 不能覆盖重写父类当中的final方法
		/*
		@Override
		public void method(){
		System.out.println("子类覆盖重写父类方法");
		*/
        }
    }

</pre><ul><li>final关键字修饰局部变量：</li><li>尤其是在修饰形参时，表名此形参是一个常量，调用该方法时，不能对其进行修改</li><li>static final ：用来修饰属性：全局常量</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n1333" mdtype="fences" style="break-inside: unset;">    public class Student{
        private String name;

        public String getName() {
            return name;
        }

        public void setName(String name) {
            this.name = name;
        }

        public Student(String name) {
            this.name = name;
        }

        public Student() {
        }
    }


    public static void main(String[] args) {
        int num1 = 10;
        System.out.println(num1);// 10
        num1 = 20;
        System.out.println(num1);// 20
        //一旦使用final修饰局部变量 那么这个变量就不能进行更改 一次赋值 终生不变
        final int num2 = 100;
        System.out.println(num2);// 100
        //num2 = 250;//错误写法 不能改变
        //num2 = 100；//错误写法
        final int num3;
        //正确写法 只要保证有唯一一次赋值即可
        num3 = 30;
        //对于基本类型来说 不可变说的是数据值 而对于引用类型来说 不可变的是地址值
        Student stu1 = new Student("firstname");
        System.out.println(stu1);//地址值
        System.out.println(stu1.getName());//firstname
        stu1 = new Student("secondname");
        System.out.println(stu1);//地址值改变
        System.out.println(stu1.getName());//secondname
        
        final Student stu2 = new Student("onename");
        //错误写法 final引用类型变量地址不可变
        //stu2 = new Student("twoname");
        System.out.println(stu2);//地址值
        System.out.println(stu2.getName());//onename
        stu2.setName("twoname");
        System.out.println(stu2);//地址值不变
        System.out.println(stu2.getName());//twoname 内容改变
    }

</pre><ul><li>final关键字修饰成员变量：</li><li>可以考虑赋值的位置有：显式初始化、代码块中初始化、构造器中初始化</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n1339" mdtype="fences" style="break-inside: unset;">    public class Person{
        private final String name = "name";

        public String getName() {
            return name;
        }

        public Person() {
            name = "name";
        }

        public Person(String name) {
            this.name = name;
        }
    }

</pre><h2><a name='header-n1340' class='md-header-anchor '></a>51. 四种权限修饰符比较</h2><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n1341" mdtype="fences">Java四种权限修饰符 ：
					public	&gt;	protected	&gt;	(default)	&gt;	private
同一个类(我自己)		yes			yes				yes				yes
同一个包(我邻居)		yes			yes				yes				no
不同包子类(我儿子)		yes			yes				no				no
不同包非子类(陌生人)	yes			no				no				no

注意 (default) 不是default 而是省略不写

</pre><h2><a name='header-n1342' class='md-header-anchor '></a>52. 抽象类的匿名子类</h2><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n1343" mdtype="fences" style="break-inside: unset;">//抽象Person类
abstract class Person{
    String name;
    int age;
    public Person(){

    }
    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }
    public abstract void printInfo();
}

//Worker类
class Worker extends Person{
    int worker_time;

    public Worker(int worker_time) {
        this.worker_time = worker_time;
    }

    public Worker(String name, int age, int worker_time) {
        super(name, age);
        this.worker_time = worker_time;
    }

    @Override
    public void printInfo() {
        System.out.println("name = " + name);
        System.out.println("age = " + age);
        System.out.println("worker_time = " + worker_time);
    }
}

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n1344" mdtype="fences" style="break-inside: unset;">public class Javacode {

        public static void main(String[] args) {

            Worker worker1 = new Worker("NAME",12,32);
            method(worker1); // 非匿名的类 非匿名对象
            method(new Worker(18));// 非匿名的类 匿名对象

            // 创建一匿名子类的对象
            Person person1 = new Person() {
                @Override
                public void printInfo() {
                    System.out.println("匿名子类非匿名对象");
                }
            };
            method(person1);

            // 创建匿名子类的匿名对象
            method(new Person() {
                @Override
                public void printInfo() {
                    System.out.println("匿名子类匿名对象");
                }
            });

        }

        public static void method(Person p){
            p.printInfo();
        }
}

</pre><h2><a name='header-n1345' class='md-header-anchor '></a>53. 多态多态的概述：一个对象拥有多种形态</h2><ul><li><p>面向对象的三大特征：封装性 继承性 多态性</p></li><li><p>extends继承或者implements实现 是多态性的前提</p></li><li><p>代码中体现多态性：父类引用指向子类对象</p></li><li><p>格式：</p><ul><li>父类名称 对象名 = new 子类名称();</li><li>接口名称 对象名 = new 实现类名称();</li></ul></li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n1360" mdtype="fences" style="break-inside: unset;">    public class Fu{
        public void method(){
            System.out.println("父类方法");
        }
        public void methodFu(){
            System.out.println("父类特有方法");
        }
    }
    public class Zi extends Fu{
        @Override
        public void method(){
            System.out.println("子类方法");
        }
    }

    public static void main(String[] args) {
        //使用多态的写法
        //左侧父类的引用 指向了右侧子类的对象
        Fu obj = new Zi();
        obj.method();// 子类方法
        obj.methodFu();// 父类特有方法
    }

</pre><ul><li>多态中成员变量的使用特点：</li><li>访问成员变量的两种方式：</li></ul><ol start='' ><li>直接通过对象名称访问成员变量：看等号左边是谁 优先用谁 没有则向上找</li><li>间接通过成员方法访问成员变量：看该方法属于谁 优先用谁 没有则向上找</li></ol><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n1371" mdtype="fences" style="break-inside: unset;">    public class Fu{
        int num = 10;
        public void showNum(){
            System.out.println(num);
        }
    }
    public class Zi extends Fu{
        int num = 20;
        int age = 16;
        @Override
        public void showNum(){
            System.out.println(num);
        }
        public void showAge(){
            System.out.println(age);
        }
    }

    public static void main(String[] args) {
        //使用多态写法 父类引用指向子类对象
        Fu obj = new Zi();
        System.out.println(obj.num);// 父类10
        //System.out.println(obj.age);// 错误写法
        //子类没有覆盖重写 就是父类10
        obj.showNum();
        //子类如果覆盖重写 就是子类20
        obj.showNum();
    }

</pre><ul><li><p>多态中成员方法的使用特点：</p></li><li><p>在多态的代码中 成员方法的访问规则是：</p><ul><li>看new的是谁 就优先用谁 没有则向上找</li><li>口诀：编译看左边 运行看右边</li><li>成员变量：编译看左边 运行还看左边</li><li>成员方法：编译看左边 运行看右边</li></ul></li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n1386" mdtype="fences" style="break-inside: unset;">	public class Fu{
        int num = 10;
        public void showNum(){
            System.out.println(num);
        }
        public void method(){
            System.out.println("父类方法");
        }
        public void methodFu(){
            System.out.println("父类特有方法");
        }
    }
    public class Zi extends Fu{
        int num = 20;
        int age = 16;
        @Override
        public void showNum(){
            System.out.println(num);
        }
        @Override
        public void method(){
            System.out.println("子类方法");
        }
        public void showAge(){
            System.out.println(age);
        }
        public void methodZi(){
            System.out.println("子类特有方法");
        }
    }

    public static void main(String[] args) {
        Fu obj = new Zi();//多态
        obj.showNum();
        obj.method();//父子都有 优先用子
        obj.methodFu();//子类没有父类有 向上找到父类
        //编译看左边 左边是Fu Fu当中没有methodZi()方法 所以编译报错
        //obj.methodZi();// 错误写法
    }

</pre><ul><li>使用多态的好处：(举例)</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n1390" mdtype="fences" style="break-inside: unset;">员工 work();//抽象
讲师 work();//讲课
助教 work();//辅导
如果不用多态 只用子类 那么写法是：
Teacher one = new Teacher();
one.work();//讲课
Assistant two = new Assistant();
two.work();//辅导
我现在唯一要做的事情 就是调用work方法 其他的功能不关心
如果使用多态的写法 对比一下：
Employee one = new Teacher();
one.work();//讲课
Employee two = new Assistant();
two.work();//辅导
好处：无论右边new的时候换成哪个子类对象 等号右边调用方法都不会变

</pre><h2><a name='header-n1391' class='md-header-anchor '></a>54. 对象的向上转型和向下转型</h2><ul><li>对象的向上转型 其实就是多态写法：</li><li>格式：父类名称 对象名 = new 子类名称(); Animal animal = new Cat();</li><li>含义：右侧创建一个子类对象 把他当做父类来看待使用 创建了一只猫 当做动物看待 没问题</li><li>注意事项：向上转型一定是安全的 从小范围转向大范围 从小范围的猫 向上转换成大范围的动物</li><li>向上转型的弊端：对象一旦向上转型为父类 那么就无法调用子类原本特有的内容</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n1403" mdtype="fences" style="break-inside: unset;">	public abstract class Animal{
        public abstract void eat();
    }
    public class Cat extends Animal{
        @Override
        public void eat() {
            System.out.println("猫吃鱼");
        }
		//子类特有方法
		public void catchMouse(){
			System.out.println("猫抓老鼠");
		}
    }

    public static void main(String[] args) {
        //对象向上转型 就是 父类引用指向子类对象
        Animal animal = new Cat();
        animal.eat();//猫吃鱼
		//animal.catchMouse();// 错误写法
    }

</pre><ul><li>对象的向下转型：其实是一个还原的动作</li><li>格式：子类名称 对象名 = (子类名称)父类对象;</li><li>含义：将父类对象还原为本类的子类对象</li><li>Animal animal = new Cat();// 本来是猫 向上转型为动物</li><li>Cat cat = (Cat)animal;// 本来是猫 已经被当做动物了 还原回来成为本类的猫</li><li>注意事项：</li><li>必须保证对象本来创建的时候就是猫才能向下转型称为猫</li><li>如果对象创建的时候本来不是猫 现在非要向下转型为猫 就会报错</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n1421" mdtype="fences" style="break-inside: unset;">	public abstract class Animal{
        public abstract void eat();
    }
    public class Cat extends Animal{
        @Override
        public void eat() {
            System.out.println("猫吃鱼");
        }
		//子类特有方法
		public void catchMouse(){
			System.out.println("猫抓老鼠");
		}
    }
	
    public class Dog extends Animal{
        @Override
        public void eat() {
            System.out.println("狗吃SHIT");
        }
		//子类特有方法
		public void watchHouse(){
			System.out.println("狗看家");
		}
    }
	
    public static void main(String[] args) {
        //对象向上转型 就是 父类引用指向子类对象
        Animal animal = new Cat();
        animal.eat();//猫吃鱼
		//animal.catchMouse();// 错误写法
		//向下转型 进行还原动作
		Cat cat = (Cat)animal;
		cat.catchMouse();// 猫抓老鼠
		//下面是错误的向下转型：
		//本类new的时候是一只猫 现在非要当做狗
		//错误写法 编译不会报错 但是运行有异常
		//java.lang.ClassCastException 类转换异常
		//Dog dog = (Dog)animal;
    }

</pre><h2><a name='header-n1422' class='md-header-anchor '></a>55. instanceof使用instanceof关键字进行类型判断</h2><ul><li>如何知道一个父类引用的对象本来是什么子类 </li><li>格式：</li><li>对象 instanceof 类名称</li><li>这将会得到一个boolean值结果 也就是判断前面的对象能不能做后面类型的实例</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n1432" mdtype="fences" style="break-inside: unset;">	public abstract class Animal{
        public abstract void eat();
    }
    
    public class Cat extends Animal{
        @Override
        public void eat() {
            System.out.println("猫吃鱼");
        }
		//子类特有方法
		public void catchMouse(){
			System.out.println("猫抓老鼠");
		}
    }
	
    public class Dog extends Animal{
        @Override
        public void eat() {
            System.out.println("狗吃SHIT");
        }
		//子类特有方法
		public void watchHouse(){
			System.out.println("狗看家");
		}
    }
	
    public static void main(String[] args) {
        //对象向上转型 就是 父类引用指向子类对象
        Animal animal = new Cat();
        animal.eat();//猫吃鱼
		//如果希望调用子类特有方法 需要向下转型
		//判断一下父类引用animal是不是Dog
		if(animal instanceof Dog){
			Dog dog = (Dog)animal;
			dog.watchHouse();
		} else if(animal instanceof Cat){
			Cat cat = (Cat)animal;
			cat.catchMouse();
		}
		
		giveMeAPet(new Dog());
    }
	
	public static void giveMeAPet(Animal animal){
		if(animal instanceof Dog){
			Dog dog = (Dog)animal;
			dog.watchHouse();
		} else if(animal instanceof Cat){
			Cat cat = (Cat)animal;
			cat.catchMouse();
		}
	}

</pre><h2><a name='header-n1433' class='md-header-anchor '></a>56. USB接口举例</h2><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n1434" mdtype="fences" style="break-inside: unset;">	public interface USB {
	    public abstract void open();// 打开设备
	
	    public abstract void close();//关闭设备
	
	}
	
	//鼠标就是一个USB设备
	public class Mouse implements USB{
	
	    @Override
	    public void open() {
	        System.out.println("打开鼠标");
	    }
	
	    @Override
	    public void close() {
	        System.out.println("关闭鼠标");
	    }
	
	    public void click(){
	        System.out.println("鼠标点击");
	    }
	}
	
	
	//键盘就是一个USB设备
	public class Keyboard implements USB{
	
	    @Override
	    public void open() {
	        System.out.println("打开键盘");
	    }
	
	    @Override
	    public void close() {
	        System.out.println("关闭键盘");
	    }
	    public void type(){
	        System.out.println("键盘输入");
	    }
	}
	
	
	public class Computer {
	
	    public void powerOn(){
	        System.out.println("笔记本电脑开机");
	    }
	    public void powerOff(){
	        System.out.println("笔记本电脑关机");
	    }
	    //使用USB设备方法 使用接口作为方法参数
	    public void useDevice(USB usb){
	        usb.open();// 打开设备
	        if(usb instanceof Mouse){//一定要先判断
	            Mouse mouse = (Mouse) usb;//向下转型
	            mouse.click();
	        } else if(usb instanceof Keyboard){//先判断
	            Keyboard keyboard = (Keyboard) usb;//向下转型
	            keyboard.type();
	        }
	        usb.close();// 关闭设备
	    }
	}
	
	public static void main(String[] args) {
		//首先创建一个笔记本电脑
		Computer computer = new Computer();
		computer.powerOn();
		//准备一个鼠标供电脑使用
		Mouse mouse = new Mouse();
		//首先进行向上转型
		USB usbMouse = (USB) mouse;
		//对以上三行语句整合为多态写法：USB usbMouse = new Mouse();
		//参数是USB类型 正好传进去的参数也是USB类型
		computer.useDevice(usbMouse);
		//创建一个USB键盘供电脑使用
		Keyboard keyboard = new Keyboard();//没有使用多态写法
		//方法参数是USB类型 穿进去的是实现类对象
		computer.useDevice(keyboard);//正确写法 也发生了向上转型
		//使用子类对象 匿名对象 也可以
		//对以上四行语句整合可以为：computer.useDevice(new Keyboard());//也是正确写法
		computer.powerOff();
		System.out.println("=============");
		method(10.0);//正确写法 double--&gt;double
		method(10);//正确写法 int--&gt;double
		int a = 30;
		method(a);//正确写法 int--&gt;double
	}
	public static void method(double num){
	    System.out.println(num);
	}

</pre><h2><a name='header-n1435' class='md-header-anchor '></a>57. 接口</h2><ul><li>接口就是多个类的公共规范</li><li>接口是一种引用数据类型 最重要的内容就是其中的 抽象方法</li><li>如何定义一个接口：</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n1443" mdtype="fences">public interface 接口名称{
	//接口内容
}

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n1444" mdtype="fences">备注：换成了关键字interface之后 编译生成的字节码文件仍然是 .java--&gt;.class
如果是java7 接口可以包含的内容有：
1.常量
2.抽象方法
如果是java8 接口还可以包含：
3.默认方法
4.静态方法
如果是java9 接口还可以包含：
5.私有方法

</pre><ul><li>接口的抽象方法定义：</li><li>在任何版本Java中 接口都能定义抽象方法</li><li>格式：</li><li>public abstract 返回值类型 方法名称(参数列表);</li><li>注意事项：</li></ul><ol start='' ><li>接口中的抽象方法 修饰符必须是两个固定的关键字 public abstract</li><li>这两个关键字修饰符 可以选择性地省略</li><li>方法三要素 可以随意定义</li></ol><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n1463" mdtype="fences">	public interface MyInterfaceAbstract{
        //这是一个抽象方法
        public abstract void methodAbs1();
        //这是一个抽象方法
        abstract void methodAbs2();
        //这是一个抽象方法
        public void methodAbs3();
        //这是一个抽象方法
        void methodAbs4();
    }

</pre><ul><li>接口使用步骤：</li></ul><ol start='' ><li>接口不能直接使用 必须有一个实现类来实现该接口</li></ol><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n1470" mdtype="fences">格式：
public class 实现类名称 implements 接口名称{
	// ....
}

</pre><ol start='2' ><li>接口的实现类必须覆盖重写接口中所有的抽象方法：实现：去掉关键字abstract 加上方法体和大括号</li><li>创建实现类对象 进行使用</li></ol><ul><li>注意事项：</li><li>如果实现类没有覆盖重写接口中所有的抽象方法 那么这个实现类自己就必须是抽象类</li><li>即如果实现类覆盖了接口中的所有抽象方法，则此实现类就可以实例化</li><li>如果实现类没有覆盖接口中所有的抽象方法，则此实现类仍为一个抽象类</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n1485" mdtype="fences" style="break-inside: unset;">    public interface MyInterfaceAbstract{
        //这是一个抽象方法
        public abstract void methodAbs1();
        //这是一个抽象方法
        abstract void methodAbs2();
        //这是一个抽象方法
        public void methodAbs3();
        //这是一个抽象方法
        void methodAbs4();
    }
	
    public class MyInterfaceAbstractImpl implements MyInterfaceAbstract{
        @Override
        public void methodAbs1(){
            System.out.println("这是第一个方法");
        }
        @Override
        public void methodAbs2(){
            System.out.println("这是第二个方法");
        }
        @Override
        public void methodAbs3(){
            System.out.println("这是第三个方法");
        }
        @Override
        public void methodAbs4(){
            System.out.println("这是第四个方法");
        }        
    }
	
    public static void main(String[] args) {
        //错误写法 不能直接new接口对象使用
        //MyInterfaceAbstract inter = new MyInterfaceAbstract();
        //创建实现类的对象使用
        MyInterfaceAbstractImpl inter = new MyInterfaceAbstractImpl();
        impl.methodAbs1();
        impl.methodAbs2();
    }

</pre><ul><li>从Java8开始 接口里允许定义默认方法</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n1489" mdtype="fences">格式：
public default 返回值类型 方法名称(参数列表){
	方法体
}

</pre><ul><li>备注：接口当中的默认方法，可以解决接口升级的问题</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n1493" mdtype="fences" style="break-inside: unset;">	public interface MyInterfaceDefault{
		//抽象方法
		public abstract void methodAbs1();
		//新添加了一个抽象方法
		// public abstract void methodAbs2();
		//新添加抽象方法 需要再次将实现类全部覆盖重写 这时需要将新添加的方法 改为默认方法即可 便不再需要再次全部覆盖重写
		//新添加的方法 改成默认方法 其中的public可省略
		public abstract void methodDefault(){
			System.out.println("这是新添加的默认方法");
		}
	}
	
	public class MyInterfaceDefaultA implements MyInterfaceAbstract{
		@Override
		public void methodAbs(){
			System.out.println("实现了抽象方法AAA");
		}
	}
	
	public class MyInterfaceDefaultB implements MyInterfaceAbstract{
		@Override
		public void methodAbs(){
			System.out.println("实现了抽象方法BBB");
		}
		@Override
		public void methodDefault(){
			System.out.println("实现类B覆盖重写了接口的默认方法");
		}
	}
	
	//接口的默认方法 可以通过接口实现类对象直接调用
	//接口的默认方法 也可以被接口实现类进行覆盖重写
	public static void main(String[] args) {
	    //创建了实现类对象
		MyInterfaceDefaultA a = new MyInterfaceDefaultA();
		a.methodAbs();// 调用抽象方法 实际运行的是右侧实现类
		//调用默认方法 如果实现类当中没有 会向上找接口的
		a.methodDefault();// 这是新添加的默认方法
		MyInterfaceDefaultB b = new MyInterfaceDefaultB();
		b.methodAbs();
		b.methodDefault();// 实现类B覆盖重写了接口的默认方法
	}

</pre><ul><li>接口的静态方法定义：</li><li>从Java8开始 接口中允许定义静态方法</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n1499" mdtype="fences">格式：
public static 返回值类型 方法名称 (参数列表){
	方法体
}

</pre><ul><li>提示 ：就是将abstract 或 default 换成 static即可 带上方法体</li><li>注意事项：不能通过接口实现类的对象来调用接口当中的静态方法</li><li>正确用法： 通过接口名称 直接调用其中的静态方法</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n1507" mdtype="fences" style="break-inside: unset;">	public interface MyInterfaceStatic{
		public static void methodStatic(){
			System.out.println("这是接口的静态方法");
		}
	}
	
	public class MyInterfaceStaticImpl implements MyInterfaceStatic{
		
	}
	
	public static void main(String[] args) {
		//创建了实现类对象
		MyInterfaceStaticImpl impl = new MyInterfaceStaticImpl();
		//错误写法
		//impl.methodStatic();
		//直接通过接口名称调用静态方法
		MyInterfaceStatic.methodStatic();
	}

</pre><ul><li>接口的私有方法定义：</li><li>我们需要抽取一个共有方法来解决两个默认方法直接代码重复的问题</li><li>但是这个共有方法不应该让实现类使用 应该是私有化的</li><li>解决方案：</li><li>java9开始 接口中允许定义私有方法</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n1519" mdtype="fences">1.普通私有方法 解决多个默认方法之间代码重复问题
格式  private 返回值类型 方法名称(参数列表){
	方法体
}
2.静态私有方法 解决多个静态方法之间代码重复问题
格式  private static 返回值类型 方法名称(参数列表){
	方法体
}

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n1520" mdtype="fences" style="break-inside: unset;">	public interface MyInterfacePrivate{
        public default void methodDefault1(){
            System.out.println("默认方法1");
            methodDefaultCommon();// 只有默认方法可以使用
        }
        public default void methodDefault2(){
            System.out.println("默认方法2");
            methodDefaultCommon();// 只有默认方法可以使用
        }
        private void methodDefaultCommon(){
            System.out.println("AAA");
            System.out.println("BBB");
            System.out.println("CCC");
        }
        public static void  methodStatic1(){
            System.out.println("静态方法1");
            methodStaticCommon();//只有静态方法可以使用
        }
        public static void methodStatic2(){
            System.out.println("静态方法2");
            methodStaticCommon();//只有静态方法可以使用
        }
        private static void methodStaticCommon(){
            System.out.println("XXX");
            System.out.println("YYY");
            System.out.println("ZZZ");
        }
    }

    public static void main(String[] args) {
        MyInterfacePrivate.methodStatic1();
        MyInterfacePrivate.methodStatic2();
    }

</pre><ul><li>接口的常量定义和使用：</li><li>接口当中也可以定义 成员变量 但是必须用 public static final三个关键字进行修饰</li><li>从效果上看 这其实就是接口的常量</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n1528" mdtype="fences">格式：
public static final 数据类型 变量名称 = 数据值;
备注：一旦使用final关键字进行修饰 说明不可改变

</pre><ul><li>注意事项：</li></ul><ol start='' ><li>接口当中的常量 可以省略public static final 注意 不写也照样是这样</li><li>接口当中的常量 必须进行赋值</li><li>接口中常量的名称 使用完全大写的字母 用下划线进行分隔 (推荐)</li></ol><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n1539" mdtype="fences">public interface MyInterfaceConst{
	//这其实就是一个常量 一旦赋值 不可修改
	public static final int NUM_OF_MY_CLASS = 12;
}

public static void main(String[] args) {
    //访问接口当中的变量
	System.out.println(MyInterfaceConst.NUM_OF_MY_CLASS);
}

</pre><ul><li>在Java9+版本中 接口的内容可以有：</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n1543" mdtype="fences" style="break-inside: unset;">1.成员变量其实是常量 格式：
[public] [static] [final] 数据类型 变量名称 = 数据值;
注意：
	常量必须进行赋值 且一旦赋值不能改变
	变量名称完全大写 用下划线进行分隔
	
2.接口中最重要的就是抽象方法 格式：
[public] [abstract] 返回值类型 方法名称(参数列表)；
注意：实现类必须覆盖重写接口所有的抽象方法 除非实现类是抽象类

3.从Java8开始 接口里允许定义默认方法 格式：
[public] default 返回值类型 方法名称(参数列表){ 方法体 }
注意：默认方法也可以被覆盖重写

4.从Java8开始 接口里允许定义静态方法 格式：
[public] [static] 返回值类型 方法名称(参数列表){ 方法体 }
注意：应该通过接口名称进行调用 不能通过实现类调用接口静态方法
通过实现类对象，可以调用接口中的默认方法，如果重写了默认方法，则调用的是重写以后的默认方法
默认方法与继承的父类方法同名时，子类在没有重写此方法的情况下，调用的是父类的同名同参数方法 (类优先原则)
如果实现类实现了多个接口，且在接口中存在同名同参数的方法，在没有重写的情况下，会发生接口冲突报错，在这种情况下，必须子类对该方法进行重写


5.从Java9开始 接口里允许定义私有方法 格式：
普通私有方法：private 返回值类型 方法名称(参数列表){ 方法体 }
静态私有方法：private static 返回值类型 方法名称(参数列表){ 方法体 }
注意：private的方法只有接口自己才能调用 不能被实现类或别人使用

</pre><ul><li>使用接口的时候 需要注意：</li></ul><ol start='' ><li>接口是没有静态代码块或构造方法的</li><li>一个类的直接父类只能有唯一一个 但是一个类可以同时实现多个接口</li></ol><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n1552" mdtype="fences">格式：public class MyInterfaceAbstractImpl implements MyInterfaceAbstractA,MyInterfaceAbstractB{
	//覆盖重写所有抽象方法
}

</pre><ol start='3' ><li>如果实现类所实现的多个接口当中 存在重复的抽象方法 那么只需要覆盖重写一次即可</li><li>如果实现类没有覆盖重写接口中所有的抽象方法 那么实现类就必须是一个抽象类</li><li>如果实现类所实现的多个接口当中 存在重复的默认方法 那么实现类一定要对冲突的默认方法进行覆盖重写</li><li>一个类如果直接父类当中的方法和接口当中的默认方法产生了冲突 那么优先用父类当中的方法</li></ol><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n1562" mdtype="fences" style="break-inside: unset;">	public interface MyInterfaceAbstractA{
        //错误写法 接口不能有静态代码块
        //static{}
        //错误写法 接口不能有构造方法
        //public MyInterfaceAbstractA(){}
        public abstract void methodA();
        public abstract void methodAbs();
        public default void methodDefault(){
            System.out.println("默认方法AAA");
        }
    }
    
    public interface MyInterfaceAbstractB{
        public abstract void methodB();
        public abstract void methodAbs();
        public default void methodDefault(){
            System.out.println("默认方法BBB");
        }
    }
    
    public class MyInterfaceAbstractImpl implements MyInterfaceAbstractA,MyInterfaceAbstractB{

        @Override
        public void methodA() {
            System.out.println("覆盖重写了A的抽象方法");
        }

        @Override
        public void methodB() {
            System.out.println("覆盖重写了B的抽象方法");
        }

        @Override
        public void methodAbs() {
            System.out.println("覆盖重写了AB接口都有的抽象方法");
        }

        @Override
        public void methodDefault() {
            System.out.println("对多个接口当中冲突的默认方法进行了覆盖重写");
        }

    }

    //实现类是抽象类
    public abstract  class MyInterfaceAbstract implements MyInterfaceAbstractB,MyInterfaceAbstractA{
        @Override
        public void methodA() {

        }
        @Override
        public void methodAbs() {

        }
        @Override
        public void methodDefault() {
            System.out.println("对多个接口当中冲突的默认方法进行了覆盖重写");
        }
    }
    
    //==================================

    public interface MyInterface{
        public default void method(){
            System.out.println("接口默认方法");
        }
    }
    public class Fu{
        public void method(){
            System.out.println("父类方法");
        }
    }

    public class Zi extends Fu implements MyInterface{
        
    }

    public static void main(String[] args) {
        Zi zi = new Zi();
        zi.method();// 父类方法
    }

</pre><p>1.类与类之间是单继承的 直接父类只有一个
2.类与接口之间是多实现的 一个类可以实现多个接口
3.接口与接口之间是多继承的</p><ul><li>接口之间的多继承：</li><li>注意事项：</li></ul><ol start='' ><li>多个父接口当中的抽象方法如果重复 没关系</li><li>多个父接口当中的默认方法如果重复 那么子接口必须进行默认方法的覆盖重写 而且带着default关键字</li></ol><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n1574" mdtype="fences" style="break-inside: unset;">	public interface MyInterfaceA{
        public abstract void methodA();
        public abstract void methodCommon();
        public default void methodDefault(){
            System.out.println("AAA");
        }
    }

    public interface MyInterfaceB{
        public abstract void methodB();
        public abstract void methodCommon();
        public default void methodDefault(){
            System.out.println("BBB");
        }
    }
    public interface MyInterface extends MyInterfaceA,MyInterfaceB{
       //该MyInterface接口有4个方法
        //methodA 来源于接口A
        //methodB 来源于接口B
        //methodCommon 同时来源于接口AB
        //method 来源于自己
        public abstract void method();

        @Override
        public default void methodDefault() {
            System.out.println("覆盖重写父接口中的重复默认方法");
        }
    }

</pre><h2><a name='header-n1575' class='md-header-anchor '></a>58. 接口匿名实现类的对象</h2><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n1576" mdtype="fences" style="break-inside: unset;">package JavaPackage_1;

public class USBTest {
    public static void main(String[] args) {

        Computer com = new Computer();
        //1.创建了接口的非匿名实现类的非匿名对象
        Flash flash = new Flash();
        com.transferData(flash);

        //2. 创建了接口的非匿名实现类的匿名对象
        com.transferData(new Printer());

        //3. 创建了接口的匿名实现类的非匿名对象
        USB phone = new USB(){
            @Override
            public void start() {
                System.out.println("手机开始工作...");
            }
            @Override
            public void stop() {
                System.out.println("手机结束工作...");
            }
        };
        com.transferData(phone);
        
        //4. 创建了接口的匿名实现类的匿名对象
        com.transferData(new USB(){
            @Override
            public void start() {
                System.out.println("播放器开始工作...");
            }
            @Override
            public void stop() {
                System.out.println("播放器结束工作...");
            }
        });
        
    }
}

class Computer{
    public void transferData(USB usb){ //USB usb = new Flash();
        usb.start();
        System.out.println("具体传输数据的细节...");
        usb.stop();
    }
}

interface USB{
    //常量：定义了长、宽、最大最小的传输速度等
    void start();
    void stop();
}

class Flash implements USB{
    @Override
    public void start() {
        System.out.println("U盘开启工作...");
    }
    @Override
    public void stop() {
        System.out.println("U盘结束工作...");
    }
}

class Printer implements USB{
    @Override
    public void start() {
        System.out.println("打印机开启工作...");
    }
    @Override
    public void stop() {
        System.out.println("打印机结束工作...");
    }
}

</pre><h2><a name='header-n1577' class='md-header-anchor '></a>60. 接口应用：代理模式</h2><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n1578" mdtype="fences" style="break-inside: unset;">package JavaPackage_1;

/*
 * 接口的应用：代理模式
 */
public class NetWorkTest {
    public static void main(String[] args) {
        Server server = new Server();
        ProxyServer proxyServer = new ProxyServer(server);
        proxyServer.browse();
    }
}

interface NetWork{ // 接口
    public void browse();
}

//被代理类
class Server implements NetWork{ // 服务器
    @Override
    public void browse() {
        System.out.println("真实的服务器访问网络...");
    }
}

//代理类
class ProxyServer implements NetWork{
    private NetWork work;
    public ProxyServer(NetWork work){
        this.work = work;
    }
    public void check(){
        System.out.println("联网之前的检查工作...");
    }

    @Override
    public void browse() {
        check();
        work.browse();
    }
}

</pre><h2><a name='header-n1579' class='md-header-anchor '></a>61. 实现接口和继承父类重名</h2><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n1580" mdtype="fences" style="break-inside: unset;">public class NetWorkTest {
    public static void main(String[] args) {
        new C().px();
    }
}

interface A{
    int x = 0;
}
class B{
    int x = 1;
}
class C extends B implements A{
    public void px(){
        System.out.println(super.x);// 1
        System.out.println(A.x);// 0
    }
}

</pre><h2><a name='header-n1581' class='md-header-anchor '></a>61. 内部类</h2><ul><li>内部类：</li><li>一个类的内部包含另一个类</li><li>分类：</li></ul><ol start='' ><li>成员内部类</li><li>局部内部类(包含匿名内部类)</li></ol><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n1594" mdtype="fences" style="break-inside: unset;">	public class Body{//外部类
        //外部类的成员变量
        private String name;
        //外部类的方法
        public vold methodBody(){
            System.out.println("外部类方法");
        }
        public class Heart{//成员内部类
            //内部类的方法
            public void beat(){
                System.out.println("heart");
                System.out.println(name);//内部类引用外部类成员变量
                //正确写法
            }
        }

        public Body() {
        }

        public Body(String name) {
            this.name = name;
        }

        public String getName() {
            return name;
        }

        public void setName(String name) {
            this.name = name;
        }
    }

</pre><ul><li>成员内部类的使用：</li></ul><ol start='' ><li>间接使用：在外部类的方法中 使用内部类 main知识调用外部类的 方法</li><li>直接使用：  外部类名称.内部类名称 对象名 = new 外部类名称().new 内部类名称();</li></ol><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n1603" mdtype="fences" style="break-inside: unset;">	public class Body{//外部类
        //外部类的成员变量
        private String name;
        //外部类的方法
        public vold methodBody(){
            System.out.println("外部类方法");
            new Heart().beat();//间接使用内部类
        }
        public class Heart{//成员内部类
            //内部类的方法
            public void beat(){
                System.out.println("heart");
                System.out.println(name);//内部类引用外部类成员变量
                //正确写法
            }
        }

        public Body() {
        }

        public Body(String name) {
            this.name = name;
        }

        public String getName() {
            return name;
        }

        public void setName(String name) {
            this.name = name;
        }
    }

    public static void main(String[] args) {
        Body body = new Body();//外部类的对象
        //通过外部类对象 调用外部类方法 间接使用内部类
        body.methodBody();
        //直接使用内部类
        Body.Heart heart = new Body().new Heart();
        heart.beat();
    }

</pre><ul><li><p>内部类的同名变量访问：</p><ul><li><p>如果出现了重名现象 那么格式是 外部类名称.this.外部类成员变量名</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n1610" mdtype="fences">public class Outer{
    int num = 10;//外部类成员变量
    public class Inner{
        int num = 20;//内部类成员变量
        public void methodInner(){
            int num = 30;//内部类方法的局部变量
            System.out.println(num);//局部变量 就近原则
            System.out.println(this.num);//内部类的成员变量
            System.out.println(Outer.this.num);//外部类的成员变量
        }
    }
}

</pre></li><li><p>局部内部类：</p></li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n1613" mdtype="fences">修饰符 class 外部类名称{
修饰符 返回值类型 外部类方法名称(参数列表){
		class 局部内部类名称{
			//...
		}
		//...
	}
	//...
}

</pre></li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n1614" mdtype="fences"><br></pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n1615" mdtype="fences" style="break-inside: unset;">    public class Outer{
        public void methodOuter(){
            class Inner{//局部内部类
                int num = 10;
                public void methodInner(){
                    System.out.println(num);// 10
                }
            }
            Inner inner = new Inner();
            inner.methodInner();
        }
    }

    public static void main(String[] args) {
        Outer outer = new Outer();
        outer.methodOuter();
    }

</pre><ul><li>定义一个类的时候 权限修饰符的规则：</li></ul><ol start='' ><li>外部类 public / (default)</li><li>成员内部类 public<span>	</span>/ protected / (default) / private</li><li>局部内部类 什么也不能写</li></ol><ul><li>局部内部类的final问题 ：</li><li>局部内部类如果希望访问所在方法的局部变量 那么这个局部变量必须是有效final的</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n1631" mdtype="fences">public class Outer{
	public void methodOuter(){
		final int num = 10;//所在方法的局部变量
		class MyInner{
			public void methodInner(){
				System.out.println(num);
			}
		}
	}
}

</pre><ul><li><p>匿名内部类 :</p><ul><li>如果接口的实现类(或者是父类的子类)只需要使用唯一的一次</li><li>那么这种情况下就可以省略掉该类的定义 而改为使用 匿名内部类</li></ul></li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n1640" mdtype="fences">定义格式：
接口名称 对象名 = new 接口名称(){
	//覆盖重写所有抽象方法
};

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n1641" mdtype="fences" style="break-inside: unset;">	public interface MyInterface{
        public abstract void method();
    }

    public static void main(String[] args) {
        //使用匿名内部类
        MyInterface obj = new MyInterface() {
            @Override
            public void method() {
                System.out.println("匿名内部类实现类方法");
            }
        };
        obj.method();
		//使用匿名内部类 而且使用了省略对象名称 也是匿名对象
        
		new MyInterface() {
            @Override
            public void method() {
                System.out.println("匿名内部类实现类方法");
            }
        }.method();
    }

</pre><ul><li>对“new 接口名称(){...}”进行解析：</li></ul><ol start='' ><li>new代表创建对象的动作</li><li>接口名称就是匿名内部类需要实现哪个接口</li><li>{...}这才是匿名内部类的内容</li></ol><ul><li>注意：</li></ul><ol start='' ><li>匿名内部类 在创建对象的时候 只能使用唯一一次
如果希望多次创建对象 而且内容一样的话 就需要单独定义实现类了</li><li>匿名对象 在调用方法的时候 只能使用唯一一次
如果希望同一个对象调用多次方法 那么必须给对象起一个名字</li><li>匿名内部类是省略了【实现类/子类名称】但是匿名对象是省略了 对象名称
匿名内部类和匿名对象不是一回事！！！</li></ol><h2><a name='header-n1662' class='md-header-anchor '></a>62. 类作成员变量</h2><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n1663" mdtype="fences" style="break-inside: unset;">	public class Weapon{
        private String code;//武器代号
        public Weapon() {
        }
        public Weapon(String code) {
            this.code = code;
        }
        public String getCode() {
            return code;
        }
        public void setCode(String code) {
            this.code = code;
        }
    }
    
    public class Hero{
        private String name;//英雄的名字
        private int age;//英雄的年龄
        private Weapon weapon;//英雄的武器
        public Hero() {
        }
        public Hero(String name, int age, Weapon weapon) {
            this.name = name;
            this.age = age;
            this.weapon = weapon;
        }
        public String getName() {
            return name;
        }
        public void setName(String name) {
            this.name = name;
        }
        public int getAge() {
            return age;
        }
        public void setAge(int age) {
            this.age = age;
        }
        public Weapon getWeapon() {
            return weapon;
        }
        public void setWeapon(Weapon weapon) {
            this.weapon = weapon;
        }
        public void attack(){
            System.out.println("年龄为"+age+"岁的"+name+"用"+weapon.getCode()+"正在攻击对方");
        }
    }

    public static void main(String[] args) {
        //创建一个英雄角色
        Hero hero = new Hero();
        hero.setAge(20);
        hero.setName("hero's name");
        //创建一个武器对象
        Weapon weapon = new Weapon("hero's weapon");
        hero.setWeapon(weapon);
        hero.attack();
    }

</pre><h2><a name='header-n1664' class='md-header-anchor '></a>63. 接口作成员变量、形参和返回值</h2><ul><li>接口作为成员变量类型：</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n1668" mdtype="fences" style="break-inside: unset;">	public interface Skill{
        public abstract void use();//释放技能的抽象方法
    }
    
    public class Hero{
        private String name;
        private Skill skill;

        public Hero() {
        }

        public Hero(String name, Skill skill) {
            this.name = name;
            this.skill = skill;
        }

        public String getName() {
            return name;
        }

        public void setName(String name) {
            this.name = name;
        }

        public Skill getSkill() {
            return skill;
        }

        public void setSkill(Skill skill) {
            this.skill = skill;
        }
        public void attack(){
            System.out.println("我叫"name+"开始释放技能：");
            skill.use();//调用接口中的抽象方法
            System.out.println("技能释放完毕");
        }
    }
    
    public class SkillImpl implements Skill{
        @Override
        public void use(){
            System.out.println("Biu~biu~biu~");
        }
    }

    public static void main(String[] args) {
        Hero hero = new Hero();
        hero.setName("name");
        hero.setSkill(new SkillImpl());//使用单独定义的实现类
        hero.attack();
		
		//这里还可以改用匿名内部类 即不再需要定义接口的实现类 
		Skill skill = new Skill(){
			@Override
			public void use(){
				System.out.println("pia~pia~pia!");
			}
		};
		hero.setSkill(skill);
		hero.attack();
		
		//进一步简化 同时使用匿名内部类和匿名对象
		hero.setSkill(new Skill{
			@Override
			public void use(){
				System.out.println("papapa");
			}
		});
		
		hero.attack();
    }

</pre><ul><li>接口作为方法的参数和返回值：</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n1672" mdtype="fences" style="break-inside: unset;">public static void main(String[] args) {
        //左边是接口名称 右边是实现类名称 多态写法
        List&lt;String&gt; list = new ArrayList&lt;&gt;();
        List&lt;String&gt; result = addNames(list);
        for(int i = 0; i&lt;result.size();i++){
            System.out.println(result.get(i));
        }
        
    public static List&lt;String&gt; addNames(List&lt;String&gt; list){
        list.add("name1");
        list.add("name2");
        list.add("name3");
        list.add("name4");
        return list;
    }
}

</pre><h2><a name='header-n1673' class='md-header-anchor '></a>64. 发红包案例</h2><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n1674" mdtype="fences" style="break-inside: unset;">用户类：姓名，余额
群主类：发红包的方法
普通类：收红包的方法
发红包的逻辑，三要素：
返回值类型： ArrayList&lt;Integer&gt;
方法名称：send
	参数列表：1.总钱数 int totalMoney 2.份数 int count
	public ArrayList&lt;Integer&gt; send(int totalMoney,int count){
		//...
	}
收红包的逻辑，三要素：
返回值类型：void
方法名称：receive
	参数列表：ArrayList&lt;Integer&gt;
	public void receive(ArrayList&lt;Integer&gt; list){
		//...
	}

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n1675" mdtype="fences" style="break-inside: unset;"> 	//用户的类
    public class User{
        private String name;// 姓名
        private int money;//余额 用户当前拥有的钱数

        public String getName() {
            return name;
        }

        public void setName(String name) {
            this.name = name;
        }

        public int getMoney() {
            return money;
        }

        public void setMoney(int money) {
            this.money = money;
        }

        public User(String name, int money) {
            this.name = name;
            this.money = money;
        }

        public User() {
        }

        public void show1(){
            System.out.println("我叫："+name+" 我目前有"+money+"块钱");
        }
        public void show2(){
            System.out.println("我叫："+name+"我现在有"+money+"块钱");
        }
    }
    
    //群主的类
    //import.java.util.ArrayList;
    public class Manager extends User{
        public Manager(){

        }
        public Manager(String name, int money) {
            super(name, money);
        }
        public ArrayList&lt;Integer&gt; send(int totalMoney,int count){
            //首先需要一个集合用来存储若干个红包的金额
            ArrayList&lt;Integer&gt; redList = new ArrayList&lt;&gt;();
            //首先看一下群主有多少钱
            int leftMoney = super.getMoney();//群主当前的余额
            if(totalMoney&gt;leftMoney){
                System.out.println("当前余额不足");
                return redList;//返回空集合
            }
            //扣钱 其实就是重新设置余额
            super.setMoney(leftMoney-totalMoney);
            //发红包需要平均拆分成count份
            int avg = totalMoney/count;
            int mod = totalMoney%count;//余数 就是甩下的零头
            //除不开的零头 放在最后一个红包中
            //下面把红包一个一个放在集合中
            for (int i = 0; i &lt; count - 1; i++) {
                redList.add(avg);
            }
            //最后一个红包
            int last = avg + mod;
            redList.add(last);
            return redList;
        }
    }

    //普通成员
    //import java.util.ArrayList;
    //import java.util.Random;
    public class Member extends User{
        public Member(){

        }

        public Member(String name, int money) {
            super(name, money);
        }

        public void receive(ArrayList&lt;Integer&gt; list){
            //从多个红包中随便抽取一个 给我自己
            //随机获取一个集合当中的索引编号
            int index = new Random().nextInt(list.size());
            //根据索引 从集合当中删除 并且得到被删除的红包给我自己
            int delta = list.remove(index);
            //当前成员本来有多少钱
            int money = super.getMoney();
            //加法 并且重新设置回去
            super.setMoney(money+delta);
        }
    }

    public static void main(String[] args) {
        Manager manager = new Manager("群主",100);
        Member one = new Member("成员A",0);
        Member two = new Member("成员B",0);
        Member three = new Member("成员C",0);
        Member four = new Member("成员D",0);
        Member five = new Member("成员E",0);
        Member six = new Member("成员F",0);
        Member seven = new Member("成员F",0);
        manager.show1();
        one.show1();
        two.show1(); 
        three.show1();
        four.show1();
        five.show1();
        six.show1();
        seven.show1();
        System.out.println("================");
        //群主共法54元钱 分成7个包
        ArrayList&lt;Integer&gt; redList = manager.send(54,7);
        //7个成员收红包
        one.receive(redList);
        two.receive(redList);
        three.receive(redList);
        four.receive(redList);
        five.receive(redList);
        six.receive(redList);
        seven.receive(redList);
        manager.show2();
        one.show2();
        two.show2();
        three.show2();
        four.show2();
        five.show2();
        six.show2();
        seven.show2();        
    }

</pre><p>&nbsp;</p><h2><a name='header-n1677' class='md-header-anchor '></a>65. 异常处理</h2><ul><li><p>异常：</p><ol start='' ><li>java.lang.Throwable类是Java语言中所有错误或异常的超类</li><li>Exception：编译期异常 进行编译时java程序出现的问题</li><li>RunTimeException：运行期异常 java程序运行过程中出现的问题
异常相当于程序的毛病 将异常处理掉可继续执行程序</li><li>Error：错误
必须修改源代码 程序才能继续执行</li></ol></li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n1690" mdtype="fences" style="break-inside: unset;">	import java.text.ParseException;
	import java.text.SimpleDateFormat;
	import java.util.Date;

	public static void main(String[] args) /* throws ParseException */*/*/ {
        //Exception：编译期异常 进行编译时java程序出现的问题
        SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd");//用来格式化日期
        Date date = null;//将字符串格式日期解析为Date格式日期
        try {
            date = simpleDateFormat.parse("1999-29-99");
        } catch (ParseException e) {
            e.printStackTrace();
        }
        System.out.println(date);
        System.out.println("后续代码01");
        //RuntimeException：运行期异常 java程序运行过程中出现的问题
        int[] arr = {1,2,3};
        System.out.println(arr[0]);
        try {
            //可能出现异常的代码
            System.out.println(arr[3]);
        } catch (Exception e){
            //处理异常的逻辑
            System.out.println(e);
        }
        System.out.println("后续代码02");
        //Error错误：OutOfMemoryError:Java heap space 内存溢出错误 创建的数组太大 超出了JVM分配的内存
        //int[] arr = new int[1024*1024*1024];//必须修改代码 创建小的数组
        System.out.println("后续代码03");
    }
</pre><ul><li>异常的处理：</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n1694" mdtype="fences">Java异常处理的五个关键字：try catch finally throw throws

throw关键字：
作用：可以使用throw关键字在指定的方法中抛出指定的异常
使用格式：throw new xxxException("异常产生的原因");
注意：
	1.throw关键字必须写在方法的内部
	2.throw关键字后面的new的对象必须是Exception或者Exception的子类对象
	3.throw关键字抛出指定的异常对象 就必须处理这个异常对象
		throw关键字后面创建的是RuntimeException或者是RUNtimeException的子类对象 我们可以不处理 默认交给JVM处理(打印异常对象 中断程序)
		throw关键字后面创建的是编译异常 那么就必须处理这个异常 要么throws 要么try...catch
</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n1695" mdtype="fences" style="break-inside: unset;">	public static void main(String[] args) {
        int[] arr1 = null;
        int e1 = getElement(arr1,0);
        System.out.println(e1);
        int[] arr2 = new int[3];
        int e2 = getElement(arr2,3);
        System.out.println(e2);
    }
    //定义一个方法 获取数组指定索引处的元素
    //以后必须首先对方法传递过来的参数进行合法性校验 如果参数不合法 那么就必须使用抛出异常的方式告知方法调用者 传递的参数异常
    //注意：
    //  NullPointerException是一个运行期异常 默认交给JVM处理
    //  ArrayIndexOutOfBoundException是一个运行期异常 默认交给JVM处理
    
    public static int getElement(int[] arr,int index){
        //如果数组arr的值为null 那么抛出空指针异常 告知调用者"传递的数组的值为null"
        if(arr==null){
            throw new NullPointerException("传递的数组的值为null");
        }
        //对传递的index进行校验 如果不在数组的索引范围内 抛出数组索引越界异常 告知调用者"传递的索引值超出了数组的索引范围"
        if(index&lt;0||index&gt;arr.length-1){
            throw new ArrayIndexOutOfBoundsException("传递的索引值超出了数组的索引范围");
        }
        int ele = arr[index];
        return ele;
    }
</pre><ul><li><p>Objects非空判断：</p><ol start='' ><li>查看指定引用对象是否为空</li></ol></li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n1702" mdtype="fences">    public static void main(String[] args) {
        method(null);
    }
    public static void method(Object obj){
        //对传递过来的参数进行合法性判断 判断是否为null
        Objects.requireNonNull(obj);
        Objects.requireNonNull(obj,"传递的对象的值为null");
    }	
</pre><p>异常处理的第一种方式——声明异常throws：</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n1704" mdtype="fences" style="break-inside: unset;">作用：
		当方法内部抛出异常对象的时候 那么就必须处理这个异常对象
		可以使用throws关键字处理异常对象 会把异常对象声明抛出给方法的调用者处理 最终交给JVM处理
	使用格式：在方法声明时使用 
		修饰符 返回值类型 方法名(参数列表) throws AAAException,BBBException...{
			throw new AAAException("产生原因");
			throw new BBBException("产生原因");
		}
	注意：
		1.throws关键字必须写在方法声明出
		2.throws关键字后面声明的异常必须是Exception或者Exception的子类
		3.方法内部如果抛出了多个异常对象 那么throws后面必须也声明多个异常
			如果抛出的多个异常对象有子父类关系 那么直接声明父类异常即可
		4.调用了一个声明抛出异常的方法 我们就必须处理声明的异常
			要么继续使用throws声明抛出 将异常交给方法的调用者处理 最终交给JVM处理
			要么try...catch自己处理异常
</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n1705" mdtype="fences" style="break-inside: unset;">	//public static void main(String[] args) throws FileNotFoundException,IOException
    //public static void main(String[] args) throws IOException
    public static void main(String[] args) throws Exception{
        //FileNotFoundException extends IOException extends Exception
        //若果抛出多个异常对象有子父类关系 那么直接声明父类异常即可
        readFile("C:\\a.txt");
		System.out.print("后续代码不会执行");
        readFile("c:\\a.mp3");
    }
    //定义一个方法对传递的文件路径进行合法性判断
    //如果不是"c:\\a.txt"那么抛出文件找不到异常对象 告知方法调用者
    //注意：
    //      FileNotFoundException是编译异常 抛出编译异常就必须处理这个异常
    //      可以使用throws继续声明抛出FileNotFoundException这个异常对象 让方法的调用者处理

    public static void readFile(String fileName) throws IOException {
        if(!fileName.equals("c:\\a.txt")){
            throw new FileNotFoundException("传递的文件路径不是c:\\a.txt");
        }
        //若果传递的路径不是.txt结尾 那么抛出IO异常对象 告知方法调用者 文件后缀名错误
        if(!fileName.endsWith(".txt")){
            throw new IOException("文件后缀名错误");
        }
        System.out.println("路径正确 读取文件");
    }
</pre><p>异常处理的第二种方式——捕获异常 try...catch ：</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n1707" mdtype="fences">	 格式：
		try{
			可能产生异常的代码
		} catch(定义一个异常的变量 用来接收try中抛出的异常对象) {
			异常处理逻辑
			一般在工作中 会把异常的信息记录到一个日志中
		} catch(异常类名 变量名) {
			
		}
	注意：
		1.try中可能会抛出多个异常对象 那么就可以使用多个catch来处理这些异常对象
		2.如果try中产生了异常 那么就会执行catch中的异常处理逻辑 执行完毕后 继续执行try...catch之后的代码
		如果try中未产生异常 那么就不会执行catch中的异常处理逻辑 执行完try代码后继续执行try...catch之后的代码
</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n1708" mdtype="fences" style="break-inside: unset;">	public static void main(String[] args) {
        try{
            //可能产生异常的代码
            readFile("d:\\a.map");
        } catch (IOException e){//try中抛出什么异常对象 catch就定义什么异常变量 用来接收这个异常对象
            //异常处理的逻辑
            System.out.println("catch - 传递的文件后缀不是.txt");
        }
        System.out.println("后续代码执行");
    }
	
    //如果传递路径不是.txt结尾 那么抛出IO异常对象 告知方法调用者 文件后缀名错误
    public static void readFile(String fileName) throws IOException{
        if(!fileName.endsWith(".txt")){
            throw new IOException("文件后缀名错误");
        }
        System.out.println("路径正确 读取文件");
    }
</pre><ul><li><p>Throwable类三个异常处理方法：</p><ol start='' ><li>String getMessage() 返回此throwable的简短描述</li><li>String toString() 返回此throwable的详细消息字符串</li><li>void printStackTrace() JVM打印异常对象 默认此方法 打印异常信息最全面</li></ol></li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n1719" mdtype="fences" style="break-inside: unset;">	public static void main(String[] args) {
        try{
            //可能产生异常的代码
            readFile("d:\\a.map");
        } catch (IOException e){//try中抛出什么异常对象 catch就定义什么异常变量 用来接收这个异常对象
            
			
			//异常处理的逻辑
			System.out.println(e.getMessage());//文件后缀名不对
			System.out.println(e.toString());//重写Object类的toString java.io.IOException：文件后缀名不对
			System.out.println(e);//
			
        }
        System.out.println("后续代码执行");
    }
	
	
    //如果传递路径不是.txt结尾 那么抛出IO异常对象 告知方法调用者 文件后缀名错误
    public static void readFile(String fileName) throws IOException{
        if(!fileName.endsWith(".txt")){
            throw new IOException("文件后缀名错误");
        }
        System.out.println("路径正确 读取文件");
    }

</pre><h2><a name='header-n1720' class='md-header-anchor '></a>66. finally代码块</h2><ul><li>finally代码块：</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n1724" mdtype="fences" style="break-inside: unset;">	格式：
		try{
			可能产生异常的代码
		} catch(定义一个异常的变量 用来接收try中抛出的异常对象) {
			异常处理逻辑
			一般在工作中 会把异常的信息记录到一个日志中
		} catch(异常类名 变量名) {
			
		} finally{
			无论是否出现异常都会执行
		}
	注意：
		1.finally不能单独使用 必须和try一起使用
		2.finally一般用于资源释放 无论程序是否出现异常 最后都要资源释放(IO)

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n1725" mdtype="fences" style="break-inside: unset;">	public static void main(String[] args) {
        try{
            //可能产生异常的代码
            readFile("d:\\a.map");
        } catch (IOException e){//try中抛出什么异常对象 catch就定义什么异常变量 用来接收这个异常对象
            //异常处理的逻辑
            System.out.println("catch - 传递的文件后缀不是.txt");
        } finally{//无论是否出现异常都会执行
		
			System.out.println("资源释放");
		}
		
        System.out.println("后续代码执行");
    }
	
    //如果传递路径不是.txt结尾 那么抛出IO异常对象 告知方法调用者 文件后缀名错误
    public static void readFile(String fileName) throws IOException{
        if(!fileName.endsWith(".txt")){
            throw new IOException("文件后缀名错误");
        }
        System.out.println("路径正确 读取文件");
    }

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n1726" mdtype="fences" style="break-inside: unset;">public class NetWorkTest {
    public static void main(String[] args)  {
        FileInputStream fis = null;
        try {
            File file = new File("HRLLO.txt");
            fis = new FileInputStream(file);
            int data = fis.read();
            while (data != -1){
                System.out.println((char)data);
                data = fis.read();
            }
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e){
            e.printStackTrace();
        } finally {
            try {
                if(fis != null)
                    fis.close();
            } catch (IOException e){
                e.printStackTrace();
            }
        }
    }
}

</pre><h2><a name='header-n1727' class='md-header-anchor '></a>67. 异常注意事项</h2><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n1728" mdtype="fences">异常的注意事项：
	多异常的捕获处理：
		1.多个异常分别处理
		2.多个异常一次捕获 多次处理
			注意事项：
				一个try 多个catch catch里面定义的异常变量 如果有子父类关系 那么子类的异常变量必须写在父类的异常变量的上面 否则就会报错
				ArrayIndexOutOfBoundsException extends IndexOutOfBoundsException
		3.多个异常一次捕获 一次处理

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n1729" mdtype="fences" style="break-inside: unset;">	public static void main(String[] args) {
        //1.多个异常分别处理
        try {
            int[] arr = {1,2,3};
            System.out.println(arr[3]);
        } catch (ArrayIndexOutOfBoundsException e){
            System.out.println(e);
        }

        try {
            List&lt;Integer&gt; list = List.of(1,2,3);
            System.out.println(list.get(3));
        } catch (IndexOutOfBoundsException e){
            System.out.println(e);
        }
        System.out.println("后续代码01执行");
        
		//2.多个异常一次捕获 多次处理
        try {
            int[] arr = {1,2,3};
            System.out.println(arr[3]);
        } catch (ArrayIndexOutOfBoundsException e){
            System.out.println(e);
        } catch (IndexOutOfBoundsException e){
            System.out.println(e);
        }
        System.out.println("后续代码02执行");
        
        //3.多个异常一次捕获 一次处理
        try {
            int[] arr = {1,2,3};
            System.out.println(arr[3]);
			List&lt;Integer&gt; list = List.of(1,2,3);
            System.out.println(list.get(3));
        } catch (Exception e){
            System.out.println(e);
        }
	}
	
	//运行时异常被抛出可以不处理 既不捕获也不声明抛出
	//默认给虚拟机处理 终止程序 什么时候运行时不抛出异常 再继续执行程序

</pre><ul><li><p>异常的注意事项：</p><ul><li>如果finally中有return语句 永远返回的都是finally中的结果 应避免此类情况</li></ul></li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n1736" mdtype="fences" style="break-inside: unset;">	public static void main(String[] args) {
        int a = getA();
        System.out.println(a);// 100
    }
    public static int getA(){
        int a = 10;
        try {
            return a;
        } catch (Exception e) {
            System.out.println(e);
        } finally {
            //一定会执行的代码
            a = 100;
            return a;
        }
    }

</pre><p>异常的注意事项：</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n1738" mdtype="fences">	执行的方法a中，先后又调用了另外几个方法，这几个方法是递进关系执行的，建议这几个方法使用throws进行处理，而执行的方法a可以考虑try-catch-finally进行处理
	子父类的异常：
	- 如果父类抛出了多个异常 子类重写父类的方法时 抛出和父类相同的异常或者是父类异常的子类或者不抛出异常
	- 父类方法没有抛出异常 子类重写父类的方法时也不可抛出异常 此时子类产生该异常 只能捕获处理 不能声明抛出
	注意：
		父类异常时什么样 子类异常就是什么样

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n1739" mdtype="fences" style="break-inside: unset;">	public class Fu{
        public void show01() throws NullPointerException,ClassCastException{}
        public void show02() throws IndexOutOfBoundsException{}
        public void show03() throws IndexOutOfBoundsException{}
        public void show04() throws {}
    }
    public class Zi extends Fu{
        //子类重写父类方法时 抛出和父类相同的异常
        public void show01() throws NullPointerException,ClassCastException{}
        //子类重写父类方法时 抛出父类异常的子类
        public void show02() throws IndexOutOfBoundsException{}
        //子类重写父类方法时 不抛出异常
        public void show03(){}
        //父类方法没有抛出异常 子类重写父类该方法时也不可抛出异常
        //public void show04() throws Exception{}
        //此时子类产生该异常 只能捕获处理 不能声明抛出
        public void show04(){
            try {
                throw new Exception("编译期异常");
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }

</pre><h2><a name='header-n1740' class='md-header-anchor '></a>68. 自定义异常类</h2><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n1741" mdtype="fences">自定义异常类：
	格式：
		public class XXXException extends Exception / RuntimeException{
			添加一个空参数的构造方法
			添加一个带异常信息的构造方法
		}
	注意：
		1.自定义异常类一般都是以Exception结尾 说明该类是一个异常类
		2.自定义异常类 必须的继承Exception 或 RuntimeException
			继承Exception 那么自定义的异常类就是一个编译期异常 如果方法内部抛出了编译期异常 就必须处理这个异常对象 要么throws 要么try...catch
			继承RuntimeException 那么自定义的异常类就是一个运行期异常 无序处理 交给虚拟机处理(中断处理)

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n1742" mdtype="fences">	public class RegisterException extends Exception{
        //添加一个空参数的构造方法
        public RegisterException(){
            
        }
        //添加一个带异常信息的构造方法
        //方法内部会调用父类带异常信息的构造方法 让父类来处理这个异常信息
        public RegisterException(String message){
            super(message);
        }
    }

</pre><p><strong>练习：</strong></p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n1744" mdtype="fences">自定义异常练习：
	
要求：模拟注册操作 如果用户名已经存在 则抛出异常并提示 亲 该用户名已经被注册
	分析：
		1.使用数组保存已经注册过的用户名 (数据库)
		2.使用Scanner获取用户输入的注册的用户名 (前端 页面)
		3.定义一个方法 对用户输入的注册的用户名进行判断
			遍历存储已经注册过的用户名的数组 获取每一个用户名
			使用获取到的用户名和用户输入的用户名进行比较
				true：用户名已经存在 抛出RegisterException异常 告知用户"亲，该用户名已经被注册"
				false：继续遍历比较 如果循环结束后 还没有找到重复的用户名 则提示用户"恭喜您 注册成功"

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n1745" mdtype="fences" style="break-inside: unset;">	public static void main(String[] args) throws ParseException, RegisterException {
		//2.使用Scanner获取用户输入的注册的用户名(前端 页面)
        Scanner sc = new Scanner(System.in);
        System.out.println("请输入需要注册的用户名：");
        String username = sc.next();
        checkUsername(username);
	}	

    //3.定义一个方法 对用户输入的需要注册的用户名进行判断
    public static void checkUsername(String username) throws RegisterException {
        //1.使用数组保存已经注册过的用户名(数据库)
        String[] usersnames = {"one","two","three","four","five"};
        //遍历存储已经注册过的用户名数组 获取每一个用户名
        for(String name : usersnames) {
            //使用获取到的用户名和用户输入的用户名进行比较
            if(name.equals(username)){
                //true:用户名已经存在 抛出RegisterException异常 告知用户"亲，该用户名已经被注册
                throw new RegisterException("亲，该用户名已经被注册");
            }
        }
        //如果循环结束了还没有找到重复的用户名 提示用户"恭喜您 注册成功"
        System.out.println("恭喜您 注册成功");
    }

</pre><ul><li>Java9新特性</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n1749" mdtype="fences">InputStreamReader reader = new InputStreamReader(System.in);
OutputStreamWriter writer = new OutputStreamWriter(System.out);
try (reader; writer) {
//reader是final的，不可再被赋值
//reader = null;
//具体读写操作省略
} catch (IOException e) {
e.printStackTrace();
}

</pre><h2><a name='header-n1750' class='md-header-anchor '></a>69. Date类</h2><ul><li>毫秒值的概念和作用 ：</li><li>java.util.Date是用来表示日期和时间的类</li><li>1秒=1000毫秒</li><li>时间原点：1970.1.1 00:00:00(英国格林威治)</li><li>中国 1970.1.1 08:00:00  </li><li>1天==86400000 ms</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n1764" mdtype="fences">System.out.println(System.currentTimeMillis());
//获取当前系统时间到1970.1.1 00:00:00经历了多少毫秒

</pre><ul><li>Date类的构造方法和成员方法：</li><li>long getTime() 把日期转换为毫秒值；</li><li>toString() 显示当前的年月日时分秒</li><li>返回自1970.1.1 00:00:00 GMT 以来到目前表示的毫秒数</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n1774" mdtype="fences">	Date date = new Date();
	long time = date.getTime();
	System.out.println(time);

</pre><ul><li>Date的带参数的构造方法 Date(long date) </li><li>传递毫秒值 把毫秒值转换为Date日期</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n1780" mdtype="fences">	Date date = new Date(0L);
	System.out.println(date);
	//Thu Jan 01 08:00:00 CST 1970

</pre><ul><li>Date空参构造方法 Date() 获取当前系统日期和时间</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n1784" mdtype="fences">	Date date = new Date();
	System.out.println(date);
	System.out.println(new Date());

</pre><ul><li>java.util.Date和java.sql.Date的转换</li><li><code>java.util.Date是java.sql.Date的父类</code></li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n1790" mdtype="fences">	//创建java.sql.Date对象
    java.sql.Date date = new java.sql.Date(352345L);
    System.out.println(date);//1971-02-13

    //将java.util.Date对象转换为java.sql.Date对象
    //情况一：
	Date date4 = new java.sql.Date(2343243242323L);
    java.sql.Date date5 = (java.sql.Date) date4;
    //情况二：
    Date date6 = new Date();
    java.sql.Date date7 = new java.sql.Date(date6.getTime());

</pre><h2><a name='header-n1791' class='md-header-anchor '></a>70. DateFormat类</h2><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n1792" mdtype="fences" style="break-inside: unset;">DateFormat类：
	java.text.DateFormat 是日期时间格式化子类的抽象类
	作用：格式化 解析
	成员方法：
		String format(Date date) 按照指定模式 把Date日期 格式化为符合模式的字符串
		Date parse(String source) 把符合模式的字符串解析为日期
	
DateFormat类是一个抽象类 无法直接创建对象使用 可以使用DateFormat类的子类

java.text.SimpleDateFormat extends DateFormat
	构造方法：
		SimpleDateFormat(String pattern) 用给定的模式和默认语言环境的日期格式符号构造
		参数：String pattern 传递指定的模式
		
注意：
写对应的模式 会把模式替换为对应的日期和时间"yyyy-MM-dd HH:mm:ss"
模式中的字母不能更改 连接模式的符号可以改变

</pre><ul><li><p>使用DateFormat类中方法parse把文本解析为日期：</p></li><li><p>步骤</p><ol start='' ><li>创建SimpleDateFormat对象 构造方法中传递指定的模式</li><li>调用SimpleDateFormat对象中的parse方法 把符合构造方法中模式的字符串 解析为Date日期</li></ol></li><li><p>注意：</p></li><li><p>public Date parse(String source) throws ParseException
<span>	</span>parse方法声明了一个异常 ParseException
<span>	</span>如果字符串和构造方法的模式不一样 那么程序就会抛出此异常
<span>	</span>调用一个抛出了异常的方法 就必须处理这个异常 要么throws继续抛出这个异常 
<span>	</span>要么try catch自己处理异常</p></li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n1807" mdtype="fences">	public static void test() throws ParseException {
        //1.创建SimpleDateFormat对象 构造方法中传递指定的模式
        SimpleDateFormat sdf = new SimpleDateFormat("yyyy年MM月dd日 HH时mm分ss秒");
        //2.调用SimpleDateFormat对象中的parse方法 把符合构造方法中模式的字符串解析为Date日期
        //Date parse(String source) 把符合模式的字符串解析为Date日期
        Date date = sdf.parse("2088年5月6日 02时35分52秒");
        System.out.println(date);
    }

</pre><ul><li><p>使用DateFormat类中方法format将日期格式化为文本：</p></li><li><p>步骤：</p><ol start='' ><li>创建SimpleDateFormat对象 构造方法中传递指定的模式</li><li>调用SimpleDateFormat对象中的方法format 按照构造方法中指定模式 把Date日期格式化为符合模式的字符串</li></ol></li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n1818" mdtype="fences">    public static void test(){
        //1.创建SimpleDateFormat对象 构造方法中传递指定的模式
        SimpleDateFormat sdf = new SimpleDateFormat("yyyy年MM月dd日 HH时mm分ss秒");
        //2.调用SimpleDateFormat对象中的方法format 按照构造方法中指定模式 把Date日期格式化为符合模式的字符串
        //String format(Date date) 按照指定模式 把Date日期格式化为符合模式的字符串
        Date date = new Date();
        String str = sdf.format(date);
        System.out.println(date);
        System.out.println(str);
    }

</pre><p><strong>计算一个人从出生到现在活了多少天：</strong></p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n1820" mdtype="fences" style="break-inside: unset;">    public static void test() throws ParseException {
        //1.使用Scanner类中的方法next获取出身日期
        Scanner sc = new Scanner(System.in);
        System.out.println("请输入出生日期，格式为“yyyy-MM-dd” :");
        String birthdayDateString = sc.next();
        //2.使用DateFormat类中的方法parse把字符串解析为Date格式
        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd");
        Date birthdayDate = sdf.parse(birthdayDateString);
        //3.把Date格式的出生日期转换为毫秒值
        long birthdayDateTime = birthdayDate.getTime();
        //4.获取当前日期的毫秒值
        long nowTime = new Date().getTime();
        //5.使用当前日期的毫秒值-出生日期的毫秒值
        long time = nowTime-birthdayDateTime;
        //6.把毫秒的差值转换为天数(s/1000/60/60/24)
        System.out.println(time/1000/60/60/24);
    }

</pre><h2><a name='header-n1821' class='md-header-anchor '></a>71. Calendar类</h2><ul><li>Calendar类介绍：</li><li>java.util.Calendar类 日历类 </li><li>Calendar类是一个抽象类 里面提供了很多操作日历字段的方法 </li><li>Calendar类无法直接创建对象使用 里面有一个静态方法getInstance() 该方法返回了Calendar类的子类对象</li><li>static Calendar getInstance() 使用默认时区和语言环境获得一个日历</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n1833" mdtype="fences">    public static void main(String[] args) {
        Calendar calendar = Calendar.getInstance();//多态
        System.out.println(calendar);
        System.out.println(calendar.getClass());
        //class java.util.GregorianCalendar
    }

</pre><ul><li><p>Calendar类常用成员方法：</p></li><li><p>public int get(int field) 返回给定日历字段的值</p></li><li><p>参数int field 是日历类字段 可以使用Calendar类的静态成员变量获取</p><ul><li>YEAR MONTH DATE HOUR MINUTE SECOND</li></ul></li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n1844" mdtype="fences">    private static void test(){
        //使用getInstance方法获取Calendar对象
        Calendar calendar = Calendar.getInstance();
        int year = calendar.get(Calendar.YEAR);
        System.out.println(year);
        int month = calendar.get(Calendar.MONTH);
        System.out.println(month);
        int date = calendar.get(Calendar.DATE);
        System.out.println(date);
    }

</pre><ul><li><p>public void set(int field,int value) 将给定日历字段设置为给定值</p><ul><li>int field 传递指定日历字段</li><li>int value 给指定字段设置的值</li></ul></li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n1853" mdtype="fences">	public static void test(){
        //使用getInstance方法获取Calendar对象
        Calendar calendar = Calendar.getInstance();
        //设置年为9999
        calendar.set(Calendar.YEAR,9999);
        //设置月为9999
        calendar.set(Calendar.MONTH,9999);
        //设置日为9999
        calendar.set(Calendar.DATE,9999);
        //同时设置年月日 set的重载方法
        calendar.set(9999,9999,9999,9999,9999,99999);
    }

</pre><ul><li><p>public abstract void add(int field,int anount) </p></li><li><p>根据日期规则 为给定日期把指定字段增加/减少指定的值</p><ul><li>int field 传递指定日历字段</li><li>int anount 增加/减少指定的值</li></ul></li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n1864" mdtype="fences">    public static void test(){
        //使用getInstance方法获取Calendar对象
        Calendar calendar = Calendar.getInstance();
        //年增加2
        calendar.add(Calendar.YEAR,2);
        //月减少3
        calendar.add(Calendar.MONTH,-3);
    }

</pre><ul><li>public Date getTime()</li><li>返回一个表示此Calendar时间值 Date对象</li><li>把日历对象转换为日期对象</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n1872" mdtype="fences">	public static void test(){
		//使用getInstance方法获取Calendar对象
		Calendar calendar = Calendar.getInstance();
		Date date = calendar.getTime();
		System.out.println(date);
	}

</pre><ul><li>setTime():</li><li>Date ---&gt; 日历类：</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n1878" mdtype="fences">	Calendar calendar = Calendar.getInstance();
    Date date = new Date();
    calendar.setTime(date);
    days = calendar.get(Calendar.DAY_OF_MONTH);
    System.out.println(days);

</pre><h2><a name='header-n1879' class='md-header-anchor '></a>72. System类</h2><p><strong>System类的常用方法：</strong></p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n1881" mdtype="fences">	-  public static long currentTimeMillis(); 返回以毫秒为单位的当前时间
	-  用来测试程序的执行效率

</pre><ul><li>验证 for循环打印数字1-9999所需要的的时间(毫秒)</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n1885" mdtype="fences">    public static void demo04(){
        //程序执行前获取一次毫秒值
        long start = System.currentTimeMillis();
        //执行for循环
        for (int i = 0; i &lt; 9999; i++) {
            System.out.print(i+" ");
        }
        System.out.println();
        //程序执行完毕后获取一次毫秒值
        long end = System.currentTimeMillis();
        System.out.println("程序共耗时"+(end-start)+"毫秒");
    }

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n1886" mdtype="fences">public static void arraycopy(Object src,int srcPos,Object dest, int destPos,int length) 
作用：
	将数组中指定的数据拷贝到另一个数组中去
参数：
	src 源数组 
	srcPos 源数组起始位置  
	dest 目标数组  
	destPos 目标数组起始位置 
	length  要复制的数组元素的数量

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n1887" mdtype="fences" style="break-inside: unset;">// 练习：
		//将src数组前三个元素复制到dest数组前三个位置上
		//复制前： src[1,2,3,4,5]  dest[6,7,8,9,10]
		//复制后： src[1,2,3,4,5]  dest[1,2,3,9,10]
		
    public static void test(){
        //定义源数组
        int[] src = {1,2,3,4,5};
        //定义目标数组
        int[] dest = {6,7,8,9,10};
        System.out.println("复制前："+Arrays.toString(dest));
        //使用System可中的arraycopy方法把源数组前三个元素复制到目标数组的前三个位置上
        System.arraycopy(src,0,dest,0,3);
        System.out.println("复制后："+Arrays.toString(dest));
    }

</pre><h2><a name='header-n1888' class='md-header-anchor '></a>73. String类</h2><ul><li><p>String:字符串，使用一对&quot;&quot;引起来表示。</p><ol start='' ><li><p>String声明为final的，不可被继承</p></li><li><p>String实现了Serializable接口：表示字符串是支持序列化的。
  <span>	</span> 实现了Comparable接口：表示String可以比较大小</p></li><li><p>String内部定义了final char[] value用于存储字符串数据</p></li><li><p>String:代表不可变的字符序列。简称：不可变性。
体现：</p><ol start='' ><li><p>当对字符串重新赋值时，需要重写指定内存区域赋值，不能使用原有的value进行赋值。</p><ol start='2' ><li>当对现有的字符串进行连接操作时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。</li><li>当调用String的replace()方法修改指定字符或字符串时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。</li></ol></li></ol></li><li><p>通过字面量的方式（区别于new）给一个字符串赋值，此时的字符串值声明在字符串常量池中。</p></li><li><p>字符串常量池中是不会存储相同内容的字符串的。</p></li></ol></li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n1913" mdtype="fences">    String s1 = "string1";
    String s2 = "string1";
    System.out.println(s1==s2);//true
    String s3 = s1.replace('1',' ');
    System.out.println(s3);//string 

</pre><ul><li>String的实例化方式：</li><li>方式一：通过字面量定义的方式</li><li>方式二：通过new + 构造器的方式</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n1921" mdtype="fences">面试题：String s = new String("abc");方式创建对象，在内存中创建了几个对象？
       两个:一个是堆空间中new结构，另一个是char[]对应的常量池中的数据："abc"

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n1922" mdtype="fences">class Person{
        String name;
        int age;

        public Person(String name, int age) {
                this.name = name;
                this.age = age;
        }
}

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n1923" mdtype="fences">    Person p1 = new Person("Tom", 12);
    Person p2 = new Person("Tom", 12);
    System.out.println(p1.name.equals(p2.name));//true
    System.out.println(p1.name == p2.name);//true 指向同一地址
    p1.name = "Jerry";
    System.out.println(p2.name);//Tom

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n1924" mdtype="fences">结论：
1. 常量与常量的拼接结果在常量池。且常量池中不会存在相同内容的常量。
2. 只要其中有一个是变量，结果就在堆中。
3. 如果拼接的结果调用intern()方法，返回值就在常量池中

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n1925" mdtype="fences" style="break-inside: unset;">        String s1 = "javaEE";
        String s2 = "hadoop";

        String s3 = "javaEEhadoop";
        String s4 = "javaEE" + "hadoop";
        String s5 = s1 + "hadoop";
        String s6 = "javaEE" + s2;
        String s7 = s1 + s2;

        System.out.println(s3 == s4);//true  字面量和字面量拼接
        System.out.println(s3 == s5);//false s5在堆空间中开辟
        System.out.println(s3 == s6);//false s6在堆空间中开辟
        System.out.println(s3 == s7);//false s7在堆空间中开辟
        System.out.println(s5 == s6);//false 
        System.out.println(s5 == s7);//false
        System.out.println(s6 == s7);//false
        String s8 = s6.intern();//返回值得到的s8使用的常量值中已经存在的“javaEEhadoop”
        System.out.println(s3 == s8);//true

</pre><ul><li>String中的常用方法：</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n1929" mdtype="fences">int length()：返回字符串的长度： return value.length
char charAt(int index)： 返回某索引处的字符return value[index]
boolean isEmpty()：判断是否是空字符串：return value.length == 0
String toLowerCase()：使用默认语言环境，将 String 中的所有字符转换为小写
String toUpperCase()：使用默认语言环境，将 String 中的所有字符转换为大写
String trim()：返回字符串的副本，忽略前导空白和尾部空白
boolean equals(Object obj)：比较字符串的内容是否相同
boolean equalsIgnoreCase(String anotherString)：与equals方法类似，忽略大小写
String concat(String str)：将指定字符串连接到此字符串的结尾。 等价于用“+”
int compareTo(String anotherString)：比较两个字符串的大小
String substring(int beginIndex)：返回一个新的字符串，它是此字符串的从beginIndex开始截取到最后的一个子字符串。
String substring(int beginIndex, int endIndex) ：返回一个新字符串，它是此字符串从beginIndex开始截取到endIndex(不包含)的一个子字符串。

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n1930" mdtype="fences">boolean endsWith(String suffix)：测试此字符串是否以指定的后缀结束
boolean startsWith(String prefix)：测试此字符串是否以指定的前缀开始
boolean startsWith(String prefix, int toffset)：测试此字符串从指定索引开始的子字符串是否以指定前缀开始

boolean contains(CharSequence s)：当且仅当此字符串包含指定的 char 值序列时，返回 true
int indexOf(String str)：返回指定子字符串在此字符串中第一次出现处的索引
int indexOf(String str, int fromIndex)：返回指定子字符串在此字符串中第一次出现处的索引，从指定的索引开始
int lastIndexOf(String str)：返回指定子字符串在此字符串中最右边出现处的索引
int lastIndexOf(String str, int fromIndex)：返回指定子字符串在此字符串中最后一次出现处的索引，从指定的索引开始反向搜索

注：indexOf和lastIndexOf方法如果未找到都是返回-1

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n1931" mdtype="fences">替换：
	String replace(char oldChar, char newChar)：返回一个新的字符串，它是通过用 newChar 替换此字符串中出现的所有 oldChar 得到的。
	String replace(CharSequence target, CharSequence replacement)：使用指定的字面值替换序列替换此字符串所有匹配字面值目标序列的子字符串。
	String replaceAll(String regex, String replacement)：使用给定的 replacement 替换此字符串所有匹配给定的正则表达式的子字符串。
	String replaceFirst(String regex, String replacement)：使用给定的 replacement 替换此字符串匹配给定的正则表达式的第一个子字符串。
匹配:
	boolean matches(String regex)：告知此字符串是否匹配给定的正则表达式。
切片：
	String[] split(String regex)：根据给定正则表达式的匹配拆分此字符串。
	String[] split(String regex, int limit)：根据匹配给定的正则表达式来拆分此字符串，最多不超过limit个，如果超过了，剩下的全部都放到最后一个元素中。

</pre><ul><li><p>String 与 char[]之间的转换 </p><ul><li>String --&gt; char[]:调用String的toCharArray()</li><li>char[] --&gt; String:调用String的构造器</li></ul></li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n1940" mdtype="fences">    String str1 = "abc123";
    char[] charArray = str1.toCharArray();
    char[] arr = new char[]{'h','e','l','l','o'};
    String str2 = new String(arr);

</pre><ul><li><p>String 与 byte[]之间的转换</p></li><li><p>编码：String --&gt; byte[]:调用String的getBytes()</p><ul><li>解码：byte[] --&gt; String:调用String的构造器</li></ul></li></ul><ol start='' ><li>编码：字符串 --&gt;字节  (看得懂 ---&gt;看不懂的二进制数据)</li><li>解码：编码的逆过程，字节 --&gt; 字符串 （看不懂的二进制数据 ---&gt; 看得懂）</li></ol><ul><li>说明：解码时，要求解码使用的字符集必须与编码时使用的字符集一致，否则会出现乱码。</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n1957" mdtype="fences">String str1 = "abc123中国";
        byte[] bytes = str1.getBytes();//使用默认的字符集，进行编码。
        System.out.println(Arrays.toString(bytes));
        byte[] gbks = str1.getBytes("gbk");//使用gbk字符集进行编码。
        System.out.println(Arrays.toString(gbks));
        System.out.println("******************");
        String str2 = new String(bytes);//使用默认的字符集，进行解码。
        System.out.println(str2);
        String str3 = new String(gbks);
        System.out.println(str3);//出现乱码。原因：编码集和解码集不一致！
        String str4 = new String(gbks, "gbk");
        System.out.println(str4);//没有出现乱码。原因：编码集和解码集一致！

</pre><h2><a name='header-n1958' class='md-header-anchor '></a>74. StringBuilder类</h2><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n1959" mdtype="fences">StringBuilder:
	构造方法：
		java.lang.StringBuilder类 字符串缓冲区 
		StringBuilder() 构造一个不带任何字符的字符串生成器 初始容量为16字符
		StringBuilder(String str) 构造一个字符串生成器 并初始化为指定的字符串内容
	常用方法：
		public StringBuilder append(...) 添加任意类型的数据的字符串形式 返回本身
		public String toString() 将当前StringBuilder对象转换为String对象

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n1960" mdtype="fences" style="break-inside: unset;">	 public static void main(String[] args) {
        //空参数构造方法
        StringBuilder str1 = new StringBuilder();
        System.out.println("str1:" + str1);//str1:
        //带字符串的构造方法
        StringBuilder str2 = new StringBuilder("abc");
        System.out.println("str2:" + str2);//str2:abc

        //创建StringBuilder对象
        StringBuilder builder = new StringBuilder();
        //使用append方法向StringBuilder中添加数据
        builder.append("abc");
        builder.append(1);
        builder.append(true);
        builder.append(80.0);
        System.out.println(builder);
        //链式编程：方法返回值是一个对象 可以继续调用方法
        builder.append("123").append("AXC").append(98512).append(false);
        System.out.println(builder);
    }

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n1961" mdtype="fences">StringBuilder和String相互转换：

	Stirng--&gt;StringBuilder  可以使用StringBuilder的构造方法
		StringBuilder(String str) 构造一个字符串生成器 并初始化为指定的字符串内容
	StringBuilder--&gt;String  可以使用StringBuilder中的toString方法
		public String toString()  将当前StringBuilder对象转换为String对象

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n1962" mdtype="fences">    public static void main(String[] args) {
        //String--&gt;StringBuilder
        String str1 = "Hello";
        System.out.println(str1);
        StringBuilder builder = new StringBuilder(str1);
        //向StringBuilder中添加数据
        builder.append(" world");
        System.out.println(builder);
        //StringBuilder--&gt;String
        String str2 = builder.toString();
        System.out.println(str2);
    }

</pre><h2><a name='header-n1963' class='md-header-anchor '></a>75. StringBuffer类</h2><ul><li>String、StringBuffer、StringBuilder三者的异同？</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n1967" mdtype="fences">   String:不可变的字符序列；底层使用char[]存储
   StringBuffer:可变的字符序列；线程安全的，效率低；底层使用char[]存储
   StringBuilder:可变的字符序列；jdk5.0新增的，线程不安全的，效率高；底层使用char[]存储

</pre><p>&nbsp;</p><ul><li>源码分析：</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n1972" mdtype="fences" style="break-inside: unset;">   String str = new String();//char[] value = new char[0];
   String str1 = new String("abc");//char[] value = new char[]{'a','b','c'};

   StringBuffer sb1 = new StringBuffer();//char[] value = new char[16];底层创建了一个长度是16的数组。
   System.out.println(sb1.length());//
   sb1.append('a');//value[0] = 'a';
   sb1.append('b');//value[1] = 'b';

   StringBuffer sb2 = new StringBuffer("abc");//char[] value = new char["abc".length() + 16];

   问题1. System.out.println(sb2.length());//3
   问题2. 扩容问题:如果要添加的数据底层数组盛不下了，那就需要扩容底层的数组。
   默认情况下，扩容为原来容量的2倍 + 2，同时将原有数组中的元素复制到新的数组中。

</pre><p> <code>指导意义：开发中建议大家使用：StringBuffer(int capacity) 或 StringBuilder(int capacity)</code></p><ul><li>StringBuffer的常用方法：</li></ul><p> </p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n1978" mdtype="fences">StringBuffer append(xxx)：提供了很多的append()方法，用于进行字符串拼接
StringBuffer delete(int start,int end)：删除指定位置的内容
StringBuffer replace(int start, int end, String str)：把[start,end)位置替换为str
StringBuffer insert(int offset, xxx)：在指定位置插入xxx
StringBuffer reverse() ：把当前字符序列逆转
public int indexOf(String str)
public String substring(int start,int end):返回一个从start开始到end索引结束的左闭右开区间的子字符串
public int length()
public char charAt(int n )
public void setCharAt(int n ,char ch)

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n1979" mdtype="fences">总结：
    增：append(xxx)
    删：delete(int start,int end)
    改：setCharAt(int n ,char ch) / replace(int start, int end, String str)
    查：charAt(int n )
    插：insert(int offset, xxx)
    长度：length();
    遍历：for() + charAt() / toString()

</pre><p><code>效率比较：从高到低排列：StringBuilder &gt; StringBuffer &gt; String</code></p><h2><a name='header-n1981' class='md-header-anchor '></a>76.  Collection集合</h2><ul><li><p>Collection集合概述：</p><ul><li><p>数组长度固定 集合长度可变</p><ul><li>数组中存储同一类元素 集合存储的都是对象 而且对象的类型可以不一致</li></ul></li></ul></li><li><p>java.util.Collection接口</p><ul><li><p>所有单列集合的最顶层接口 里面定义了所有单列集合共性的方法</p><ul><li>任意的单列集合都可以使用collection接口中的方法</li></ul></li></ul></li><li><p>共性方法：</p><ol start='' ><li><p>public boolean add(E e):把给定对象添加到当前集合中</p><ol start='2' ><li>public void clear():清空集合中的所有元素</li><li>public boolean remove(E e):把给定的对象在当前集合中删除</li><li>public boolean contains(E e):判断当前集合中是否包含给定的对象</li><li>public boolean isEmpty():判断当前集合是否为空</li><li>public int size():返回集合中元素的个数</li><li>public Object[] toArray():把集合中的元素 存储到数组中</li></ol></li></ol></li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n2017" mdtype="fences" style="break-inside: unset;">    public static void main(String[] args) {
        //创建集合对象 可以使用多态
        Collection&lt;String&gt; coll = new ArrayList&lt;&gt;();
        System.out.println(coll);//[]  重写了toString方法
        
        //public boolean add(E e) 把给定对象添加到当前集合中 返回boolean值 一般为true 所以可以不用接收
        boolean b1 = coll.add("firstname");
        System.out.println("b1:" + b1);//b1:true
        System.out.println(coll);//[firstname]
        coll.add("secondname");
        coll.add("thirdname");
        coll.add("fourthname");
        System.out.println(coll);//[firstname, secondname,thirdname,fourthname]
        
        //public boolean remove(E e) 把给定的对象在当前集合中删除
        //集合中存在并删除 返回 true  集合中不存在 删除失败返回 false
        boolean b2 = coll.remove("secondname");
        System.out.println("b2:" + b2);//b2:true
        boolean b3 = coll.remove("thisname");
        System.out.println("b3:" + b3);//b3:false
        System.out.println(coll);//[firstname, thirdname, fourthname]
        
        //public boolean contains(E e) 判断当前集合中是否包含给定的对象 包含返回true 不包含返回false
        boolean b4 = coll.contains("firstname");
        System.out.println("b4:" + b4);//b4:true
        boolean b5 = coll.contains("secondname");
        System.out.println("b5:" + b5);//b5:false
        
        //public boolean isEmpty() 判断当前集合是否为空 空返回true 非空返回false
        boolean b6 = coll.isEmpty();
        System.out.println("b6:" + b6);//b6:false
        //public int size() 返回集合中元素个数
        int size = coll.size();
        System.out.println("size:" + size);//size:3
        
        //public Object[] toArray() 把集合中的元素存储到数组
        Object[] arr = coll.toArray();
        for (int i = 0; i &lt; arr.length; i++) {
            System.out.print(arr[i] + " ");
        }
        
        //public void clear() 清空集合中所有元素 但不删除集合
        coll.clear();
        System.out.println(coll);//[]
        System.out.println(coll.isEmpty());//true
    }

</pre><h2><a name='header-n2018' class='md-header-anchor '></a>77. Iterator接口介绍：</h2><ul><li><p>迭代：Collection集合元素通用获取方式 </p><ul><li><p>java.util.Iterator接口：迭代器(对集合进行遍历)</p></li><li><p>两个常用方法：</p><ol start='' ><li>boolean hasNext() 如果仍有元素可以迭代 返回true，判断集合中还有没有下一个元素 有则返回true 没有返回false</li><li>E next() 返回迭代的下一个元素 取出集合中的下一个元素</li></ol></li><li><p>Iterator迭代器，是一个接口，无法直接使用，需要使用Iterator接口的实现类对象</p></li><li><p>这个获取实现类的方式比较特殊：</p><ul><li>Collection接口中有一个方法叫iterator() 这个方法返回的就是迭代器的实现类对象</li><li>Iterator<E> iterator() 返回在此collection的元素上进行迭代的迭代器</li></ul></li></ul></li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n2041" mdtype="fences" style="break-inside: unset;">    public static void main(String[] args) {
        //创建一个集合对象
        Collection&lt;String&gt; coll = new ArrayList&lt;&gt;();
        //向集合中添加元素
        coll.add("myname");
        coll.add("yourname");
        
        //用集合中的方法iterator()获取迭代器的实现类对象 使用Iterator接口接收(多态)
        //注意：Iterator&lt;E&gt;接口也是有泛型的 集合是什么泛型 迭代器就是什么泛型
        Iterator&lt;String&gt; it = coll.iterator();
        
        //使用Iterator接口中的方法hasNext判断还有没有下一个元素
        boolean b = it.hasNext();
        System.out.println(b);//true
        
        //使用Iterator接口中的方法next取出集合中的下一个元素
        String str = it.next();
        System.out.println(str);//myname
        
        //迭代器取出集合元素代码重复 可使用while循环优化 循环结束条件即hasNext方法返回false
        
        //while循环
        while(it.hasNext()){
            String s = it.next();
            System.out.println(s);
        }
        
        //for循环 
        for (Iterator&lt;String&gt; iterator = coll.iterator();iterator.hasNext();){
            String r = iterator.next();
            System.out.println(r);
        }
        
    }

</pre><h2><a name='header-n2042' class='md-header-anchor '></a>78. 增强for循环</h2><ul><li>增强for循环：只能用于遍历集合或数组</li><li>增强for循环也是迭代器 简化了迭代器的书写</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n2048" mdtype="fences">格式：
	for(集合/数组的数据类型 变量名：集合名/数组名){
		System.out.print(变量名);
	}

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n2049" mdtype="fences" style="break-inside: unset;">    //使用增强for循环遍历集合
    public static void test(){
        ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();
        list.add("first");
        list.add("second");
        list.add("third");
        list.add("fourth");
        list.add("fifth");
        for(String s : list){
            System.out.println(s);
        }
    }
    
    //使用增强for循环遍历数组
    public static void test(){
        int[] arr = {1,2,3,4,5};
        for(int i : arr){
            System.out.println(i);
        }
    }

</pre><h2><a name='header-n2050' class='md-header-anchor '></a>79. LocalDate LocalTime LocalDateTime类</h2><ul><li>常用方法：</li></ul><ol start='' ><li>now()</li><li>of()</li><li>getXxx()</li><li>withXxx()</li></ol><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n2063" mdtype="fences" style="break-inside: unset;">    //now():获取当前的日期、时间、日期+时间
    LocalDate localDate = LocalDate.now();
    LocalTime localTime = LocalTime.now();
    LocalDateTime localDateTime = LocalDateTime.now();

    System.out.println(localDate);
    System.out.println(localTime);
    System.out.println(localDateTime);

    //of():设置指定的年、月、日、时、分、秒。没有偏移量
    LocalDateTime localDateTime1 = LocalDateTime.of(2020, 10, 6, 13, 23, 43);
    System.out.println(localDateTime1);

    //getXxx()：获取相关的属性
    System.out.println(localDateTime.getDayOfMonth());
    System.out.println(localDateTime.getDayOfWeek());
    System.out.println(localDateTime.getMonth());
    System.out.println(localDateTime.getMonthValue());
    System.out.println(localDateTime.getMinute());

    //体现不可变性
    //withXxx():设置相关的属性
    LocalDate localDate1 = localDate.withDayOfMonth(22);
    System.out.println(localDate);
    System.out.println(localDate1);

    LocalDateTime localDateTime2 = localDateTime.withHour(4);
    System.out.println(localDateTime);
    System.out.println(localDateTime2);

    LocalDateTime localDateTime3 = localDateTime.plusMonths(3);
    System.out.println(localDateTime);
    System.out.println(localDateTime3);

    LocalDateTime localDateTime4 = localDateTime.minusDays(6);
    System.out.println(localDateTime);
    System.out.println(localDateTime4);

</pre><h2><a name='header-n2064' class='md-header-anchor '></a>80. Instant类</h2><ul><li>常用方法：</li></ul><ol start='' ><li>now()</li><li>atOffset(时区偏移量)</li><li>toEpochMilli()</li><li>ofEpochMilli()</li></ol><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n2077" mdtype="fences" style="break-inside: unset;">	//now():获取本初子午线对应的标准时间
    Instant instant = Instant.now();
    System.out.println(instant);//2019-02-18T07:29:41.719Z

    //添加时间的偏移量
    OffsetDateTime offsetDateTime = instant.atOffset(ZoneOffset.ofHours(8));
    System.out.println(offsetDateTime);//2019-02-18T15:32:50.611+08:00

    //toEpochMilli():获取自1970年1月1日0时0分0秒（UTC）开始的毫秒数  ---&gt; Date类的getTime()
    long milli = instant.toEpochMilli();
    System.out.println(milli);

    //ofEpochMilli():通过给定的毫秒数，获取Instant实例  --&gt;Date(long millis)
    Instant instant1 = Instant.ofEpochMilli(1550475314878L);
    System.out.println(instant1);

</pre><h2><a name='header-n2078' class='md-header-anchor '></a>81. DateTimeFormatter类</h2><ul><li>DateTimeFormatter:格式化或解析日期、时间</li><li>方式一：预定义的标准格式。如：ISO_LOCAL_DATE_TIME;ISO_LOCAL_DATE;ISO_LOCAL_TIME</li><li>方式二：      本地化相关的格式。</li><li>方式三：自定义的格式。如：ofPattern(“yyyy-MM-dd hh:mm:ss”)</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n2088" mdtype="fences">	DateTimeFormatter formatter = DateTimeFormatter.ISO_LOCAL_DATE_TIME;
    //格式化:日期--&gt;字符串
    LocalDateTime localDateTime = LocalDateTime.now();
    String str1 = formatter.format(localDateTime);
    System.out.println(localDateTime);
    System.out.println(str1);//2019-02-18T15:42:18.797
    
    //解析：字符串 --&gt;日期
    TemporalAccessor parse = formatter.parse("2019-02-18T15:42:18.797");
    System.out.println(parse);

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n2089" mdtype="fences" style="break-inside: unset;">	//本地化相关的格式。如：ofLocalizedDateTime()
    FormatStyle.LONG / FormatStyle.MEDIUM / FormatStyle.SHORT :适用于LocalDateTime
    DateTimeFormatter formatter1 = DateTimeFormatter.ofLocalizedDateTime(FormatStyle.LONG);
    //格式化
    String str2 = formatter1.format(localDateTime);
    System.out.println(str2);//2019年2月18日 下午03时47分16秒


	//本地化相关的格式。如：ofLocalizedDate()
	FormatStyle.FULL / FormatStyle.LONG / FormatStyle.MEDIUM / FormatStyle.SHORT : 适用于LocalDate
    DateTimeFormatter formatter2 = DateTimeFormatter.ofLocalizedDate(FormatStyle.MEDIUM);
    //格式化
    String str3 = formatter2.format(LocalDate.now());
    System.out.println(str3);//2019-2-18

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n2090" mdtype="fences">	//自定义的格式。如：ofPattern(“yyyy-MM-dd hh:mm:ss”)
    DateTimeFormatter formatter3 = DateTimeFormatter.ofPattern("yyyy-MM-dd hh:mm:ss");
    //格式化
    String str4 = formatter3.format(LocalDateTime.now());
    System.out.println(str4);//2019-02-18 03:52:09

    //解析
    TemporalAccessor accessor = formatter3.parse("2019-02-18 03:52:09");
    System.out.println(accessor);

</pre><h2><a name='header-n2091' class='md-header-anchor '></a>82. Java比较器</h2><ul><li><p>使用两个接口中的任何一个：Comparable 或 Comparator来比较对象的大小</p></li><li><p>Comparable接口的使用举例：  自然排序</p><ol start='' ><li><p>像String、包装类等实现了Comparable接口，重写了compareTo(obj)方法，给出了比较两个对象大小的方式。</p></li><li><p>像String、包装类重写compareTo()方法以后，进行了从小到大的排列</p></li><li><p>重写compareTo(obj)的规则：</p><ul><li>如果当前对象this大于形参对象obj，则返回正整数，</li><li>如果当前对象this小于形参对象obj，则返回负整数，</li><li>如果当前对象this等于形参对象obj，则返回零。</li></ul></li><li><p>对于自定义类来说，如果需要排序，我们可以让自定义类实现Comparable接口，重写compareTo(obj)方法。
在compareTo(obj)方法中指明如何排序</p></li></ol></li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n2113" mdtype="fences">	 String[] arr = new String[]{"AA","CC","KK","MM","GG","JJ","DD"};
     Arrays.sort(arr);//默认从小到大排序
     System.out.println(Arrays.toString(arr)); // [AA, CC, DD, GG, JJ, KK, MM]

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n2114" mdtype="fences" style="break-inside: unset;">class Goods implements  Comparable{

        private String name;
        private double price;

        public Goods() {
        }

        public Goods(String name, double price) {
                this.name = name;
                this.price = price;
        }

        public String getName() {
                return name;
        }

        public void setName(String name) {
                this.name = name;
        }

        public double getPrice() {
                return price;
        }

        public void setPrice(double price) {
                this.price = price;
        }

        @Override
        public String toString() {
                return "Goods{" +
                        "name='" + name + '\'' +
                        ", price=" + price +
                        '}';
        }

        //指明商品比较大小的方式:按照价格从低到高排序,再按照产品名称从高到低排序
        @Override
        public int compareTo(Object o) {
                if(o instanceof Goods){
                        Goods goods = (Goods)o;
                        //方式一：
                        if(this.price &gt; goods.price){
                                return 1;
                        }else if(this.price &lt; goods.price){
                                return -1;
                        }else{
                                return -this.name.compareTo(goods.name);//字符串直接调用compareTo方法
                        }
                        //方式二：return Double.compare(this.price,goods.price);
                }
                throw new RuntimeException("传入的数据类型不一致！");//类型不一致抛出异常
        }
}

    Goods[] goods = new Goods[6];
    goods[0] = new Goods("AA",3);
    goods[1] = new Goods("CC",4);
    goods[2] = new Goods("AA",1);
    goods[3] = new Goods("FF",6);
    goods[4] = new Goods("DD",2);
    goods[5] = new Goods("BB",4);
    Arrays.sort(goods);
    System.out.println(Arrays.toString(goods));

</pre><ul><li>Comparator接口的使用：定制排序</li></ul><ol start='' ><li><p>当元素的类型没有实现java.lang.Comparable接口而又不方便修改代码，或者实现了java.lang.Comparable接口的排序规则不适合当前的操作，那么可以考虑使用 Comparator 的对象来排序</p></li><li><p>重写compare(Object o1,Object o2)方法，比较o1和o2的大小：</p><ul><li>如果方法返回正整数，则表示o1大于o2；</li><li>如果返回0，表示相等；</li><li>返回负整数，表示o1小于o2。</li></ul></li></ol><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n2130" mdtype="fences" style="break-inside: unset;">    String[] arr = new String[]{"AA","CC","KK","MM","GG","JJ","DD"};
    Arrays.sort(arr,new Comparator(){
            //按照字符串从大到小的顺序排列
            @Override
            public int compare(Object o1, Object o2) {
                    if(o1 instanceof String &amp;&amp; o2 instanceof  String){
                            String s1 = (String) o1;
                            String s2 = (String) o2;
                            return -s1.compareTo(s2);
                    }
                    throw new RuntimeException("输入的数据类型不一致");
            }
    });
    System.out.println(Arrays.toString(arr)); // [MM, KK, JJ, GG, DD, CC, AA]

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n2131" mdtype="fences" style="break-inside: unset;">    Goods[] goods = new Goods[6];
    goods[0] = new Goods("AA",3);
    goods[1] = new Goods("CC",4);
    goods[2] = new Goods("AA",1);
    goods[3] = new Goods("FF",6);
    goods[4] = new Goods("DD",2);
    goods[5] = new Goods("BB",4);
    Arrays.sort(goods, new Comparator() {
            //指明商品比较大小的方式:按照产品名称从低到高排序,再按照价格从高到低排序
            @Override
            public int compare(Object o1, Object o2) {
                    if(o1 instanceof Goods &amp;&amp; o2 instanceof Goods){
                            Goods g1 = (Goods)o1;
                            Goods g2 = (Goods)o2;
                            if(g1.getName().equals(g2.getName())){
                                    return -Double.compare(g1.getPrice(),g2.getPrice());
                            }else{
                                    return g1.getName().compareTo(g2.getName());
                            }
                    }
                    throw new RuntimeException("输入的数据类型不一致");
            }
    });
    
    //测试
    for (int i = 0; i &lt; goods.length; i++) {
            System.out.println(goods[i].toString());
    }
    
    /**
    *	Goods{name='AA', price=3.0}
	*	Goods{name='AA', price=1.0}
	*	Goods{name='BB', price=4.0}
	*	Goods{name='CC', price=4.0}
	*	Goods{name='DD', price=2.0}
	*	Goods{name='FF', price=6.0}
	*/

</pre><h2><a name='header-n2132' class='md-header-anchor '></a>83. System类成员方法</h2><ol start='' ><li>native long currentTimeMillis()：
该方法的作用是返回当前的计算机时间，时间的表达格式为当前计算机时间和GMT时间(格林威治时间)1970年1月1号0时0分0秒所差的毫秒数。</li><li>void exit(int status)：
该方法的作用是退出程序。其中status的值为0代表正常退出，非零代表异常退出。使用该方法可以在图形界面编程中实现程序的退出功能等。</li><li>void gc()：
该方法的作用是请求系统进行垃圾回收。至于系统是否立刻回收，则取决于系统中垃圾回收算法的实现以及系统执行时的情况。</li><li>String getProperty(String key)：
该方法的作用是获得系统中属性名为key的属性对应的值。</li></ol><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n2142" mdtype="fences">    System.out.println(System.getProperty("java.version"));
    System.out.println(System.getProperty("java.home"));
    System.out.println(System.getProperty("os.name"));
    System.out.println(System.getProperty("os.version"));
    System.out.println(System.getProperty("user.name"));
    System.out.println(System.getProperty("user.home"));
    System.out.println(System.getProperty("user.dir"));

</pre><h2><a name='header-n2143' class='md-header-anchor '></a>84. Math类</h2><ul><li>java.lang.Math提供了一系列静态方法用于科学计算。其方法的参数和返回值类型一般为double型。</li></ul><ol start='' ><li>abs 绝对值</li><li>acos,asin,atan,cos,sin,tan 三角函数</li><li>sqrt 平方根</li><li>pow(double a,doble b) a的b次幂</li><li>log 自然对数</li><li>exp e为底指数</li><li>max(double a,double b)</li><li>min(double a,double b)</li><li>random() 返回0.0到1.0的随机数</li><li>long round(double a) double型数据a转换为long型（四舍五入）</li><li>toDegrees(double angrad) 弧度—&gt;角度</li><li>toRadians(double angdeg) 角度—&gt;弧度</li></ol><h2><a name='header-n2172' class='md-header-anchor '></a>85. BigInteger和BigDecimal类</h2><ul><li>BigInteger类</li><li>常用方法</li></ul><ol start='' ><li>public BigInteger abs()：返回此 BigInteger 的绝对值的 BigInteger。</li><li>BigInteger add(BigInteger val) ：返回其值为 (this + val) 的 BigInteger</li><li>BigInteger subtract(BigInteger val) ：返回其值为 (this - val) 的 BigInteger</li><li>BigInteger multiply(BigInteger val) ：返回其值为 (this * val) 的 BigInteger</li><li>BigInteger divide(BigInteger val) ：返回其值为 (this / val) 的 BigInteger。整数相除只保留整数部分。</li><li>BigInteger remainder(BigInteger val) ：返回其值为 (this % val) 的 BigInteger。</li><li>BigInteger[] divideAndRemainder(BigInteger val)：返回包含 (this / val) 后跟(this % val) 的两个 BigInteger 的数组。</li><li>BigInteger pow(int exponent) ：返回其值为 (thisexponent) 的 BigInteger。</li></ol><ul><li><p>BigDecimal类</p></li><li><p>BigDecimal类支持不可变的、任意精度的有符号十进制定点数。</p></li><li><p>构造器：</p><ul><li>public BigDecimal(double val)</li><li>public BigDecimal(String val)</li></ul></li><li><p>常用方法：</p><ul><li>public BigDecimal add(BigDecimal augend)</li><li>public BigDecimal subtract(BigDecimal subtrahend)</li><li>public BigDecimal multiply(BigDecimal multiplicand)</li><li>public BigDecimal divide(BigDecimal divisor, int scale, int roundingMode)</li></ul></li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n2218" mdtype="fences">	BigInteger bi = new BigInteger("1243324112234324324325235245346567657653");
    BigDecimal bd = new BigDecimal("12435.351");
    BigDecimal bd2 = new BigDecimal("11");
    System.out.println(bi);
    System.out.println(bd.divide(bd2, BigDecimal.ROUND_HALF_UP));
    System.out.println(bd.divide(bd2, 25, BigDecimal.ROUND_HALF_UP));

</pre><h2><a name='header-n2219' class='md-header-anchor '></a>86. 枚举类</h2><ul><li>自定义枚举类</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n2223" mdtype="fences" style="break-inside: unset;">class Season{
        //1.声明Season对象的属性:private final修饰
        private final String seasonName;
        private final String seasonDesc;

        //2.私有化类的构造器,并给对象属性赋值
        Season(String seasonName, String seasonDesc){
                this.seasonName = seasonName;
                this.seasonDesc = seasonDesc;
        }

        //3.提供当前枚举类的多个对象：public static final的
        public static final Season SPRING = new Season("春天","春暖花开");
        public static final Season SUMMER = new Season("夏天","夏日炎炎");
        public static final Season AUTUMN = new Season("秋天","秋高气爽");
        public static final Season WINTER = new Season("冬天","冰天雪地");

        //4.其他诉求：获取枚举类对象的属性
        public String getSeasonName() {
                return seasonName;
        }

        public String getSeasonDesc() {
                return seasonDesc;
        }
        //4.其他诉求：提供toString()
        @Override
        public String toString() {
                return "Season{" +
                        "seasonName='" + seasonName + '\'' +
                        ", seasonDesc='" + seasonDesc + '\'' +
                        '}';
        }
}

	//测试
	System.out.println(Season.SPRING.getSeasonName()); // 春天
    System.out.println(Season.SPRING.getSeasonDesc()); // 春暖花开
    System.out.println(Season.SPRING); // Season{seasonName='春天', seasonDesc='春暖花开'}

</pre><ul><li>enum关键字定义枚举类</li><li>定义的枚举类默认继承于java.lang.Enum类</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n2229" mdtype="fences" style="break-inside: unset;">enum Season{

        //1.提供当前枚举类的对象
        SPRING("春天","春暖花开"),
        SUMMER("夏天","夏日炎炎"),
        AUTUMN("秋天","秋高气爽"),
        WINTER("冬天","冰天雪地");

        //2.声明Season对象的属性:private final修饰
        private final String seasonName;
        private final String seasonDesc;

        //3.私有化类的构造器,并给对象属性赋值
        Season(String seasonName, String seasonDesc){
                this.seasonName = seasonName;
                this.seasonDesc = seasonDesc;
        }

        //4.其他诉求：获取枚举类对象的属性
        public String getSeasonName() {
                return seasonName;
        }

        public String getSeasonDesc() {
                return seasonDesc;
        }
}

	//测试
    Season autumn = Season.AUTUMN;
    System.out.println(autumn); // AUTUMN
    System.out.println(autumn.getSeasonName()); // 秋天
    System.out.println(autumn.getSeasonDesc()); // 秋高气爽
    System.out.println(Season.class.getSuperclass()); // class java.lang.Enum

</pre><ul><li>Enum类中的常用方法：</li></ul><ol start='' ><li>toString():返回枚举类对象的名称</li><li>values():返回所有的枚举类对象构成的数组</li><li>valueOf(String objName):返回枚举类中对象名是objName的对象。如果没有objName的枚举类对象，则抛异常：IllegalArgumentException</li></ol><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n2240" mdtype="fences">    Season[] values = Season.values();
    for (Season season :values) {
            System.out.println(season);
    }
    Season winter = Season.valueOf("WINTER");
    System.out.println(winter);

</pre><ul><li>枚举类实现接口</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n2244" mdtype="fences" style="break-inside: unset;">interface Info{
        public abstract void showSeason();
}

//使用enum关键字枚举类
enum Season implements Info{
        //1.提供当前枚举类的对象，多个对象之间用","隔开，末尾对象";"结束
        SPRING("春天","春暖花开"){
                @Override
                public void showSeason() {
                        System.out.println("这是春天");
                }
        },
        SUMMER("夏天","夏日炎炎"){
                @Override
                public void showSeason() {
                        System.out.println("这是夏天");
                }
        },
        AUTUMN("秋天","秋高气爽"){
                @Override
                public void showSeason() {
                        System.out.println("这是秋天");
                }
        },
        WINTER("冬天","冰天雪地"){
                @Override
                public void showSeason() {
                        System.out.println("这是冬天");
                }
        };

        private final String seasonName;
        private final String seasonDesc;

        private Season(String seasonName,String seasonDesc){
                this.seasonName = seasonName;
                this.seasonDesc = seasonDesc;
        }

        public String getSeasonName() {
                return seasonName;
        }

        public String getSeasonDesc() {
                return seasonDesc;
        }
}

	//测试
    for (Season season:Season.values()) {
            System.out.println(season);
            season.showSeason();
    }

</pre><h2><a name='header-n2245' class='md-header-anchor '></a>87. Annotation注解</h2><ul><li>略....</li></ul><h2><a name='header-n2249' class='md-header-anchor '></a>88. Collection集合</h2><ul><li>集合框架：</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n2253" mdtype="fences"> *      |----Collection接口：单列集合，用来存储一个一个的对象
 *          |----List接口：存储有序的、可重复的数据。  --&gt;“动态”数组
 *              |----ArrayList、LinkedList、Vector
 *
 *          |----Set接口：存储无序的、不可重复的数据   --&gt;高中讲的“集合”
 *              |----HashSet、LinkedHashSet、TreeSet
 *
 *      |----Map接口：双列集合，用来存储一对(key - value)一对的数据   --&gt;高中函数：y = f(x)
 *              |----HashMap、LinkedHashMap、TreeMap、Hashtable、Properties

</pre><h2><a name='header-n2254' class='md-header-anchor '></a>89. Collection接口中的方法</h2><ul><li>add(Object e):将元素e添加到集合coll中</li><li>size():获取添加的元素的个数</li><li>addAll(Collection coll):将coll集合中的元素添加到当前的集合中</li><li>isEmpty():判断当前集合是否为空</li><li>clear():清空集合元素</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n2266" mdtype="fences" style="break-inside: unset;">    Collection c = new ArrayList();
    c.add("AA");
    c.add("BB");
    c.add(123);
    c.add(new Date());
    System.out.println(c.size()); // 4
    Collection coll = new ArrayList();
    coll.add(456);
    coll.add("CC");
    c.addAll(coll);
    System.out.println(c); // [AA, BB, 123, Mon Jun 06 23:54:05 CST 2022, 456, CC]
    coll.clear();
    System.out.println(coll.isEmpty()); // true

</pre><ul><li>contains(Object obj):判断当前集合中是否包含obj，判断时会调用obj对象所在类的equals()。</li><li>containsAll(Collection coll):判断形参coll中的所有元素是否都存在于当前集合中</li><li>remove(Object obj):从当前集合中移除obj元素</li><li>removeAll(Collection coll):差集：从当前集合中移除coll中所有的元素</li><li>retainAll(Collection coll):交集：获取当前集合和coll集合的交集，并返回给当前集合</li><li>equals(Object obj):要想返回true，需要当前集合和形参集合的元素都相同[含顺序]</li><li>hashCode():返回当前对象的哈希值</li><li>toArray():集合转为数组 [数组转为集合:调用Arrays类的静态方法asList()]</li><li>iterator():返回Iterator接口的实例，用于遍历集合元素</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n2286" mdtype="fences" style="break-inside: unset;">class Person {

        private String name;
        private int age;

        public Person() {
        }

        public Person(String name, int age) {
                this.name = name;
                this.age = age;
        }

        public String getName() {
                return name;
        }

        public void setName(String name) {
                this.name = name;
        }

        public int getAge() {
                return age;
        }

        public void setAge(int age) {
                this.age = age;
        }

        @Override
        public String toString() {
                return "Person{" +
                        "name='" + name + '\'' +
                        ", age=" + age +
                        '}';
        }

        @Override
        public boolean equals(Object o) {
                if (this == o) return true;
                if (o == null || getClass() != o.getClass()) return false;
                Person person = (Person) o;
                return age == person.age &amp;&amp; Objects.equals(name, person.name);
        }

        @Override
        public int hashCode() {
                return Objects.hash(name, age);
        }
}

	//测试
    Collection coll = new ArrayList();
    coll.add(new Person("Jerry",20));
    coll.add(new String("Tom"));
    coll.add(false);
    System.out.println(coll); // [Person{name='Jerry', age=20}, Tom, false]
    System.out.println(coll.contains("Tom")); // true
    System.out.println(coll.contains(new Person("Jerry",20))); // true 重写了equals方法
    System.out.println(coll.remove(new Person("Jerry",20))); // true
    System.out.println(coll); // [Tom, false]

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n2287" mdtype="fences">    Object[] arr = coll.toArray();
    for(int i = 0;i &lt; arr.length;i++){
            System.out.println(arr[i]);
    }
    List&lt;String&gt; list = Arrays.asList(new String[]{"AA", "BB", "CC"});
    System.out.println(list);

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n2288" mdtype="fences">	List arr1 = Arrays.asList(new int[]{123, 456});
    System.out.println(arr1); // [[I@15aeb7ab]
    System.out.println(arr1.size()); // 1

    List arr2 = Arrays.asList(new Integer[]{123, 456});
    System.out.println(arr2); // [123,456]
    System.out.println(arr2.size()); // 2

</pre><h2><a name='header-n2289' class='md-header-anchor '></a>90. Iterator迭代器</h2><ul><li>集合元素的遍历操作，使用迭代器Iterator接口：</li></ul><ol start='' ><li>内部的方法：hasNext() 和  next()</li><li>集合对象每次调用iterator()方法都得到一个全新的迭代器对象，默认游标都在集合的第一个元素之前。</li><li>内部定义了remove(),可以在遍历的时候，删除集合中的元素。此方法不同于集合直接调用remove()</li></ol><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n2300" mdtype="fences" style="break-inside: unset;">    Collection coll = new ArrayList();
    coll.add(123);
    coll.add(new String("Tom"));
    coll.add(false);
    Iterator iterator = coll.iterator();
    for(int i = 0;i &lt; coll.size();i++){
            System.out.println(iterator.next());
    }

    //集合对象每次调用iterator()方法都得到一个全新的迭代器对象，默认游标都在集合的第一个元素之前。
    Iterator iterator1 = coll.iterator();
    //hasNext():判断是否还有下一个元素
    while(iterator1.hasNext()){
            //next():①指针下移 ②将下移以后集合位置上的元素返回
            System.out.println(iterator1.next());
    }

    Iterator iterator2 = coll.iterator();
    while (iterator2.hasNext()){
            Object obj = iterator2.next();
            if("Tom".equals(obj)) {
                    iterator2.remove();
            }
    }

</pre><h2><a name='header-n2301' class='md-header-anchor '></a>91. List</h2><p>List集合：java.util.list接口 extends Collection接口</p><ul><li><p>List接口特点：
<span>	</span>1. 有序集合 存储元素和取出的顺序是一样的
<span>	</span>2. 有索引 包含了一些带索引的方法
<span>	</span>3. 允许存储重复的元素</p></li><li><p>List常用方法：</p><ol start='' ><li><p>public void add(int index,E element) 将指定元素 添加到该集合的指定位置上</p><ol start='2' ><li>public E get(int index) 返回集合指定位置上的元素</li><li>public E remove(int index) 移除列表中指定位置的元素 返回的是被移除的元素</li><li>public E set(int index,E element) 用指定元素替换集合中指定位置的元素 返回更新前的元素</li><li>boolean addAll(int index, Collection eles):从index位置开始将eles中的所有元素添加进来</li><li>int indexOf(Object obj):返回obj在集合中首次出现的位置</li><li>int lastIndexOf(Object obj):返回obj在当前集合中末次出现的位置</li></ol></li><li><p>List subList(int fromIndex, int toIndex):返回从fromIndex到toIndex位置的子集合</p></li></ol></li><li><p>注意：索引的时候一定要防止索引越界异常</p><ol start='' ><li><p>IndexOutOfBoundsException 集合索引越界异常</p><ol start='2' ><li>ArrayIndexOutOfBoundsException 数组索引越界异常</li></ol></li></ol></li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n2334" mdtype="fences">* 	|----Collection接口：单列集合，用来存储一个一个的对象
*     |----List接口：存储有序的、可重复的数据。  --&gt;“动态”数组,替换原有的数组
*        |----ArrayList：作为List接口的主要实现类；线程不安全的，效率高；底层使用Object[] elementData存储
*        |----LinkedList：对于频繁的插入、删除操作，使用此类效率比ArrayList高；底层使用双向链表存储
*      	 |----Vector：作为List接口的古老实现类；线程安全的，效率低；底层使用Object[] elementData存储

</pre><ul><li>add和addAll比较</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n2338" mdtype="fences">    ArrayList list = new ArrayList();
    list.add(123);
    list.add("AA");
    ArrayList list1 = new ArrayList();
    list1.add('C');
    list.add(list1);
    System.out.println(list); // [123, AA, [C]]
    list.addAll(list1);
    System.out.println(list); // [123, AA, [C], C]

</pre><ul><li>remove(int index)和remove(Object obj)比较</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n2342" mdtype="fences">    List list = new ArrayList();
    list.add(1);
    list.add(2);
    list.add(3);
    list.remove(2); // 下标
    System.out.println(list); // [1, 2]
    list.remove(Integer.valueOf(2)); // 元素
    System.out.println(list); // [1]

</pre><ul><li>应用</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n2346" mdtype="fences" style="break-inside: unset;">    //创建一个List集合对象 多态
    List&lt;String&gt; list = new ArrayList&lt;&gt;();
    //使用add方法向集合中添加元素
    list.add("a");
    list.add("b");
    list.add("c");
    list.add("d");
    list.add("a");
    //打印集合
    System.out.println(list);//[a, b, c, d, a]  重写了toString
    //public void add(int index, E element) 将指定元素添加到集合的指定位置上
    //在cd之间添加元素
    list.add(3,"me");
    System.out.println(list);//[a, b, c, me, d, a]
    //public E remove(int index) 移除列表中指定位置的元素 返回被移除的元素
    String removeE = list.remove(3);
    System.out.println("被移除的元素是："+removeE);
    System.out.println(list);//[a, b, c, d, a]
    //public E set(int index,E element) 用指定元素替换集合中的指定元素 范湖更新前的元素
    String setE = list.set(4,"A");
    System.out.println("被替换的元素为："+setE);
    System.out.println(list);//[a, b, c, d, A]

</pre><h2><a name='header-n2347' class='md-header-anchor '></a>92. LinkedList</h2><ul><li><p>java.util.LinkedList集合 implements List接口</p></li><li><p>LinkedList集合特点：</p><ol start='' ><li><p>底层是一个链表结构：查询慢 增删快</p><ol start='2' ><li><p>里面包含了大量操作首尾元素的方法</p><ol start='3' ><li>注意 ：使用LinkedList集合特有的方法 不能使用多态</li></ol></li></ol></li></ol></li><li><p>方法：</p></li></ul><ol start='' ><li>public void addFirst(E e) 将指定元素插入此列表的开头</li><li>public void addLast(E e) 将指定元素添加到此列表的结尾</li><li>public void push(E e) 将元素推入此列表所表示的堆栈</li><li>public E getFrist() 返回此列表的第一个元素</li><li>public E getLast() 返回此列表的最后一个元素</li><li>public E removeFirst() 移除并返回此列表的第一个元素</li><li>public E removeLast() 移除并返回此列表的最后一个元素</li><li>public E pop() 从此列表所表示的堆栈处弹出一个元素</li><li>public boolean isEmpty() 如果列表不包含元素 返回true</li></ol><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n2383" mdtype="fences" style="break-inside: unset;"> 	//创建LinkedList集合对象
    LinkedList&lt;String&gt; linked = new LinkedList&lt;&gt;();
    //使用add方法向集合中添加元素
    linked.add("a");
    linked.add("b");
    linked.add("c");
    System.out.println(linked);//[a, b, c]
    linked.addFirst("www");
    //linked.push("www");//同addFirst()
    System.out.println(linked);//[www, a, b, c]
    //public void addLast(E e) 将指定元素添加到列表结尾 等效于add()
    linked.addLast("com");
    System.out.println(linked);//[www, a, b, c, com]

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n2384" mdtype="fences" style="break-inside: unset;">	//创建LinkedList集合对象
    LinkedList&lt;String&gt; linked = new LinkedList&lt;&gt;();
    //使用add方法向集合中添加元素
    linked.add("a");
    linked.add("b");
    linked.add("c");
    System.out.println(linked);//[a, b, c]
    linked.clear();//清空集合中的元素 在获取集合元素时会抛出NoSuchElementException
    //public boolean isEmpty() 如果列表不包含元素 则返回true
    if(!linked.isEmpty()){
        //public E getFrist() 返回此列表的第一个元素
        //public E getLast() 返回此列表的最后一个元素
        String first = linked.getFirst();
        System.out.println(first);
        String last = linked.getLast();
        System.out.println(last);
    }

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n2385" mdtype="fences" style="break-inside: unset;">	//创建LinkedList集合对象
    LinkedList&lt;String&gt; linked = new LinkedList&lt;&gt;();
    //使用add方法向集合中添加元素
    linked.add("a");
    linked.add("b");
    linked.add("c");
    System.out.println(linked);//[a, b, c]
    //public E removeFirst() 移除并返回此列表的第一个元素
    //public E removeLast() 移除并返回此列表的最后一个元素
    //public E pop() 从此列表所表示的堆栈处弹出一个元素
    String first = linked.removeFirst();
    //String first = linked.pop();//等效于removeFirst()
    System.out.println("被移除的第一个元素是："+first);
    String last = linked.removeLast();
    System.out.println("被移除的最后一个元素是："+last);
    System.out.println(linked);

</pre><h2><a name='header-n2386' class='md-header-anchor '></a>93. Set</h2><ul><li><p>Set接口：(使用同Collection接口方法)</p><ol start='' ><li><p>java.tuil.HashSet接口 extends Collection接口</p></li><li><p>Set接口特点：</p><ol start='' ><li>不允许存储重复元素</li><li>没有索引 也没有带索引的方法 也不能使用普通的for循环遍历</li></ol></li><li><p>java.util.HashSet集合 implements Set接口</p><ol start='' ><li><p>HashSet集合：</p><ol start='' ><li>不允许存储重复元素</li><li>没有索引 也没有带索引的方法 也不能使用普通的for循环遍历</li><li>是一个无序集合 存储元素和取出元素的顺序可能不一样</li><li>底层是一个哈希表结构(查询的速度非常快)</li></ol></li></ol></li></ol></li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n2414" mdtype="fences" style="break-inside: unset;">Set接口的框架：
 * |----Collection接口：单列集合，用来存储一个一个的对象
 *          |----Set接口：存储无序的、不可重复的数据   --&gt;高中讲的“集合”
 *              |----HashSet：作为Set接口的主要实现类；线程不安全的；可以存储null值
 *                  |----LinkedHashSet：作为HashSet的子类；遍历其内部数据时，可以按照添加的顺序遍历
 *                                      对于频繁的遍历操作，LinkedHashSet效率高于HashSet.
 *              |----TreeSet：可以按照添加对象的指定属性，进行排序。
 *
 *  1. Set接口中没有额外定义新的方法，使用的都是Collection中声明过的方法。
 *
 *  2. 要求：向Set(主要指：HashSet、LinkedHashSet)中添加的数据，其所在的类一定要重写hashCode()和equals()
 *     要求：重写的hashCode()和equals()尽可能保持一致性：相等的对象必须具有相等的散列码
 *      重写两个方法的小技巧：对象中用作 equals() 方法比较的 Field，都应该用来计算 hashCode 值。

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n2415" mdtype="fences" style="break-inside: unset;">一、Set：存储无序的、不可重复的数据
    以HashSet为例说明：
    1. 无序性：不等于随机性。存储的数据在底层数组中并非按照数组索引的顺序添加，而是根据数据的哈希值决定的。
    2. 不可重复性：保证添加的元素按照equals()判断时，不能返回true.即：相同的元素只能添加一个。
二、添加元素的过程：以HashSet为例：
        我们向HashSet中添加元素a,首先调用元素a所在类的hashCode()方法，计算元素a的哈希值，
    此哈希值接着通过某种算法计算出在HashSet底层数组中的存放位置（即为：索引位置），判断数组此位置上是否已经有元素：
        如果此位置上没有其他元素，则元素a添加成功。 ---&gt;情况1
        如果此位置上有其他元素b(或以链表形式存在的多个元素），则比较元素a与元素b的hash值：
            如果hash值不相同，则元素a添加成功。---&gt;情况2
            如果hash值相同，进而需要调用元素a所在类的equals()方法：
                   equals()返回true,元素a添加失败
                   equals()返回false,则元素a添加成功。---&gt;情况2

     对于添加成功的情况2和情况3而言：元素a 与已经存在指定索引位置上数据以链表的方式存储。
     jdk 7 :元素a放到数组中，指向原来的元素。
     jdk 8 :原来的元素在数组中，指向元素a
     HashSet底层：数组+链表的结构。

</pre><ul><li>使用</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n2419" mdtype="fences" style="break-inside: unset;">    Set&lt;Integer&gt; set = new HashSet&lt;&gt;();
    //使用add方法向集合中添加元素
    set.add(1);
    set.add(2);
    set.add(3);
    set.add(1);
    //使用迭代器遍历set集合
    Iterator&lt;Integer&gt; iterator = set.iterator();
    while (iterator.hasNext()){
        Integer integer = iterator.next();
        System.out.println(integer);//1, 2, 3
    }
    //使用增强for遍历set集合
    for(Integer integer : set){
        System.out.println(integer);
    }

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n2420" mdtype="fences" style="break-inside: unset;">class Person {

        private String name;
        private int age;

        public Person() {
        }

        public Person(String name, int age) {
                this.name = name;
                this.age = age;
        }

        public String getName() {
                return name;
        }

        public void setName(String name) {
                this.name = name;
        }

        public int getAge() {
                return age;
        }

        public void setAge(int age) {
                this.age = age;
        }

        @Override
        public String toString() {
                return "Person{" +
                        "name='" + name + '\'' +
                        ", age=" + age +
                        '}';
        }

        @Override
        public boolean equals(Object o) {
                if (this == o) return true;
                if (o == null || getClass() != o.getClass()) return false;
                Person person = (Person) o;
                return age == person.age &amp;&amp; Objects.equals(name, person.name);
        }

        @Override
        public int hashCode() {
                return Objects.hash(name, age);
        }
}

	//测试
    Set set = new HashSet();
    set.add(456);
    set.add(123);
    set.add(123);
    set.add("AA");
    set.add("CC");
    set.add(new Person("Tom",12));
    set.add(new Person("Tom",12));
    set.add(129);
    Iterator iterator = set.iterator();
    while(iterator.hasNext()){
            System.out.println(iterator.next());
    }
    /**
     * AA
     * CC
     * 129
     * 456
     * 123
     * Person{name='Tom', age=12}
     */

</pre><ul><li>哈希值：是一个十进制的整数 由系统随机给出 是一个逻辑地址 不是数据存储的实际物理地址</li><li>在Object类有一个方法可以获得对象的哈希值 int hashCode()  返回该对象的哈希值</li></ul><h2><a name='header-n2426' class='md-header-anchor '></a>94. LinkedHashSet</h2><ul><li>LinkedHashSet作为HashSet的子类，在添加数据的同时，每个数据还维护了两个引用，记录此数据前一个数据和后一个数据。</li><li>优点：对于频繁的遍历操作，LinkedHashSet效率高于HashSet</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n2432" mdtype="fences" style="break-inside: unset;">    Set set = new LinkedHashSet();
    set.add("AA");
    set.add("CC");
    set.add(456);
    set.add(123);
    set.add(new Person("Tom",12));
    Iterator iterator = set.iterator();
    while(iterator.hasNext()){
            System.out.println(iterator.next());
    }
    /**
     * 456
     * 123
     * AA
     * CC
     * Person{name='Tom', age=12}
     */

</pre><h2><a name='header-n2433' class='md-header-anchor '></a>95. TreeSet</h2><ol start='' ><li>向TreeSet中添加的数据，要求是相同类的对象。</li><li>两种排序方式：自然排序（实现Comparable接口） 和 定制排序（Comparator）</li><li>自然排序中，比较两个对象是否相同的标准为：compareTo()返回0.不再是equals().</li><li>定制排序中，比较两个对象是否相同的标准为：compare()返回0.不再是equals().</li></ol><ul><li>自然排序</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n2446" mdtype="fences" style="break-inside: unset;">class Person implements Comparable{

        private String name;
        private int age;

        public Person() {
        }

        public Person(String name, int age) {
                this.name = name;
                this.age = age;
        }

        public String getName() {
                return name;
        }

        public void setName(String name) {
                this.name = name;
        }

        public int getAge() {
                return age;
        }

        public void setAge(int age) {
                this.age = age;
        }

        @Override
        public String toString() {
                return "Person{" +
                        "name='" + name + '\'' +
                        ", age=" + age +
                        '}';
        }

        @Override
        public boolean equals(Object o) {
                if (this == o) return true;
                if (o == null || getClass() != o.getClass()) return false;
                Person person = (Person) o;
                return age == person.age &amp;&amp; Objects.equals(name, person.name);
        }

        @Override
        public int hashCode() {
                return Objects.hash(name, age);
        }

        //按照姓名从大到小排列,年龄从小到大排列
        @Override
        public int compareTo(Object o) {
                if(o instanceof Person){
                        Person person = (Person) o;
                        int compare = -this.name.compareTo(person.name);
                        if(compare != 0){
                                return compare;
                        } else {
                                return Integer.compare(this.age,person.age);
                        }
                } else {
                        throw new RuntimeException("输入的类型不匹配");
                }
        }
}

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n2447" mdtype="fences" style="break-inside: unset;">    TreeSet treeSet = new TreeSet();
    treeSet.add(new Person("Tom",12));
    treeSet.add(new Person("Jerry",32));
    treeSet.add(new Person("Jim",2));
    treeSet.add(new Person("Mike",65));
    treeSet.add(new Person("Jack",33));
    treeSet.add(new Person("Jack",56));
    Iterator iterator = treeSet.iterator();
    while(iterator.hasNext()){
            System.out.println(iterator.next());
    }

    /**
     * Person{name='Tom', age=12}
     * Person{name='Mike', age=65}
     * Person{name='Jim', age=2}
     * Person{name='Jerry', age=32}
     * Person{name='Jack', age=33}
     * Person{name='Jack', age=56}
     */

</pre><ul><li>定制排序</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n2451" mdtype="fences" style="break-inside: unset;">    TreeSet treeSet = new TreeSet(new Comparator() {
            //按照年龄从小到大排列
            @Override
            public int compare(Object o1, Object o2) {
                    if(o1 instanceof Person &amp;&amp; o2 instanceof Person){
                            Person p1 = (Person) o1;
                            Person p2 = (Person) o2;
                            return Integer.compare(p1.getAge(),p2.getAge());
                    }else {
                            throw new RuntimeException("输入数据类型不匹配！");
                    }
            }
    });

    treeSet.add(new Person("Tom",12));
    treeSet.add(new Person("Jerry",32));
    treeSet.add(new Person("Jim",2));
    treeSet.add(new Person("Mike",65));
    treeSet.add(new Person("Mary",33));
    treeSet.add(new Person("Jack",33));
    treeSet.add(new Person("Jack",56));

    Iterator iterator = treeSet.iterator();
    while(iterator.hasNext()){
            System.out.println(iterator.next());
    }

    /**
     * Person{name='Jim', age=2}
     * Person{name='Tom', age=12}
     * Person{name='Jerry', age=32}
     * Person{name='Mary', age=33}
     * Person{name='Jack', age=56}
     * Person{name='Mike', age=65}
     */

</pre><h2><a name='header-n2452' class='md-header-anchor '></a>96. 可变参数</h2><ul><li><p>可变参数：</p><ol start='' ><li><p>使用前提：方法的参数列表数据类型已经确定 但是参数的个数不确定</p><ol start='2' ><li>使用格式：定义方法时使用</li><li>修饰符 返回值类型 方法名(数据类型...变量名){}</li></ol></li></ol></li><li><p>可变参数原理：</p><ol start='' ><li><p>可变参数底层就是一个数组 根据传递参数个数的不同 会创建不同长度的数组 来存储这些参数</p><ol start='2' ><li>传递参数的个数 可以是0-n个</li></ol></li></ol></li><li><p>可变参数注意事项：</p><ol start='' ><li><p>一个方法的参数列表 只能有一个可变参数</p><ol start='2' ><li>如果方法的参数有多个 那么可变参数必须写在参数列表的末尾</li></ol></li></ol></li><li><p>可变参数的终极写法：</p><ul><li>public static void method(Object...obj){}</li></ul></li><li><p>使用：</p></li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n2487" mdtype="fences" style="break-inside: unset;">    public static void main(String[] args) {
            int i = add(10,20,30,2,1,0,21);
            System.out.println(i); // 84
            int t = add(1,2,3,4,5);
            System.out.println(t); // 15
    }
    public static int add(int...arr){
            System.out.println(arr);//底层是一个数组 [I@41629346
            int sum = 0;
            //遍历数组 获取每一个元素
            for(int i : arr){
                    sum+=i;
            }
            return sum;
    }

</pre><h2><a name='header-n2488' class='md-header-anchor '></a>97. Map集合</h2><ol start='' ><li>Map集合是一个双列集合 一个元素包含两个值(key,value)</li><li>Map集合中的元素 key和value的数据类型可以相同也可以不同</li><li>Map集合中的元素 key不允许重复 value可以重复</li><li>Map集合中的元素 key和value是一一对应的</li></ol><ul><li><p>Map常用子类：</p></li><li><p>java.util.HashMap&lt;k,v&gt;集合 implements Map&lt;k,v&gt;接口</p></li><li><p>HashMap集合特点：</p><ol start='' ><li>HashMap集合底层是哈希表：查询速度特别快</li><li>HashMap集合是一个无序集合 存取元素顺序可能不一致</li></ol></li><li><p>java.util.LinkHashMap&lt;k,v&gt;集合 extends HashMap&lt;k,v&gt;集合</p></li><li><p>LinkedHashMap的特点：</p><ol start='' ><li>LinkedHashMap集合底层是哈希表+链表</li><li>LinkedHashMap集合是一个有序的集合 存取元素顺序一致</li></ol></li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n2519" mdtype="fences" style="break-inside: unset;"> *  |----Map:双列数据，存储key-value对的数据   ---类似于高中的函数：y = f(x)
 *         |----HashMap:作为Map的主要实现类；线程不安全的，效率高；存储null的key和value
 *              |----LinkedHashMap:保证在遍历map元素时，可以按照添加的顺序实现遍历。
 *                      原因：在原有的HashMap底层结构基础上，添加了一对指针，指向前一个和后一个元素。
 *                      对于频繁的遍历操作，此类执行效率高于HashMap。
 *         |----TreeMap:保证按照添加的key-value对进行排序，实现排序遍历。此时考虑key的自然排序或定制排序
 *                      底层使用红黑树
 *         |----Hashtable:作为古老的实现类；线程安全的，效率低；不能存储null的key和value
 *              |----Properties:常用来处理配置文件。key和value都是String类型
 *
 *
 *      HashMap的底层：数组+链表  （jdk7及之前）
 *                    数组+链表+红黑树 （jdk 8）
 *  二、Map结构理解：
 *    Map中的key:无序的、不可重复的，使用Set存储所有的key  ---&gt; key所在的类要重写equals()和hashCode() （以HashMap为例）
 *    Map中的value:无序的、可重复的，使用Collection存储所有的value ---&gt;value所在的类要重写equals()
 *    一个键值对：key-value构成了一个Entry对象。
 *    Map中的entry:无序的、不可重复的，使用Set存储所有的entry

 *	三、HashMap底层实现原理：
		HashMap map = new HashMap():
 *      在实例化以后，底层创建了长度是16的一维数组Entry[] table。
 *      ...可能已经执行过多次put...
 *      map.put(key1,value1):
 *      首先，调用key1所在类的hashCode()计算key1哈希值，此哈希值经过某种算法计算以后，得到在Entry数组中的存放位置。
 *      如果此位置上的数据为空，此时的key1-value1添加成功。 ----情况1
 *      如果此位置上的数据不为空，(意味着此位置上存在一个或多个数据(以链表形式存在)),比较key1和已经存在的一个或多个数据
 *      的哈希值：
 *              如果key1的哈希值与已经存在的数据的哈希值都不相同，此时key1-value1添加成功。----情况2
 *              如果key1的哈希值和已经存在的某一个数据(key2-value2)的哈希值相同，继续比较：调用key1所在类的equals(key2)方法，比较：
 *                      如果equals()返回false:此时key1-value1添加成功。----情况3
 *                      如果equals()返回true:使用value1替换value2。
 *
 *       补充：关于情况2和情况3：此时key1-value1和原来的数据以链表的方式存储。
 *
 *      在不断的添加过程中，会涉及到扩容问题，当超出临界值(且要存放的位置非空)时，扩容。默认的扩容方式：扩容为原来容量的2倍，并将原有的数据复制过来。
 *
 *      jdk8 相较于jdk7在底层实现方面的不同：
 *      1. new HashMap():底层没有创建一个长度为16的数组
 *      2. jdk 8底层的数组是：Node[],而非Entry[]
 *      3. 首次调用put()方法时，底层创建长度为16的数组
 *      4. jdk7底层结构只有：数组+链表。jdk8中底层结构：数组+链表+红黑树。
 *         4.1 形成链表时，七上八下（jdk7:新的元素指向旧的元素。jdk8：旧的元素指向新的元素）
           4.2 当数组的某一个索引位置上的元素以链表形式存在的数据个数 &gt; 8 且当前数组的长度 &gt; 64时，此时此索引位置上的所数据改为使用红黑树存储。
 *
 *      DEFAULT_INITIAL_CAPACITY : HashMap的默认容量，16
 *      DEFAULT_LOAD_FACTOR：HashMap的默认加载因子：0.75
 *      threshold：扩容的临界值，=容量*填充因子：16 * 0.75 =&gt; 12
 *      TREEIFY_THRESHOLD：Bucket中链表长度大于该默认值，转化为红黑树:8
 *      MIN_TREEIFY_CAPACITY：桶中的Node被树化时最小的hash表容量:64
 *
 *  四、LinkedHashMap的底层实现原理（了解）
 *      源码中：
 *      static class Entry&lt;K,V&gt; extends HashMap.Node&lt;K,V&gt; {
             Entry&lt;K,V&gt; before, after;//能够记录添加的元素的先后顺序
             Entry(int hash, K key, V value, Node&lt;K,V&gt; next) {
                super(hash, key, value, next);
             }
         }

</pre><ul><li><p>Map接口中的常用方法：</p><ol start='' ><li>public V put(K key, V value) 把指定的键与指定的值添加到Map集合中
返回值V：存储键值对时 key不重复 返回null key重复 会用新的value替换旧的value 返回被替换的value</li><li>public V remove(Object key) 把指定键对应的键值对元素在Map集合中删除
返回值V：key存在时 返回被删除的值 key不存在时 返回null</li><li>public V get(Object key) 根据指定的键 在Map集合中获取对应的值
返回值V：key存在时 返回对应的value值 key不存在时 返回null</li><li>boolean containsKey(Object key) 判断集合中是否包含指定的键
包含返回true 不包含返回false</li><li>void putAll(Map m):将m中的所有key-value对存放到当前map中</li><li>void clear()：清空当前map中的所有数据</li><li>boolean containsValue(Object value)：是否包含指定的value</li><li>int size()：返回map中key-value对的个数</li><li>Empty()：判断当前map是否为空</li><li>boolean equals(Object obj)：判断当前map和参数对象obj是否相等</li><li>Set keySet()：返回所有key构成的Set集合</li><li>Collection values()：返回所有value构成的Collection集合</li><li>Set entrySet()：返回所有key-value对构成的Set集合</li></ol></li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n2550" mdtype="fences">    Map hashMap = new HashMap();
    hashMap.put("A",1);
    hashMap.put("B",2);
    hashMap.put("C",3);
    System.out.println(hashMap); // {A=1, B=2, C=3}
    System.out.println(hashMap.size()); // 3

</pre><h2><a name='header-n2551' class='md-header-anchor '></a>98. TreeMap</h2><ul><li>向TreeMap中添加key-value，要求key必须是由同一个类创建的对象，因为要按照key进行排序：自然排序 、定制排序。</li><li>自然排序</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n2557" mdtype="fences" style="break-inside: unset;">    TreeMap treeMap = new TreeMap();
    Person person1 = new Person("Tom", 13);
    Person person2 = new Person("Jerry", 36);
    Person person3 = new Person("Jack", 23);
    Person person4 = new Person("Alan", 27);
    treeMap.put(person1,43);
    treeMap.put(person2,92);
    treeMap.put(person3,70);
    treeMap.put(person4,66);
    System.out.println(treeMap);
    // {Person{name='Tom', age=13}=43, Person{name='Jerry', age=36}=92, Person{name='Jack', age=23}=70, Person{name='Alan', age=27}=66}
    Set entrySet = treeMap.entrySet();
    Iterator iterator1 = entrySet.iterator();
    while (iterator1.hasNext()){
            Object obj = iterator1.next();
            Map.Entry entry = (Map.Entry) obj;
            System.out.println(entry.getKey() + "--&gt;" + entry.getValue());
    }
    /**
     * Person{name='Tom', age=13}--&gt;43
     * Person{name='Jerry', age=36}--&gt;92
     * Person{name='Jack', age=23}--&gt;70
     * Person{name='Alan', age=27}--&gt;66
     */

</pre><ul><li>定制排序</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n2561" mdtype="fences" style="break-inside: unset;">     TreeMap treeMap = new TreeMap(new Comparator() {
             @Override
             public int compare(Object o1, Object o2) {
                     if(o1 instanceof Person &amp;&amp; o2 instanceof Person){
                             Person u1 = (Person)o1;
                             Person u2 = (Person)o2;
                             return Integer.compare(u1.getAge(),u2.getAge());
                     }
                     throw new RuntimeException("输入的类型不匹配！");
             }
     });
     Person person1 = new Person("Tom", 13);
     Person person2 = new Person("Jerry", 36);
     Person person3 = new Person("Jack", 23);
     Person person4 = new Person("Alan", 27);
     treeMap.put(person1,43);
     treeMap.put(person2,92);
     treeMap.put(person3,70);
     treeMap.put(person4,66);
     System.out.println(treeMap);
     // {Person{name='Tom', age=13}=43, Person{name='Jerry', age=36}=92, Person{name='Jack', age=23}=70, Person{name='Alan', age=27}=66}
     Set entrySet = treeMap.entrySet();
     Iterator iterator1 = entrySet.iterator();
     while (iterator1.hasNext()){
             Object obj = iterator1.next();
             Map.Entry entry = (Map.Entry) obj;
             System.out.println(entry.getKey() + "--&gt;" + entry.getValue());
     }
     /**
      * Person{name='Tom', age=13}--&gt;43
      * Person{name='Jack', age=23}--&gt;70
      * Person{name='Alan', age=27}--&gt;66
      * Person{name='Jerry', age=36}--&gt;92
      */

</pre><h2><a name='header-n2562' class='md-header-anchor '></a>99. Properties</h2><ul><li>Properties:常用来处理配置文件，key和value都是String类型。</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n2566" mdtype="fences" style="break-inside: unset;">    FileInputStream fis = null;
    try {
        Properties pros = new Properties();

        fis = new FileInputStream("jdbc.properties");
        pros.load(fis);//加载流对应的文件

        String name = pros.getProperty("name");
        String password = pros.getProperty("password");

        System.out.println("name = " + name + ", password = " + password);
    } catch (IOException e) {
        e.printStackTrace();
    } finally {
        if(fis != null){
            try {
                fis.close();
            } catch (IOException e) {
                e.printStackTrace();
            }

        }
    }

</pre><h2><a name='header-n2567' class='md-header-anchor '></a>100. 新特性</h2><ul><li><p>JDK9新特性：</p><ul><li><p>List接口 Set接口 Map接口 ：里面增加了一个静态方法of可以给集合一次性增加多个元素</p></li><li><p>static <E> List<E> of (E... elements)</p></li><li><p>使用前提：当集合中存储的元素个数已经确定 不再改变时使用</p></li><li><p>注意：</p><ol start='' ><li>of方法只适用于List接口 Set接口 Map接口 不适用于接口的实现类</li><li>of方法的返回值是一个不能改变的集合 集合不能再使用add put 方法添加元素 会抛出异常</li><li>Set接口和Map接口在调用of方法的时候 不能有重复元素 否则会抛出异常</li></ol></li></ul></li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n2587" mdtype="fences" style="break-inside: unset;">    public static void demo07(){
        List&lt;String&gt; stringList = List.of("a","b","c","d","a");
        System.out.println(stringList);//[a, b, c, d, a]
        //List.add("w");//UnsupportedOperationException 不支持操作异常
        //Set&lt;String&gt; stringSet = Set.of("a","b","a");//IllegalArgumentException 非法参数异常 有重复的元素
        Set&lt;String&gt; stringSet =Set.of("a","b","c","d");
        System.out.println(stringSet);
        //stringSet.add("w");//UnsupportedOperationException 不支持操作异常
        //Map&lt;String,Integer&gt; stringIntegerMap = Map.of("one",18,"two",19,"one",18);//IllegalArgumentException 非法参数异常 有重复元素
        Map&lt;String,Integer&gt; stringIntegerMap = Map.of("one",18,"twp",19);
        System.out.println(stringIntegerMap);
        //stringIntegerMap.put("three",21);//UnsupportedOperationException 不支持操作异常
    }

</pre><ul><li>练习</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n2591" mdtype="fences" style="break-inside: unset;">计算一个字符串中每个字符的出现次数：
	分析：
		1.使用Scanner获取用户输入的字符串
		2.创建Map集合 key是字符串中的字符 value是字符个数
		3.遍历字符串 获取每一个字符
		4.使用获取到的字符 去Map集合中判断key是否存在
			key存在：
				通过字符(key)获取value(字符个数)
				value++;
				put(key,value) 把新的value存储到Map集合中
			key不存在：
				put(key,1)
		5.遍历Map集合 输出结果

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n2592" mdtype="fences" style="break-inside: unset;">    public static void test(){
        Scanner sc = new Scanner(System.in);
        System.out.println("请输入字符串");
        String str = sc.next();
        HashMap&lt;Character,Integer&gt; map = new HashMap&lt;&gt;();
        for (char c : str.toCharArray()){
            if(map.containsKey(c)){
                Integer value = map.get(c);
                value++;
                map.put(c,value);
            } else {
                map.put(c,1);
            }
        }
        for (Character key : map.keySet()){
            Integer value = map.get(key);
            System.out.println(key+"--&gt;"+value);
        }
    }

</pre><h2><a name='header-n2593' class='md-header-anchor '></a>101. Collections工具类</h2><ol start='' ><li>reverse(List)：反转 List 中元素的顺序</li><li>public static <T> boolean addAll(Collection<T> c,T...elements) 向集合中添加多个元素</li><li>shuffle(List)：对 List 集合元素进行随机排序</li><li>sort(List)：根据元素的自然顺序对指定 List 集合元素按升序排序</li><li>sort(List，Comparator)：根据指定的 Comparator 产生的顺序对 List 集合元素进行排序</li><li>swap(List，int， int)：将指定 list 集合中的 i 处元素和 j 处元素进行交换</li><li>Object max(Collection)：根据元素的自然顺序，返回给定集合中的最大元素</li><li>Object max(Collection，Comparator)：根据 Comparator 指定的顺序，返回给定集合中的最大元素</li><li>Object min(Collection)</li><li>Object min(Collection，Comparator)</li><li>int frequency(Collection，Object)：返回指定集合中指定元素的出现次数</li><li>void copy(List dest,List src)：将src中的内容复制到dest中</li><li>boolean replaceAll(List list，Object oldVal，Object newVal)：使用新值替换 List 对象的所有旧值</li></ol><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n2621" mdtype="fences" style="break-inside: unset;">    List list = new ArrayList();
    list.add(123);
    list.add(43);
    list.add(765);
    list.add(-97);
    list.add(0);
    //List dest = new ArrayList();
    //Collections.copy(dest,list);
    //copy：异常：IndexOutOfBoundsException("Source does not fit in dest")
    List dest = Arrays.asList(new Object[list.size()]);
    System.out.println(dest.size()); // list.size() 5
    Collections.copy(dest,list);
    System.out.println(dest);

</pre><ul><li>Collections 类中提供了多个 synchronizedXxx() 方法，该方法可使将指定集合包装成线程同步的集合，从而可以解决多线程并发访问集合时的线程安全问题。</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n2625" mdtype="fences">//返回的list1即为线程安全的List
List list1 = Collections.synchronizedList(list);

</pre><h2><a name='header-n2626' class='md-header-anchor '></a>102. Arrays工具类</h2><ol start='' ><li>Arrays.toString(T [ ] arr); 将基本数据类型的数组转换成字符串。</li><li>Arrays.sort(T  [ ] arr) 数组排序。排序后修改了arr里的值。</li><li>Arrays.equals(T [ ]arr1, T [ ]arr2) 比较arr1和arr2数组，如果下标对应值都相等，则返回true,否则返回false。</li><li>Arrays.binarySearch(T [ ] arr, key)  二分查找有序数组的key值，如果数组包含key，则返回该下标，如果没有找到返回一个负数。</li><li>Arrays.fill(T arr[ ],T value)  将arr数组里的值全部变为value值。不返回参数，改变arr数组的值。可以用于初始化。</li><li>Arrays.asList​(T... a)：返回由指定数组支持的固定大小的列表。 </li></ol><h2><a name='header-n2640' class='md-header-anchor '></a>103. 多线程</h2><ul><li><p>并发与并行：</p><ol start='' ><li><p>并发：指两个或多个事件在同一时间段内发生  交替执行</p><ol start='2' ><li>并行：指两个或多个事件在同一时刻发生  同时执行</li></ol></li></ol></li><li><p>线程与进程：</p><ol start='' ><li><p>进程：指一个内存中运行的应用程序</p><ol start='2' ><li>线程：是进程中的一个执行单元 负责当前进程中程序的执行</li></ol></li></ol></li><li><p>一个程序运行后至少有一个进程 一个进程中可以包含多个线程</p></li><li><p>多线程好处：效率高 多个线程之间不影响</p></li><li><p>线程调度：</p><ol start='' ><li><p>分时调度：所有线程轮流使用Cpu的使用权 平均分配每个线程占用CPU的时间</p><ol start='2' ><li>抢占式调度：优先让优先级高的线程使用CPU 如果线程的优先级相同 那么会随机选择一个(线程随机性) Java使用的为抢占式调度</li></ol></li></ol></li><li><p>主线程：执行主(main)方法的线程</p></li><li><p>单线程程序：
java程序中只有一个线程，执行从main方法开始 从上到下依次执行，JVM执行main方法 main方法会进入到栈内存 JVM会找操作系统开辟一条main方法通向cpu的执行路径，CPU就可以通过这个路径来执行main方法 而这个路径就有一个名字 叫 main(主)线程。</p></li></ul><h2><a name='header-n2674' class='md-header-anchor '></a>104. 创建多线程</h2><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n2675" mdtype="fences">创建多线程程序的第一种方法：创建Thread类的子类
				java.lang.Thread类：是描述线程的类 我们想要实现多线程程序 就必须继承Thread类
	实现步骤：
		1.创建一个Thread类的子类
		2.在Thread类的子类中重写Thread类中的run方法 设置线程任务(开启线程要做什么?)
		3.创建Thread类的子类对象
		4.调用Thread类中的start方法 开启新的线程 执行run方法
			void start() 使该线程开始执行 Java虚拟机调用该线程的run方法
			结果是两个线程并发的运行 当前线程(main线程)和另一个线程(创建的新线程 执行其run方法)
			多次启动一个线程是非法的 特别是当线程已经结束执行后 不能再重新启动
			java程序属于抢占式调度 哪个线程的优先级高 哪个线程优先执行 同一个优先级 随机选择一个执行

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n2676" mdtype="fences" style="break-inside: unset;">	/1.创建一个Thread类的子类
    public class myThread extends Thread{
        //2.在Thread类的子类中重写Thread类中的run方法 设置线程任务
        @Override
        public void run() {
        	//执行代码
            for (int i = 0; i &lt; 20; i++) {
                System.out.println("run:--&gt;"+i);
            }
        }
    }
	
    public static void main(String[] args) {
        //3.创建Thread类的子类对象
        myThread mt = new myThread();
        //4.调用Thread类中的方法start 开启新线程，执行run方法
        //  我们不能通过直接调用run()的方式启动线程，这种方式只是对象调方法，未启用线程。
        mt.start();
        for (int i = 0; i &lt; 20; i++) {
            System.out.println("main:--&gt;"+i);
        }
    }

</pre><p><code>不可以还让已经start()的线程去再启动一个线程，会报IllegalThreadStateException</code></p><ul><li>Thread常用方法</li></ul><ol start='' ><li><p>获取线程名称：</p><ol start='' ><li><p>使用Thread类中的getName() String getName() 返回该线程的名称</p><ol start='2' ><li>可以先获取到当前正在执行的线程 然后再使用线程中的getName()方法获取线程名称
[static Thread currentThread() 返回对当前正在执行的线程对象的引用]</li></ol></li></ol></li></ol><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n2690" mdtype="fences" style="break-inside: unset;">//1.创建一个Thread类的子类
class myThread extends Thread{
        //2.在Thread类的子类中重写Thread类中的run方法 设置线程任务
        //我们不能通过直接调用run()的方式启动线程。
        @Override
        public void run() {
                for (int i = 0; i &lt; 20; i++) {
                        System.out.println("run:--&gt;"+i);
                }
                //获取线程名称getName();
                System.out.println("当前线程："+getName());

                //获取线程名称
                Thread t = Thread.currentThread();
                System.out.println("线程t："+t);
                String name = t.getName();
                System.out.println("当前线程："+name);

                //获取线程名称 链式编程
                System.out.println("当前线程："+Thread.currentThread().getName());
        }
}

   public static void main(String[] args) {
        //3.创建Thread类的子类对象
        myThread mt = new myThread();
        //4.调用Thread类中的方法start 开启新线程 执行run方法
        mt.start();
        System.out.println("当前线程："+Thread.currentThread().getName());
    }

</pre><ol start='2' ><li><p>设置线程名称：(了解)</p><ol start='' ><li>使用Thread类中的setName(名字)
void setName(String name) 改变线程名称 使其与参数name相同</li><li>创建一个带参数的构造方法，参数传递线程的名称 调用父类的带参构造方法 把线程名称传递给父类 让父类(Thread)给子线程起一个名字。Thread(String name) 分配新的 Thread对象</li></ol></li></ol><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n2699" mdtype="fences" style="break-inside: unset;">//1.创建一个Thread类的子类
class myThread extends Thread{
        //2.在Thread类的子类中重写Thread类中的run方法 设置线程任务
        //我们不能通过直接调用run()的方式启动线程。
        @Override
        public void run() {
                for (int i = 0; i &lt; 20; i++) {
                        System.out.println("run:--&gt;"+i);
                }
                //获取线程名称getName();
                System.out.println("当前线程："+getName());

                //获取线程名称
                Thread t = Thread.currentThread();
                System.out.println("线程t："+t);
                String name = t.getName();
                System.out.println("当前线程："+name);

                //获取线程名称 链式编程
                System.out.println("当前线程："+Thread.currentThread().getName());
        }

        public myThread() {
        }

        public myThread(String name) { // 提供构造器
                super(name);
        }
}

    public static void main(String[] args) {
            //3.创建Thread类的子类对象
            myThread mt = new myThread();
            //4.调用Thread类中的方法start 开启新线程 执行run方法
            myThread myThread = new myThread("线程二");
            mt.setName("线程一");
            mt.start();
            myThread.start();
            System.out.println("当前线程："+Thread.currentThread().getName());
    }

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n2700" mdtype="fences"> * 1. start():启动当前线程；调用当前线程的run()
 * 2. run(): 通常需要重写Thread类中的此方法，将创建的线程要执行的操作声明在此方法中
 * 3. currentThread():静态方法，返回执行当前代码的线程
 * 4. getName():获取当前线程的名字
 * 5. setName():设置当前线程的名字
 * 6. yield():释放当前cpu的执行权
 * 7. join():在线程a中调用线程b的join(),此时线程a就进入阻塞状态，直到线程b完全执行完以后，线程a才
 *           结束阻塞状态。
 * 8. stop():已过时。当执行此方法时，强制结束当前线程。
 * 9. public static void sleep(long millis):让当前线程“睡眠”指定的millitime毫秒。在指定的millitime毫秒时间内，当前
 *    线程是阻塞状态。
 * 10. isAlive():判断当前线程是否存活

</pre><ul><li>线程优先级</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n2704" mdtype="fences"> * 1.线程的优先级：
 * MAX_PRIORITY：10
 * MIN _PRIORITY：1
 * NORM_PRIORITY：5  --&gt;默认优先级
 * 
 * 2.如何获取和设置当前线程的优先级：
 *   getPriority():获取线程的优先级
 *   setPriority(int p):设置线程的优先级
 *   说明：高优先级的线程要抢占低优先级线程cpu的执行权。但是只是从概率上讲，高优先级的线程高概率的情况下
 *   被执行。并不意味着只有当高优先级的线程执行完以后，低优先级的线程才执行。

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n2705" mdtype="fences" style="break-inside: unset;">创建多线程程序的第二种方法：实现Runnable接口
	java.lang.Runnable
		实现步骤：
			1.创建一个Runnable接口的实现类
			2.在实现类中重写Runnable接口的run方法 设置线程任务
			3.创建一个Runnable接口的实现类对象
			4.创建Thread类对象 构造方法中传递Runnnable接口的实现类对象
			5.调用Thread类中的start方法 开启新的线程执行run方法
			
实现Runnable接口创建多线程程序的好处：
	1.避免了单继承的局限性
		一个类只能继承一个类 类继承了Thread类就不能继承其他的类
		实现了Runnable接口 还可以继承其他的类 实现其他的接口
	2.增强了程序的扩展性 降低了程序的耦合性
		实现Runnable接口的方式 把设置线程任务和开启新线程进行了分离
		实现类中 重写了run方法：用来设置线程任务
		创建Thread类对象 调用start方法：用来开启新线程

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n2706" mdtype="fences" style="break-inside: unset;">//1.创建一个Runnable接口的实现类
class MyThread implements Runnable{
        //2.在实现类中重写Runnable接口的run方法 设置线程任务
        @Override
        public void run() {
                for (int i = 0; i &lt; 20; i++) {
                        System.out.println(Thread.currentThread().getName()+"--&gt;"+i);
                }
        }
}

public static void main(String[] args) {
        //3.创建一个Runnable接口的实现类对象
        MyThread myThread = new MyThread();
        //4.创建Thread类对象 构造方法中传递Runnable接口的实现类对象
        Thread mt1 = new Thread(myThread);
        //5.调用Thread类中的start方法 开启新的线程执行run方法
        mt1.setName("线程一");
        mt1.start();
        Thread.currentThread().setName("主线程");
        Thread mt2 = new Thread(myThread);
        mt2.setName("线程二");
        mt2.start();
        for (int i = 0; i &lt; 20; i++) {
                System.out.println(Thread.currentThread().getName()+"--&gt;"+i);
        }
}

</pre><ul><li>窗口卖票案例：[3个窗口100张票]</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n2710" mdtype="fences" style="break-inside: unset;">class Window implements Runnable{
        private static int ticket = 100;
        @Override
        public void run() {
                while(true){
                        if(ticket &gt; 0){
                                System.out.println(Thread.currentThread().getName() + ":卖票，票号为：" + ticket);
                                ticket--;
                        }else{
                                break;
                        }
                }
        }
}

    public static void main(String[] args) {
            Window w = new Window();
            Thread t1 = new Thread(w);
            Thread t2 = new Thread(w);
            Thread t3 = new Thread(w);
            t1.setName("窗口1");
            t2.setName("窗口2");
            t3.setName("窗口3");
            t1.start();
            t2.start();
            t3.start();
    }

</pre><ul><li>比较创建线程的两种方式：</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n2714" mdtype="fences"> * 开发中：优先选择：实现Runnable接口的方式
 * 原因：1. 实现的方式没有类的单继承性的局限性
 *      2. 实现的方式更适合来处理多个线程有共享数据的情况。
 * 联系：public class Thread implements Runnable
 * 相同点：两种方式都需要重写run(),将线程要执行的逻辑声明在run()中。

</pre><ul><li><p>匿名内部类方式实现线程的创建：</p><ul><li><p>匿名内部类作用：简化代码</p><ul><li>把子类继承父类、重写父类的方法、创建子类对象合为一步完成。</li><li>匿名内部类最终产物：子类/实现类对象，而这个类没有名字。</li></ul></li><li><p>格式：</p></li></ul></li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n2728" mdtype="fences">		new 父类/接口(){
			重写父类/接口中的方法
		};

</pre><p><span>	</span></p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n2730" mdtype="fences" style="break-inside: unset;">public static void main(String[] args) {

        //线程父类是Thread
        //new myThread().start();
        new Thread(){
                //重写run方法 设置线程任务
                @Override
                public void run() {
                        for (int i = 0; i &lt; 20; i++) {
                                System.out.println(Thread.currentThread().getName()+"--&gt;"+i);
                        }
                }
        }.start();

        //线程的接口Runnable
        //Runnable r = new myThread();//多态
        Runnable r = new Runnable(){
                //重写run方法 设置线程任务
                @Override
                public void run() {
                        for (int i = 0; i &lt; 20; i++) {
                                System.out.println(Thread.currentThread().getName()+"--&gt;"+i);
                        }
                }
        };
        new Thread(r).start();

        //简化接口的方式
        new Thread(new Runnable(){
                //重写run方法 设置线程任务
                @Override
                public void run() {
                        for (int i = 0; i &lt; 20; i++) {
                                System.out.println(Thread.currentThread().getName()+"--&gt;"+i);
                        }
                }
        }).start();
}

</pre><h2><a name='header-n2731' class='md-header-anchor '></a>105. 线程安全问题</h2><ul><li><p>线程安全问题：</p><ol start='' ><li>单线程程序不会出现线程安全问题 多线程程序未访问共享数据不会出现线程安全问题</li><li>多线程访问共享数据会产生线程安全问题</li></ol></li><li><p>同步代码块处理实现Runnable的线程安全问题</p></li><li><p>在实现Runnable接口创建多线程的方式中，我们可以考虑使用this充当同步监视器。</p></li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n2744" mdtype="fences">同步代码块：
		格式：	
			synchronized(锁对象){
				可能会出现线程安全问题的代码()
			}
	注意：
		1.通过代码块中的锁对象 可以使用任意对象
		2.但是必须保证多个线程使用的锁对象是同一个
		3.锁对象作用：
			把同步代码块锁住 只让一个线程在同步代码块中执行

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n2745" mdtype="fences" style="break-inside: unset;">class Window implements Runnable{
        private static int ticket = 9999;
        private Object object = new Object();
        @Override
        public void run() {
                while(true){
                        synchronized (object) { // 也可以写为当前对象(this)或当前类(Window.class)
                                if (ticket &gt; 0) {
                                        System.out.println(Thread.currentThread().getName() + ":卖票，票号为：" + ticket);
                                        ticket--;
                                } else {
                                        break;
                                }
                        }
                }
        }
}

</pre><ul><li><p>同步代码块处理继承Thread类的线程安全问题
<code>使用synchronized(锁对象){
			可能会出现线程安全问题的代码()
		}锁对象必须唯一，private stataic Object obj = new Object();</code></p></li><li><p>在继承Thread类创建多线程的方式中，慎用this充当同步监视器，考虑使用当前类充当同步监视器。</p></li><li><p>同步方法解决线程安全问题：</p><ul><li><p>使用步骤：</p><ol start='' ><li><p>把访问了共享数据的代码抽取出来 放到一个方法中 </p><ol start='2' ><li>在方法上添加synchronized修饰符</li></ol></li></ol></li><li><p>格式：</p></li></ul></li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n2764" mdtype="fences">		修饰符 synchronized 返回值类型 方法名(参数列表){
			可能会出现线程安全问题的代码(访问了共享数据)
		}

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n2765" mdtype="fences" style="break-inside: unset;">class Window implements Runnable{
        private static int ticket = 9999;
        private Object object = new Object();
        @Override
        public void run() {
                while(true){
                        method();
                        if(ticket==0){
                                break;
                        }
                }
        }
        
        private synchronized void method(){ // //同步监视器：this
                if (ticket &gt; 0) {
                        System.out.println(Thread.currentThread().getName() + ":卖票，票号为：" + ticket);
                        ticket--;
                }
        }
}

	//测试
    Window w = new Window();
    Thread t1 = new Thread(w);
    Thread t2 = new Thread(w);
    Thread t3 = new Thread(w);
    t1.setName("窗口1");
    t2.setName("窗口2");
    t3.setName("窗口3");
    t1.start();
    t2.start();
    t3.start();

</pre><ul><li>同步方法处理继承Thread类的线程安全问题</li><li>使用静态同步方法</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n2771" mdtype="fences" style="break-inside: unset;">class Window implements Runnable{
        private static int ticket = 9999;
        private Object object = new Object();
        @Override
        public void run() {
                while(true){
                        method();
                        if(ticket==0){
                                break;
                        }
                }
        }
        
        private static synchronized void method(){ // //同步监视器：Window.class
                if (ticket &gt; 0) {
                        System.out.println(Thread.currentThread().getName() + ":卖票，票号为：" + ticket);
                        ticket--;
                }
        }
}

</pre><ul><li>小结：</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n2775" mdtype="fences"> *  关于同步方法的总结：
 *  1. 同步方法仍然涉及到同步监视器，只是不需要我们显式的声明。
 *  2. 非静态的同步方法，同步监视器是：this
 *     静态的同步方法，同步监视器是：当前类本身

</pre><ul><li>死锁问题</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n2779" mdtype="fences"> * 1.死锁的理解：不同的线程分别占用对方需要的同步资源不放弃，
 * 都在等待对方放弃自己需要的同步资源，就形成了线程的死锁
 *
 * 2.说明：
 * 1）出现死锁后，不会出现异常，不会出现提示，只是所有的线程都处于阻塞状态，无法继续
 * 2）我们使用同步时，要避免出现死锁。

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n2780" mdtype="fences" style="break-inside: unset;">public static void main(String[] args) {

        StringBuffer s1 = new StringBuffer();
        StringBuffer s2 = new StringBuffer();


        new Thread(){
            @Override
            public void run() {

                synchronized (s1){

                    s1.append("a");
                    s2.append("1");

                    try {
                        Thread.sleep(100);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    
                    synchronized (s2){
                        s1.append("b");
                        s2.append("2");

                        System.out.println(s1);
                        System.out.println(s2);
                    }
                }
            }
        }.start();


        new Thread(new Runnable() {
            @Override
            public void run() {
                synchronized (s2){

                    s1.append("c");
                    s2.append("3");

                    try {
                        Thread.sleep(100);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }

                    synchronized (s1){
                        s1.append("d");
                        s2.append("4");

                        System.out.println(s1);
                        System.out.println(s2);
                    }
                }

            }
        }).start();
        
    }

</pre><ul><li><p>Lock锁方式实现线程安全</p></li><li><p>Lock锁：</p><ol start='' ><li><p>java.util.concurrent.locks.Lock接口</p><ol start='2' ><li><p>javautil.concurrent.locks implements Lock接口</p></li><li><p>Lock实现了比synchronized 方法和语句更广泛地锁定操作</p></li><li><p>Lock接口中的方法</p><ol start='' ><li><p>void lock() 获取锁</p><ol start='2' ><li>void unlock() 释放锁</li></ol></li></ol></li></ol></li></ol></li><li><p>使用步骤：</p><ol start='' ><li><p>在成员位置创建一个ReentrantLock对象</p><ol start='2' ><li>在可能会出现安全问题的代码前调用Lock接口中的方法lock获取锁</li><li>在可能会出现安全问题的代码后调用Lock接口中的方法unlock释放锁</li></ol></li></ol></li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n2812" mdtype="fences" style="break-inside: unset;">class Window implements Runnable{

    private int ticket = 100;
    //1.实例化ReentrantLock
    private ReentrantLock lock = new ReentrantLock(); // 参数默认为false 当为true时，为"公平锁"

    @Override
    public void run() {
        while(true){
            try{

                //2.调用锁定方法lock()
                lock.lock();

                if(ticket &gt; 0){

                    try {
                        Thread.sleep(100);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }

                    System.out.println(Thread.currentThread().getName() + "：售票，票号为：" + ticket);
                    ticket--;
                }else{
                    break;
                }
            }finally {
                //3.调用解锁方法：unlock()
                lock.unlock();
            }

        }
    }
}

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n2813" mdtype="fences"> * 1.synchronized 与 Lock的异同：
 * 
 *   相同：二者都可以解决线程安全问题
 *   不同：synchronized机制在执行完相应的同步代码以后，自动的释放同步监视器
 *        Lock需要手动的启动同步（lock()），同时结束同步也需要手动的实现（unlock()）
 *
 * 2.优先使用顺序：
 * Lock  同步代码块（已经进入了方法体，分配了相应资源）  同步方法（在方法体之外）

</pre><h2><a name='header-n2814' class='md-header-anchor '></a>106. 线程的通信</h2><ul><li><p>线程状态概述：新建状态 运行状态 阻塞状态 死亡状态 休眠状态 无限等待状态</p></li><li><p>Object类中的wait带参方法 和 notifyAll()方法：</p><ul><li><p>进入到TimeWaiting(计时等待)有两种方式：</p><ol start='' ><li>使用sleep(long m)方法 在毫秒结束之后 线程睡醒进入到Runnable/Bolcked状态</li><li>使用wait(long m)方法 wait方法如果在毫秒值结束之后还没有被notify唤醒线程睡醒进入到Runnable/Bolcked状态</li></ol></li><li><p>唤醒的方法：</p><ol start='' ><li>void notify() 唤醒在此对象监视器上等待的单个线程</li><li>void notifyAll() 唤醒在此对象监视器上等待的所有线程</li></ol></li></ul></li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n2835" mdtype="fences" style="break-inside: unset;">* 线程通信的例子：使用两个线程打印 1-100。线程1, 线程2 交替打印
 *
 * 涉及到的三个方法：
 * wait():一旦执行此方法，当前线程就进入阻塞状态，并释放同步监视器。
 * notify():一旦执行此方法，就会唤醒被wait的一个线程。如果有多个线程被wait，就唤醒优先级高的那个。
 * notifyAll():一旦执行此方法，就会唤醒所有被wait的线程。
 *
 * 说明：
 * 1.wait()，notify()，notifyAll()三个方法必须使用在同步代码块或同步方法中。
 * 2.wait()，notify()，notifyAll()三个方法的调用者必须是同步代码块或同步方法中的同步监视器。
 *    否则，会出现IllegalMonitorStateException异常
 * 3.wait()，notify()，notifyAll()三个方法是定义在java.lang.Object类中。
 *
 * sleep() 和 wait()的异同:
 * 1.相同点：一旦执行方法，都可以使得当前的线程进入阻塞状态。
 * 2.不同点：1）两个方法声明的位置不同：Thread类中声明sleep() , Object类中声明wait()
 *          2）调用的要求不同：sleep()可以在任何需要的场景下调用。 wait()必须使用在同步代码块或同步方法中
 *          3）关于是否释放同步监视器：如果两个方法都使用在同步代码块或同步方法中，sleep()不会释放锁，wait()会释放锁。

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n2836" mdtype="fences" style="break-inside: unset;">class Number implements Runnable{
    private int number = 1;
    private Object obj = new Object();
    @Override
    public void run() {
        while(true){
            synchronized (obj) {
                obj.notify();
                if(number &lt;= 100){
                    try {
                        Thread.sleep(10);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    System.out.println(Thread.currentThread().getName() + ":" + number);
                    number++;
                    try {
                        //使得调用如下wait()方法的线程进入阻塞状态
                        obj.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }else{
                    break;
                }
            }
        }
    }
}

	public static void main(String[] args) {
        Number number = new Number();
        Thread t1 = new Thread(number);
        Thread t2 = new Thread(number);

        t1.setName("线程1");
        t2.setName("线程2");

        t1.start();
        t2.start();
    }

</pre><ul><li>经典例题</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n2840" mdtype="fences"> * 线程通信的应用：经典例题：生产者/消费者问题
 *
 * 生产者(Productor)将产品交给店员(Clerk)，而消费者(Customer)从店员处取走产品，
 * 店员一次只能持有固定数量的产品(比如:20），如果生产者试图生产更多的产品，店员
 * 会叫生产者停一下，如果店中有空位放产品了再通知生产者继续生产；如果店中没有产品
 * 了，店员会告诉消费者等一下，如果店中有产品了再通知消费者来取走产品。
 *
 * 分析：
 * 1. 是否是多线程问题？是，生产者线程，消费者线程
 * 2. 是否有共享数据？是，店员（或产品）
 * 3. 如何解决线程的安全问题？同步机制,有三种方法
 * 4. 是否涉及线程的通信？是

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n2841" mdtype="fences" style="break-inside: unset;">class Clerk{

    private int productCount = 0;
    //生产产品
    public synchronized void produceProduct() {
        if(productCount &lt; 20){
            productCount++;
            System.out.println(Thread.currentThread().getName() + ":开始生产第" + productCount + "个产品");
            notify();
        }else{
            //等待
            try {
                wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
    //消费产品
    public synchronized void consumeProduct() {
        if(productCount &gt; 0){
            System.out.println(Thread.currentThread().getName() + ":开始消费第" + productCount + "个产品");
            productCount--;
            notify();
        }else{
            //等待
            try {
                wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}

class Producer extends Thread{//生产者
    private Clerk clerk;
    public Producer(Clerk clerk) {
        this.clerk = clerk;
    }
    @Override
    public void run() {
        System.out.println(getName() + ":开始生产产品.....");
        while(true){
            try {
                Thread.sleep(10);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            clerk.produceProduct();
        }
    }
}

class Consumer extends Thread{//消费者
    private Clerk clerk;
    public Consumer(Clerk clerk) {
        this.clerk = clerk;
    }
    @Override
    public void run() {
        System.out.println(getName() + ":开始消费产品.....");
        while(true){
            try {
                Thread.sleep(20);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            clerk.consumeProduct();
        }
    }
}

public class ProductTest {
    public static void main(String[] args) {
        Clerk clerk = new Clerk();
        Producer p1 = new Producer(clerk);
        p1.setName("生产者1");
        Consumer c1 = new Consumer(clerk);
        c1.setName("消费者1");
        Consumer c2 = new Consumer(clerk);
        c2.setName("消费者2");
        p1.start();
        c1.start();
        c2.start();
    }
}

</pre><h2><a name='header-n2842' class='md-header-anchor '></a>107. Callable和线程池</h2><ul><li>创建线程的方式：Callable接口</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n2846" mdtype="fences"> * 如何理解实现Callable接口的方式创建多线程比实现Runnable接口创建多线程方式强大？
 * 1. call()可以有返回值的。
 * 2. call()可以抛出异常，被外面的操作捕获，获取异常的信息
 * 3. Callable是支持泛型的

</pre><ul><li>实现</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n2850" mdtype="fences" style="break-inside: unset;">//1.创建一个实现Callable的实现类
class NumThread implements Callable{
    //2.实现call方法，将此线程需要执行的操作声明在call()中
    @Override
    public Object call() throws Exception {
        int sum = 0;
        for (int i = 1; i &lt;= 100; i++) {
            if(i % 2 == 0){
                System.out.println(i);
                sum += i;
            }
        }
        return sum;
    }
}

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n2851" mdtype="fences" style="break-inside: unset;">public static void main(String[] args) {
    //3.创建Callable接口实现类的对象
    NumThread numThread = new NumThread();
    //4.将此Callable接口实现类的对象作为传递到FutureTask构造器中，创建FutureTask的对象
    FutureTask futureTask = new FutureTask(numThread);
    //5.将FutureTask的对象作为参数传递到Thread类的构造器中，创建Thread对象，并调用start()
    new Thread(futureTask).start();

    try {
        //6.获取Callable中call方法的返回值
        //get()返回值即为FutureTask构造器参数Callable实现类重写的call()的返回值。
        Object sum = futureTask.get();
        System.out.println("总和为：" + sum);
    } catch (InterruptedException e) {
        e.printStackTrace();
    } catch (ExecutionException e) {
        e.printStackTrace();
    }
}

</pre><p>线程池：
<span>	</span>1. java.util.concurrent.Executors 线程池的工厂类 用来生产线程池
<span>	</span>2. Executods类中的静态方法：</p><ul><li>static ExecutorService newFixedThreadPool(int nThreads) 创建一个可重用固定线程数的线程池</li><li>参数： int nThreads 创建线程池中包含的线程数量</li><li>返回值：返回的是ExecutorSerivce接口的实现类对象 可用ExecutorService接口接收</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n2860" mdtype="fences">	java.util.concurrent.ExecutorService：线程池接口
		用来从线程池中获取线程 调用start方法 执行线程任务
			submit(Runnable task) 提交一个Runnable任务用于执行
		关闭/销毁线程池的方法
			void shutdown()

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n2861" mdtype="fences">线程池使用步骤：
	1.使用线程池工厂类Executors里面提供的静态方法newFixedThreadPool生产一个指定线程数量的线程池
	2.创建一个类 实现Runnable接口 重写run方法 设置线程任务
	3.调用ExecutorService接口中的submit方法 传递线程任务(实现类) 开启线程 执行run方法
	4.调用ExecutorService接口中的shutdown方法 销毁线程池(不建议执行)

</pre><p><span>	</span></p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n2863" mdtype="fences"> * 好处：
 * 1.提高响应速度（减少了创建新线程的时间）
 * 2.降低资源消耗（重复利用线程池中线程，不需要每次都创建）
 * 3.便于线程管理
 *      corePoolSize：核心池的大小
 *      maximumPoolSize：最大线程数
 *      keepAliveTime：线程没有任务时最多保持多长时间后会终止

</pre><ul><li>使用演示</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n2867" mdtype="fences" style="break-inside: unset;">class NumberThread1 implements Runnable{
    @Override
    public void run() {
        for(int i = 0;i &lt;= 100;i++){
            if(i % 2 == 0){
                System.out.println(Thread.currentThread().getName() + ": " + i);
            }
        }
    }
}

class NumberThread2 implements Runnable{
    @Override
    public void run() {
        for(int i = 0;i &lt;= 100;i++){
            if(i % 2 != 0){
                System.out.println(Thread.currentThread().getName() + ": " + i);
            }
        }
    }
}

public class ThreadPool {
    public static void main(String[] args) {
        //1. 提供指定线程数量的线程池
        ExecutorService service = Executors.newFixedThreadPool(10);
        ThreadPoolExecutor service1 = (ThreadPoolExecutor) service;
        //设置线程池的属性
          System.out.println(service.getClass());
          service1.setCorePoolSize(15);
          service1.setKeepAliveTime();
        //2.执行指定的线程的操作。需要提供实现Runnable接口或Callable接口实现类的对象
        service.execute(new NumberThread1());//适合适用于Runnable
        service.execute(new NumberThread2());//适合适用于Runnable
        //service.submit(Callable callable);//适合使用于Callable
        //3.关闭连接池
        service.shutdown();
    }
}

</pre><h2><a name='header-n2868' class='md-header-anchor '></a>108. 泛型</h2><ul><li>泛型：一种未知的数据类型 当不知道使用什么类型数据时 可以使用泛型</li><li>泛型的类型必须是类，不能是基本数据类型。需要用到基本数据类型的位置，拿包装类替换</li></ul><p><code>创建集合的时候 就会确定泛型的数据类型</code>
<code>ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();</code></p><ul><li><p>创建集合对象 不使用泛型</p><ol start='' ><li>好处：集合不使用泛型 默认为Object类型 可以存储任意类型的数据</li><li>弊端：不安全 引发异常</li></ol></li><li><p>创建集合对象 使用泛型：</p><ol start='' ><li>好处：
1.避免了类型转换的麻烦 存储的是什么类型 取出的就是什么类型
2.把运行期异常提升到了编译期</li><li>弊端：
泛型是什么类型 就只能存储什么类型的数据</li></ol></li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n2890" mdtype="fences" style="break-inside: unset;">    //集合中使用泛型
    ArrayList&lt;Integer&gt; list =  new ArrayList&lt;Integer&gt;();
    list.add(78);
    list.add(87);
    list.add(99);
    list.add(65);
    
    for(Integer score : list){
        int stuScore = score;
        System.out.println(stuScore);
   }

    Iterator&lt;Integer&gt; iterator = list.iterator();
    while(iterator.hasNext()){
            int stuScore = iterator.next();
            System.out.println(stuScore);
    }

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n2891" mdtype="fences" style="break-inside: unset;">    Map&lt;String,Integer&gt; map = new HashMap&lt;&gt;();
    map.put("Tom",87);
    map.put("Jerry",87);
    map.put("Jack",67);

    Set&lt;Map.Entry&lt;String,Integer&gt;&gt; entry = map.entrySet();
    Iterator&lt;Map.Entry&lt;String, Integer&gt;&gt; iterator = entry.iterator();
    while(iterator.hasNext()){
            Map.Entry&lt;String, Integer&gt; e = iterator.next();
            String key = e.getKey();
            Integer value = e.getValue();
            System.out.println(key + "——" + value);
    }

</pre><p><strong>定义和使用含有泛型的类</strong></p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n2893" mdtype="fences" style="break-inside: unset;">public class Order&lt;T&gt; {
        //类的内部结构就可以使用类的泛型
        T orderT;
        String orderName;
        int orderId;
        
        public Order(){
        }
        
        public Order(String orderName,int orderId,T orderT){
                this.orderName = orderName;
                this.orderId = orderId;
                this.orderT = orderT;
        }
        
        public T getOrderT(){
                return orderT;
        }

        public void setOrderT(T orderT){
                this.orderT = orderT;
        }
}

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n2894" mdtype="fences">    //实例化没有指明类的泛型，则认为此泛型类型为Object类型
    Order order = new Order();
    order.setOrderT(123);
    order.setOrderT("ABC");
    //实例化时指明类的泛型
    Order&lt;String&gt; order1 = new Order&lt;&gt;("orderAA",1001,"order:AA");
    order1.setOrderT("AA:hello");

</pre><p><strong>注意事项</strong>：</p><ol start='' ><li>泛型类可能有多个参数，此时应将多个参数一起放在尖括号内。比如：&lt;E1,E2,E3&gt;</li><li>泛型类的构造器如下：public GenericClass(){}。错误的情况：public GenericClass &lt; E &gt;(){}</li><li>实例化后，操作原来泛型位置的结构必须与指定的泛型类型一致。</li><li>泛型不同的引用不能相互赋值。尽管在编译时ArrayList<String>和ArrayList<Integer>是两种类型，但是，在运行时只有
一个ArrayList被加载到JVM中。</li><li>泛型如果不指定，将被擦除，泛型对应的类型均按照Object处理，但不等价于Object。</li><li>如果泛型结构是一个接口或抽象类，则不可创建泛型类的对象。</li><li>泛型的简化操作：ArrayList<Fruit> flist = new ArrayList&lt;&gt;()。</li><li>泛型的指定中不能使用基本数据类型，可以使用包装类替换。</li><li>在类/接口上声明的泛型，在本类或本接口中即代表某种类型，可以作为非静态属性的类型、非静态方法的参数类型、非静态方法的返回值类型。但在静态方法中不能使用类的泛型。</li><li>异常类不能使用泛型。</li><li>不能使用new E[]。但是可以：E[] elements = (E[])new Object[capacity]，比如T[] arr = (T[]) new Object[10]</li><li>父类有泛型，子类可以选择保留泛型也可以选择指定泛型类型。</li></ol><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n2921" mdtype="fences" style="break-inside: unset;">class Father&lt;T1, T2&gt; {
}
// 子类不保留父类的泛型
class Son1 extends Father {
// 等价于class Son extends Father&lt;Object,Object&gt;
}
// 具体类型
class Son2 extends Father&lt;Integer, String&gt; {
}
// 子类保留父类的泛型
class Son3&lt;T1, T2&gt; extends Father&lt;T1, T2&gt; {
}
class Son4&lt;T2&gt; extends Father&lt;Integer, T2&gt; {
}
class Son5&lt;T1, T2, A, B&gt; extends Father&lt;T1, T2&gt; {
}
class Son6&lt;T2, A, B&gt; extends Father&lt;Integer, T2&gt; {
}

</pre><p><strong>定义和使用含有泛型的方法</strong></p><ul><li>格式：</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n2926" mdtype="fences">修饰符 &lt;泛型&gt; 返回值类型 方法名 (参数列表(泛型)){
	//方法体
}

</pre><ol start='' ><li>泛型方法所属的类是不是泛型类都没有关系。</li><li>泛型方法可以是静态的。</li></ol><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n2932" mdtype="fences">    public static &lt;E&gt;  List&lt;E&gt; copyFromArrayToList(E[] arr){
        ArrayList&lt;E&gt; list = new ArrayList&lt;&gt;();
        for(E e : arr){
            list.add(e);
        }
        return list;
    }

	//测试
	Integer[] arr = new Integer[]{1,2,3,4};
    //泛型方法在调用时，指明泛型参数的类型。
    List&lt;Integer&gt; list = order.copyFromArrayToList(arr);

</pre><p><strong>定义和使用含有泛型的接口</strong></p><ul><li>定义接口的实现类 指定接口的泛型</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n2937" mdtype="fences">    public interface GenericInterface &lt;I&gt; {
        public abstract void method(I i);
    }

    public class GenericInterfaceImpl1 implements GenericInterface &lt;String&gt; {
        @Override
        public void method(String s) {
            System.out.println(s);
        }
    }

</pre><p>  </p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n2939" mdtype="fences">    public class GenericInterfaceImpl2&lt;I&gt; implements GenericInterface&lt;I&gt;{
        @Override
        public void method(I i) {
            System.out.println(i);
        }
    }

	//测试
	GenericInterfaceImpl2&lt;String&gt; genericInterfaceImpl22 = new GenericInterfaceImpl2&lt;&gt;();
    genericInterfaceImpl22.method("str");

</pre><p><strong>泛型在继承方面的体现</strong></p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n2941" mdtype="fences">  类A是类B的父类，但是G&lt;A&gt; 和G&lt;B&gt;二者不具备子父类关系，二者是并列关系。
  类A是类B的父类，A&lt;G&gt; 是 B&lt;G&gt; 的父类

</pre><h2><a name='header-n2942' class='md-header-anchor '></a>109. 通配符?</h2><p>泛型通配符：? : 代表任意的数据类型。不能创建对象使用 只能作为方法的参数使用。
类A是类B的父类，G&lt; A &gt;和G&lt; B &gt;是没有关系的，二者共同的父类是：G&lt;?&gt;</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n2944" mdtype="fences">    List&lt;Object&gt; list1 = null;
    List&lt;String&gt; list2 = null;
    List&lt;?&gt; list = null;
    list = list1;
    list = list2;

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n2945" mdtype="fences">    public void print(List&lt;?&gt; list){
        Iterator&lt;?&gt; iterator = list.iterator();
        while(iterator.hasNext()){
            Object obj = iterator.next();
            System.out.println(obj);
        }
    }

</pre><p><strong>数据读取和写入的要求</strong></p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n2947" mdtype="fences">	List&lt;?&gt; list = null;
    List&lt;String&gt; list3 = new ArrayList&lt;&gt;();
    list3.add("AA");
    list3.add("BB");
    list3.add("CC");
    list = list3;
	//List&lt;?&gt;就不能向其内部添加数据，除了null。
	list.add(null);
	//List&lt;?&gt;允许读取数据，读取的数据类型为Object。
    Object o = list.get(0);
    System.out.println(o);

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n2948" mdtype="fences">泛型的上限限定和下限限定：
	上限限定：? extends E 代表使用的泛型只能是E类型的子类/本身
	下限限定：? super E 代表使用的泛型只能是E类型的父类/本身

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n2949" mdtype="fences">    //泛型的上限：此时的泛型? 必须是Number类型或者Number类型的子类
    public static void getElement1(Collection&lt;? extends Number&gt; coll){}
    //泛型的下限：此时的泛型? 必须是Number类型或者Number类型的父类
    public static void getElement2(Collection&lt;? super Number&gt; coll){}

</pre><h2><a name='header-n2950' class='md-header-anchor '></a>110. File文件</h2><ul><li>File类概述:</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n2954" mdtype="fences">java.io.File类
文件和目录路径的抽象表示形式：
java把电脑中的文件和文件夹(目录)封装成了一个File类 我们可以使用File类对文件和文件夹进行操作
使用File类的方法：	
	创建一个文件/文件夹
	删除文件/文件夹
	获取文件/文件夹
	判断文件/文件夹是否存在
	对文件夹进行遍历
	获取文件大小
File类与系统无关 任何操作系统都可以使用这个类中的方法
file：文件 directory：文件夹/目录 path：路径

</pre><ul><li><p>File类构造方法：</p><ol start='' ><li><p>File(String pathname) 通过将给定的路径名字字符串转换为抽象路径名来创建一个新File实例</p><ul><li>参数：</li></ul><ol start='' ><li>String pathname 字符串路径名称</li><li>路径可以是文件/文件名结尾</li><li>路径可以是相对路径/绝对路径</li><li>路径可以存在/不存在</li><li>创建File对象 只是把字符串路径封装为File对象 不考虑路径的真假</li></ol></li></ol></li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n2975" mdtype="fences">	File f1 = new File("C:\\Users\\IdeaProjects\\a.txt");
	System.out.println(f1);//重写了Object类的toString方法 C:\Users\IdeaProjects\a.txt
	File f2 = new File("C:\\Users\\IdeaProjects");
	System.out.println(f2);//C:\Users\IdeaProjects
	File f3 = new File("b.txt");
	System.out.println(f3);//b.txt

</pre><ol start='2' ><li><p>File(String parent,String child) 根据parent路径名字符串和child路径名字符串创建一个新File实例</p><ul><li><p>参数:</p><ol start='' ><li>String parent 父路径    String child 子路径</li><li>父路径子路径单独书写 使用灵活 父子路径都可以变化</li></ol></li></ul></li></ol><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n2987" mdtype="fences">    File file3 = new File("D:\\workspace_idea1","JavaSenior");
    System.out.println(file3);

</pre><ol start='3' ><li><p>File(File parent,String child) 根据parent抽象路径名和child路径名字符串创建一个新File实例</p><ul><li><p>参数：</p><ol start='' ><li>String parent 父路径    String child 子路径</li><li>父路径子路径单独书写 使用灵活 父子路径都可以变化</li><li>父路是File类型 可以使用File的方法对路径进行操作 再使用路径创建对象</li></ol></li></ul></li></ol><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n3001" mdtype="fences">   File parent = new File("c:\\");
   File file = new File(parent,"a.txt");
   System.out.println(file);// c:\a.txt

</pre><ul><li>常用方法</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n3005" mdtype="fences">public String getAbsolutePath()：获取绝对路径
public String getPath() ：获取路径
public String getName() ：获取名称
public String getParent()：获取上层文件目录路径。若无，返回null
public long length() ：获取文件长度（即：字节数）。不能获取目录的长度。
public long lastModified() ：获取最后一次的修改时间，毫秒值

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n3006" mdtype="fences">    File file1 = new File("hello.txt");
    File file2 = new File("d:\\io\\hi.txt");

    System.out.println(file1.getAbsolutePath());
    System.out.println(file1.getPath());
    System.out.println(file1.getName());
    System.out.println(file1.getParent());
    System.out.println(file1.length());
    System.out.println(new Date(file1.lastModified()));

</pre><ul><li>两个方法适用于文件目录：</li></ul><ol start='' ><li>public String[] list() ：获取指定目录下的所有文件或者文件目录的名称数组</li><li>public File[] listFiles() ：获取指定目录下的所有文件或者文件目录的File数组</li></ol><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n3015" mdtype="fences" style="break-inside: unset;">    File file = new File("D:\\workspace_idea1\\JavaSenior");

    String[] list = file.list();
    for(String s : list){
        System.out.println(s);
    }

    System.out.println();

    File[] files = file.listFiles();
    for(File f : files){
        System.out.println(f);
    }

</pre><ul><li>public boolean renameTo(File dest):把文件重命名为指定的文件路径</li><li>file1.renameTo(file2)为例：要想保证返回true,需要file1在硬盘中是存在的，且file2不能在硬盘中存在。</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n3021" mdtype="fences">    File file1 = new File("hello.txt");
    File file2 = new File("D:\\io\\hi.txt");

    boolean renameTo = file2.renameTo(file1);
    System.out.println(renameTo);

</pre><ol start='' ><li>public boolean isDirectory()：判断是否是文件目录</li><li>public boolean isFile() ：判断是否是文件</li><li>public boolean exists() ：判断是否存在</li><li>public boolean canRead() ：判断是否可读</li><li>public boolean canWrite() ：判断是否可写</li><li>public boolean isHidden() ：判断是否隐藏</li></ol><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n3035" mdtype="fences" style="break-inside: unset;">    File file1 = new File("hello.txt");
    file1 = new File("hello1.txt");

    System.out.println(file1.isDirectory());
    System.out.println(file1.isFile());
    System.out.println(file1.exists());
    System.out.println(file1.canRead());
    System.out.println(file1.canWrite());
    System.out.println(file1.isHidden());

    System.out.println();

    File file2 = new File("d:\\io");
    file2 = new File("d:\\io1");
    System.out.println(file2.isDirectory());
    System.out.println(file2.isFile());
    System.out.println(file2.exists());
    System.out.println(file2.canRead());
    System.out.println(file2.canWrite());
    System.out.println(file2.isHidden());

</pre><ul><li>File类创建删除功能的方法：</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n3039" mdtype="fences" style="break-inside: unset;">	1.public boolean createNewFile() 当且仅当具有该名称的文件尚不存在时 创建一个新的空文件
		创建文件的路径和名称在构造方法中给出
		此方法只能创建文件 不能创建文件夹
		创建文件的路径必须存在 否则会抛出异常
		createNewFile声明抛出异常IOException 调用这个方法 就必须处理这个异常 要么throws继续抛出这个异常 要么try...catch
		
	2.public boolean delete() 删除由此File表示的文件/目录
		可以删除文件/文件夹
		文件/文件夹删除成功返回true
		文件夹中有内容 不会删除 返回false 构造方法路径不存在返回false
		注意：
			delete方法是直接在硬盘上删除文件/文件夹 不走回收站 删除要谨慎
			
	3.public boolean mkdir() 创建由此File表示的目录
		只能创建单级文件夹(空文件夹)
		创建文件夹的路径和名称在构造方法中给出
		返回值：true：文件夹不存在 创建成功 false：文件夹存在或构造方法中的路径不存在
		
	4.public boolean mkdirs() 创建由此File表示的目录 包括任何必需但不存在的父目录
		既可以创建单级文件夹 也可以创建多级文件夹
		创建文件夹的路径和名称在构造方法中给出
		返回值：true：文件夹不存在 创建成功 false：文件夹存在或构造方法中的路径不存在

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n3040" mdtype="fences">    File file1 = new File("hi.txt");
    if(!file1.exists()){
        //文件的创建
        file1.createNewFile();
        System.out.println("创建成功");
    }else{//文件存在
        file1.delete();
        System.out.println("删除成功");
    }

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n3041" mdtype="fences">    File file2 = new File("d:\\io\\io1\\io4");

    boolean mkdir1 = file2.mkdirs();
    if(mkdir1){
        System.out.println("创建成功2");
    }

</pre><ul><li>递归打印多级文件</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n3045" mdtype="fences" style="break-inside: unset;">public static void getAllFile(File dir){
        System.out.println(dir);//打印被遍历的目录名称
        File[] files = dir.listFiles();
        for(File f : files){
                //对遍历得到的File对象f进行判断是否为文件夹
                if(f.isDirectory()){
                        //f是文件夹，则继续遍历这个文件夹
                        //我们发现getAllFile方法就是传递文件夹
                        //可以直接递归调用getAllFile方法
                        getAllFile(f);
                } else {
                        //f是一个文件，直接打印即可
                        System.out.println(f);
                }
        }
}

//测试
getAllFile(new File("d:\\Javacode"));

</pre><ul><li>搜索目录下以.java结尾的文件</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n3049" mdtype="fences" style="break-inside: unset;">//定义一个方法 参数传递File类型的目录 方法中对目录进行遍历
public static void getAllFile(File dir){
        //System.out.println(dir);//打印被遍历的目录名称
        File[] files = dir.listFiles();
        for(File f : files){
                //对遍历得到的File对象f进行判断是否为文件夹
                if(f.isDirectory()){
                        //f是文件夹，则继续遍历这个文件夹
                        //我们发现getAllFile方法就是传递文件夹，遍历文件夹的方法
                        //直接递归调用getAllFile方法
                        getAllFile(f);
                } else {
                        //f是一个文件，直接打印即可
                        //只要.java结尾的文件
                        
                        //1.把File对象f转换为字符串对象
                        //String name = f.getName();
                        //String path = f.getPath();
                        String str = f.toString();
                        //把字符串转换为小写
                        str = str.toLowerCase();
                        //2.调用String类中的方法endWith判断字符串是否以.java结尾
                        boolean b = str.endsWith(".java");
                        //3.如果是以.java结尾的文件 则输出
                        if(b){
                                System.out.println(f);
                        }

                        /**
                         * //代码简化 链式编程
                         * if(f.getName().toLowerCase().endsWith(".java")){
                         *      System.out.println(f);
                         * }
                         */
                }
        }
}

//测试
getAllFile(new File("d:\\Javacode"));

</pre><p><code>路径分隔符：public static final String separator</code></p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n3051" mdtype="fences">File file = new File("d:" + File.separator + "Javacode" + File.separator + "demo.txt");

</pre><h2><a name='header-n3052' class='md-header-anchor '></a>111. 文件过滤器</h2><ul><li><p>在File类中有两个和ListFiles重载的方法 方法的参数传递的就是过滤器</p><ol start='' ><li><p>File[] listFiles(FileFilter filter) </p><ul><li><p>java.io.FileFilter接口 用于抽象路径名(File对象)的过滤器</p></li><li><p>作用：用来过滤文件(File对象)</p></li><li><p>抽象方法：用来过滤文件的方法：</p><ul><li><p>boolean accept(File pathname) 测试指定抽象路径名是否应该包含在某个路径名列表中</p><ul><li><p>参数：<span>	</span></p><ol start='' ><li>File pathname 使用ListFiles方法遍历目录得到的每一个文件对象</li></ol></li></ul></li></ul></li></ul></li><li><p>File[] listFiles(FilenameFilter filter) </p></li></ol><ul><li><p>java.io.FilenameFilter接口 实现此接口的类实例可用于过滤文件名</p><ul><li>作用：过滤文件名称</li><li>抽象方法：用来过滤文件的方法：</li></ul><ol start='' ><li><p>boolean accept(File dir,String name) 测试指定文件是否应该包含在某一文件列表中</p><ol start='' ><li><p>参数：</p><ol start='' ><li>File dir 构造方法中传递的被遍历的目录</li><li>String name 使用ListFiles方法遍历目录 获取的每一个文件/文件夹的名称</li></ol></li></ol></li></ol></li></ul></li></ul><p><code>两个过滤器是没有实现类的 需要自己写实现类 重写过滤方法accept 在方法中自己定义过滤的规则</code></p><hr /><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n3098" mdtype="fences" style="break-inside: unset;">public class Javacode {
        
        public static void main(String[] args) {
                getAllFile(new File("D:\\Javacode"));
        }
        
        //定义一个方法，参数传递File类型的目，方法中对目录进行遍历
        public static void getAllFile(File dir){
                File[] files = dir.listFiles(new FileFilterImpl());//传递过滤器对象
                //1.listFiles方法会对构造方法中传递的目录进行遍历，获取目录中的每一个文件/文件夹，封装为File对象
                //2.listFiles方法会调用参数传递的过滤器中的accept
                //3.listFiles方法会把遍历得到的每一个File对象传递给accept方法的参数pathname
                for(File f : files){
                        //对遍历得到的File对象f进行判断是否为文件夹
                        if(f.isDirectory()){
                                //f是文件夹，则继续遍历这个文件夹
                                //我们发现getAllFile方法就是传递文件夹，遍历文件夹的方法
                                //直接递归调用getAllFile方法
                                getAllFile(f);
                        } else {
                                //f是一个文件
                                System.out.println(f);
                        }
                }
        }
}

//创建FileFilter过滤器实现类，重写过滤方法accept，定义过滤规则
class FileFilterImpl implements FileFilter {
        @Override
        //accept方法返回值是一个布尔值,为true就会把传递过去的File对象保存到File数组中
        //为false就不会把传递过去的File对象保存到File数组中
        public boolean accept(File pathname) {
                //过滤规则：在accept方法中，判断File对象是否以.java结尾
                //是就返回true，否则返回false
                //如果pathname是一个文件夹，返回true，继续遍历这个文件夹
                if(pathname.isDirectory()) {
                        return true;
                }
                return pathname.getName().toLowerCase().endsWith(".java");
        }
}

</pre><p><code>匿名内部类实现</code></p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n3100" mdtype="fences" style="break-inside: unset;">public static void getAllFile(File dir){
        File[] files = dir.listFiles(new FileFilter(){
                @Override
                public boolean accept(File pathname){
                        //过滤规则 pathname是文件夹或者以.java结尾的文件则返回true
                        return pathname.isDirectory()||pathname.getName().toLowerCase().endsWith(".java");
                }
        });
        for(File f : files){
                //对遍历得到的File对象f进行判断是否为文件夹
                if(f.isDirectory()){
                        //f是文件夹，则继续遍历这个文件夹
                        //我们发现getAllFile方法就是传递文件夹，遍历文件夹的方法
                        //直接递归调用getAllFile方法
                        getAllFile(f);
                } else {
                        //f是一个文件
                        System.out.println(f);
                }
        }
}

</pre><p><code>FilenameFilter过滤+匿名内部类实现</code></p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n3102" mdtype="fences" style="break-inside: unset;">//定义一个方法 参数传递File类型的目录 方法中对目录进行遍历
public static void getAllFile(File dir){
        File[] files = dir.listFiles(new FilenameFilter(){
                @Override
                public boolean accept(File dir,String name){
                        //过滤规则 pathname是文件夹或者以.java结尾的文件则返回true
                        return new File(dir,name).isDirectory()||name.toLowerCase().endsWith(".java");
                }
        });
        for(File f : files){
                //对遍历得到的File对象f进行判断是否为文件夹
                if(f.isDirectory()){
                        //f是文件夹，则继续遍历这个文件夹
                        //getAllFile方法就是传递文件夹，遍历文件夹的方法
                        //直接递归调用getAllFile方法
                        getAllFile(f);
                } else {
                        //f是一个文件
                        System.out.println(f);
                }
        }
}

</pre><p><code>Lambda表达式简化匿名内部类：</code>
<code>File[] files = dir.listFiles(pathname-&gt;pathname.isDirectory()||pathname.getName().toLowerCase().endsWith(&quot;.java&quot;));</code>
<code>File[] files = dir.listFiles((d,name)-&gt;new File(d,name).isDirectory()||name.toLowerCase().endsWith(&quot;.java&quot;));</code></p><hr /><p>&nbsp;</p><h2><a name='header-n3106' class='md-header-anchor '></a>112. IO流</h2><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n3107" mdtype="fences">输入：把硬盘中的数据读取到内存中使用
输出：把内存中的数据写入到硬盘中保存
</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n3108" mdtype="fences"> * 1.操作数据单位：字节流、字符流
 * 2.数据的流向：输入流、输出流
 * 3.流的角色：节点流、处理流
 *
 * 抽象基类      	        节点流（或文件流）                               缓冲流（处理流的一种）
 * InputStream     FileInputStream   (read(byte[] buffer))        BufferedInputStream (read(byte[] buffer))
 * OutputStream    FileOutputStream  (write(byte[] buffer,0,len)  BufferedOutputStream (write(byte[] buffer,0,len) / flush()
 * Reader          FileReader (read(char[] cbuf))                 BufferedReader (read(char[] cbuf) / readLine())
 * Writer          FileWriter (write(char[] cbuf,0,len)           BufferedWriter (write(char[] cbuf,0,len) / flush()
</pre><p><strong>IO异常处理</strong></p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n3110" mdtype="fences">try{
	可能产生异常的代码
} catch(异常类变量 变量名){
	异常处理逻辑
} finally{
	一定执行的代码
	资源释放
}
</pre><p><strong>文件字符输入流FileReader</strong></p><ul><li><p>构造方法：</p><ol start='' ><li><p>FileReader(String fileName)</p><ol start='2' ><li>FileReader(File file)</li></ol></li></ol></li><li><p>参数：读取文件的数据源</p><ol start='' ><li>String fileName 文件路径</li><li>File file 一个文件</li></ol></li><li><p>FileReader中构造方法的作用：</p><ol start='' ><li>创建一个FileReader对象</li><li>会把FileReader对象指向要读取的文件</li></ol></li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n3135" mdtype="fences">String类的构造方法：
	String(char[] value) 把字符数组转换为字符串
	String(char[] value,int offset,int count) 把字符数组的一部分转换为字符串 offset为开始索引 count为个数
</pre><ul><li>共性成员方法：</li></ul><ol start='' ><li>int read() 读取单个字符并返回</li><li>int read(char[] cbuf) 一次读取多个字符 将字符读入数组</li><li>void close() 关闭该流并释放与之关联的所有资源</li></ol><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n3146" mdtype="fences" style="break-inside: unset;">    FileReader fr = null;
    try {
            //1.实例化File类的对象，指明要操作的文件
            File file = new File("hello.txt");//相较于当前工程
            System.out.println(file.getAbsolutePath());
            //2.提供具体的流
            fr = new FileReader(file);
            //3.数据的读入
            //read():返回读入的一个字符。如果达到文件末尾，返回-1
            //方式一：
            int data;
            while((data = fr.read()) != -1){
                    System.out.print((char)data);
            }
    } catch (IOException e) {
            e.printStackTrace();
    } finally {
            //4.流的关闭操作
            try {
                    if (fr != null)
                            fr.close();
            } catch (IOException e) {
                    e.printStackTrace();
            }
    }
</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n3147" mdtype="fences" style="break-inside: unset;">    FileReader fr = null;
    try {
            //1.实例化File类的对象，指明要操作的文件
            File file = new File("hello.txt");//相较于当前工程
            System.out.println(file.getAbsolutePath());
            //2.提供具体的流
            fr = new FileReader(file);
            //3.数据的读入
            //read():返回读入的一个字符。如果达到文件末尾，返回-1
            //方式二：
            int data = fr.read();
            while(data != -1){
                System.out.print((char)data);
                data = fr.read();
            }
    } catch (IOException e) {
            e.printStackTrace();
    } finally {
            //4.流的关闭操作
            if(fr != null){
                    try {
                            fr.close();
                    } catch (IOException e) {
                            e.printStackTrace();
                    }
            }
    }
</pre><ol start='' ><li>read()的理解：返回读入的一个字符。如果达到文件末尾，返回-1</li><li>异常的处理：为了保证流资源一定可以执行关闭操作。需要使用try-catch-finally处理</li><li>读入的文件一定要存在，否则就会报FileNotFoundException。</li></ol><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n3155" mdtype="fences" style="break-inside: unset;">	FileReader fr = null;
    //1.实例化FileReader fr = null;
    try {
            //1.File类的实例化
            File file = new File("hello.txt");
            //2.FileReader流的实例化
            fr = new FileReader(file);
            //3.读入的操作
            //read(char[] cbuf):返回每次读入cbuf数组中的字符的个数。如果达到文件末尾，返回-1
            char[] cbuf = new char[5];
            int len;
            while ((len = fr.read(cbuf)) != -1) {
                    String str = new String(cbuf, 0, len);
                    System.out.print(str);
            }
    } catch (IOException e) {
            e.printStackTrace();
    } finally {
            if (fr != null) {
                    //4.资源的关闭
                    try {
                            fr.close();
                    } catch (IOException e) {
                            e.printStackTrace();
                    }
            }
    }
</pre><p>&nbsp;</p><p><strong>FileWriter 文件字符输出流</strong></p><ul><li><p>构造方法：<span>	</span></p><ol start='' ><li><p>FileWriter(File file) 根据给定的File对象构造一个FileWriter对象</p><ol start='2' ><li>FileWriter(String fileName) 根据给定的文件名构造一个FileWriter对象</li></ol></li></ol><ul><li><p>参数：写入数据的目的地</p><ol start='' ><li>String fileName 文件路径</li><li>File file 一个文件</li></ol></li><li><p>构造方法的作用：</p><ol start='' ><li>创建一个FileWriter对象</li><li>根据构造方法中传递的文件/文件路径 创建文件</li><li>会把FileWriter对象指向创建好的文件</li></ol></li></ul></li><li><p>共性成员方法：</p><ol start='' ><li><p>void write(int c) 写入单个字符</p><ol start='2' ><li>void write(char[] cbuf) 写入字符数组</li><li>void write(char[] cbuf,int off,int len) 写入字符数组的某一部分 off为数组开始索引 len为写的字符个数</li><li>void write(String str) 写入字符串</li><li>void write(String str,int off,int len) 写入字符串的一部分 off为字符串开始索引 len为写的字符个数</li><li>void flush() 刷新该流的缓冲</li><li>void close() 关闭此流 但要先刷新它</li></ol></li></ol></li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n3202" mdtype="fences" style="break-inside: unset;">   FileWriter fw = null;
    try {
            //1.提供File类的对象，指明写出到的文件
            File file = new File("hello.txt");
            //2.提供FileWriter的对象，用于数据的写出
            fw = new FileWriter(file,false);
            //3.写出的操作
            fw.write("Hello World!\n");
            fw.write("Hello Java!\n");
    } catch (IOException e) {
            e.printStackTrace();
    } finally {
            //4.流资源的关闭
            if(fw != null){
                    try {
                            fw.close();
                    } catch (IOException e) {
                            e.printStackTrace();
                    }
            }
    }
</pre><ul><li><p>flush和close的区别：</p><ol start='' ><li>flush：刷新缓冲区 流对象可以继续使用(继续写)</li><li>close：先刷新缓冲区 然后通知系统释放资源 流对象不可以再使用</li></ol></li><li><p>字符输出流Writer写数据的其他方法：</p><ol start='' ><li>void write(char[] cbuf) 写入字符数组</li><li>void write(char[] cbuf,int off,int len) 写入字符数组的某一部分 off为数组开始索引 len为写的字符个数</li><li>void write(String str) 写入字符串</li><li>void write(String str,int off,int len) 写入字符串的一部分 off为字符串开始索引 len为写的字符个数</li></ol></li><li><p>续写：追加写 使用两个参数的构造方法：</p><ol start='' ><li><p>FileWriter(String fileName, boolean append)</p></li><li><p>FileWriter(File file,boolean append)</p></li><li><p>参数：</p><ol start='' ><li>String fileName,File file 写入数据的目的地</li><li>boolean append 续写开关 true 不会创建新的文件覆盖源文件 可以续写 false 创建新的文件覆盖</li></ol></li></ol></li></ul><p><strong>FileReader和FileWriter实现文件复制</strong></p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n3237" mdtype="fences" style="break-inside: unset;">	FileReader fr = null;
    FileWriter fw = null;
    try {
            //1.创建File类的对象，指明读入和写出的文件
            File srcFile = new File("hello.txt");
            File destFile = new File("hello2.txt");
            //2.创建输入流和输出流的对象
            fr = new FileReader(srcFile);
            fw = new FileWriter(destFile);
            //3.数据的读入和写出操作
            char[] cbuf = new char[5];
            int len;//记录每次读入到cbuf数组中的字符的个数
            while((len = fr.read(cbuf)) != -1){
                    //每次写出len个字符
                    fw.write(cbuf,0,len);
            }
    } catch (IOException e) {
            e.printStackTrace();
    } finally {
            //4.关闭流资源
            try {
                    if(fw != null)
                            fw.close();
            } catch (IOException e) {
                    e.printStackTrace();
            }
            try {
                    if(fr != null)
                            fr.close();
            } catch (IOException e) {
                    e.printStackTrace();
            }
    }

</pre><p><strong>字节输入输出流</strong></p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n3239" mdtype="fences" style="break-inside: unset;">字节输入流InputStream：
	java.io.InputStream 字节输入流：此抽象类是表示字节输入流所有类的超类
	定义了所有子类共性的方法：
	int read() 从输入流中读取数据的下一个字节，读取一个字节并返回 读取到文件末尾返回-1
	int read(byte[] b) 从输入流中读取一定数量的字节 并将其存储在缓冲区数组b中
	void close() 关闭此输入流并释放与该流关联的所有系统资源
		
java.io.FileInputStream extends InputStream
FileInputStream 文件字节输入流
作用：把硬盘文件中的数据 读取到内存中使用

构造方法：	
	FileInputStream(String name) 
	FileInputStream(File file)
	参数：读取文件的数据源
		String name：文件路径
		File file：文件

构造方法的作用：	
	1.会创建一个FileInputStream对象
	2.会把FileInputStream对象指向构造方法中要读取的文件
	
读取数据的原理(硬盘--&gt;内存)：
	java程序--&gt;JVM--&gt;OS--&gt;OS读取数据的方法--&gt;读取文件
		
字节输入流InputStream的使用步骤
	1.创建FileInputStream对象 构造方法中绑定要读取的数据源
	2.使用FileInputStream对象在的方法read 读取文件
	3.释放资源

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n3240" mdtype="fences">字节输入流InputStream一次读取多个字节：
		int read(byte[] b) 从输入流中读取一定数量的字节 并将其存储在缓冲区数组b中
		byte[]：缓冲作用 存储每次读取到的多个字节
				数组长度一般定义为1024的整数倍
				int返回值：每次读取到的有效字节个数

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n3241" mdtype="fences" style="break-inside: unset;">	//实现对图片的复制操作
    FileInputStream fis = null;
    FileOutputStream fos = null;
    try {
            File srcFile = new File("Photo1.jpg");
            File destFile = new File("Photo2.jpg");
            fis = new FileInputStream(srcFile);
            fos = new FileOutputStream(destFile);

            //复制的过程
            byte[] buffer = new byte[5];
            int len;
            while((len = fis.read(buffer)) != -1){
                    fos.write(buffer,0,len);
            }
    } catch (IOException e) {
            e.printStackTrace();
    } finally {
            if(fos != null){
                    try {
                            fos.close();
                    } catch (IOException e) {
                            e.printStackTrace();
                    }
            }
            if(fis != null){
                    try {
                            fis.close();
                    } catch (IOException e) {
                            e.printStackTrace();
                    }
            }
    }

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n3242" mdtype="fences"> * 1. 对于文本文件(.txt,.java,.c,.cpp)，使用字符流处理
 * 2. 对于非文本文件(.jpg,.mp3,.mp4,.avi,.doc,.ppt,...)，使用字节流处理

</pre><p><strong>JDK7、JDK9对流异常的处理方式</strong></p><ul><li><p>JDK7 ：</p><ol start='' ><li>在try后面增加一个() 在()中可以定义流对象，这个流对象的作用域就在try中有效。</li><li>try中的代码执行完毕 会自动释放流对象 不用再写finally。</li></ol></li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n3252" mdtype="fences">try(定义流对象,定义流对象...){
	可能产生异常的代码
} catch(异常变量名 变量名){
	异常处理逻辑
}

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n3253" mdtype="fences">	try(
            FileInputStream fis = new FileInputStream("c:\\1.jpg");
            FileOutputStream fos = new FileOutputStream("d:\\2.jpg");
    ){
            int len = 0;
            while ((len = fis.read())!=-1){
                    fos.write(len);
            }
    } catch (IOException e){
            System.out.println(e);
    }

</pre><ul><li><p>JDK9 ：</p><ol start='' ><li>try前面可以定义流对象</li><li>在try后面的()中直接引用流对象的名称(变量名)</li><li>在try代码执行完毕后 流对象可以自动释放掉，不用再写finally。</li></ol></li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n3264" mdtype="fences">A a = new A();
B b = new B();
try(a,b){
	可能产生异常的代码
} catch(异常变量名 变量名){
	异常处理的逻辑
}

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n3265" mdtype="fences">public static void main(String[] args) throws FileNotFoundException {
        FileInputStream fis = new FileInputStream("c:\\1.jpg");
        FileOutputStream fos = new FileOutputStream("D:\\2.jpg");
        try(fis;fos){
                int len = 0;
                while ((len = fis.read())!=-1){
                        fos.write(len);
                }
        } catch (IOException e){
                System.out.println(e);
        }
}

</pre><p><strong>缓冲流</strong></p><ul><li>字节缓冲输入流：BufferedInputStream</li><li>字节缓冲输出流：BufferedOutputStream</li><li>字符缓冲输入流：BufferedReader</li><li>字符缓冲输出流：BufferedWriter</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n3276" mdtype="fences" style="break-inside: unset;">BufferedOutputStream：字节缓冲输出流
java.io.BufferedOutputStream extends OutputStream

继承自父类的共性成员方法：
		public void close()   	关闭此输出流并释放与此流有关的所有系统资源。 
		public void flush()		刷新此输出流并强制写出所有缓冲的输出字节。 
		public void write(byte[] b)	  					 	将 b.length 个字节从指定的 byte 数组写入此输出流。 
		public void write(byte[] b, int off, int len)		将指定 byte 数组中从偏移量 off 开始的 len 个字节写入此输出流。 
		public abstract void write(int b)					将指定的字节写入此输出流。 

构造方法：
	BufferedOutputStream(OutputStream out) 创建一个新的缓冲输出流 以将数据写入指定的底层输出流
	BufferedOutputStream(OutputStream out,int size)
	参数：
		OutputStream out 字节输出流，可以传递FileOutputStream 缓冲流会给FileOutputStream增加一个缓冲区提高FileOutputStream的写入效率
		int size 指定缓冲流内部缓冲区的大小，不指定默认

使用步骤：
	1.创建FileOputStream对象 构造方法中绑定要输出的目的地
	2.创建BufferedOutputStream对象 构造方法中传递FileOutputStream对象 提高FileOutputStream对象效率
	3.使用BufferedOutputStream对象中的方法write 把数据写入内部缓冲区中
	4.使用BufferedOutputStream对象中的方法flush 把内部缓冲区中的数据 刷新到文件中
	5.释放资源(会先调用flush方法刷新数据 第4步可以省略)

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n3277" mdtype="fences" style="break-inside: unset;">BufferedInputStream：字节缓冲输入流
java.io.BufferedInputStream extends InputStream
	
继承自父类的成员方法：
	int read() 从输入流中读取数据的下一个字节
	读取一个字节并返回 读取到文件末尾返回-1
	int read(byte[] b) 从输入流中读取一定数量的字节 并将其存储在缓冲区数组b中
	void close() 关闭此输入流并释放与该流关联的所有系统资源
		
构造方法：
	BufferedInputStream(InputStream in) 创建一个BufferedInputStream 
	BufferedInputStream(InputStream in,int size)
	参数：
		InputStream in 字节输入流，可以传递FileInputStream 缓冲流会给FileInputStream增加一个缓冲区 提高FileInputStream读取效率
		int size 指定缓冲流内部缓冲区的大小，不指定默认
	
使用步骤：
	1.创建FileInputStream对象 构造方法中绑定要读取的数据源
	2.创建BufferedInputStream对象 构造方法中传递FileInputStream对象
	3.使用BufferedInputStream对象中的方法read读取文件
	4.释放资源

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n3278" mdtype="fences" style="break-inside: unset;">public void BufferedStreamTest() throws FileNotFoundException {
        BufferedInputStream bis = null;
        BufferedOutputStream bos = null;
        try {
                //1.造文件
                File srcFile = new File("爱情与友情.jpg");
                File destFile = new File("爱情与友情3.jpg");
                //2.1 造节点流
                FileInputStream fis = new FileInputStream((srcFile));
                FileOutputStream fos = new FileOutputStream(destFile);
                //2.2 造缓冲流
                bis = new BufferedInputStream(fis);
                bos = new BufferedOutputStream(fos);
                //3.复制的细节：读取、写入
                byte[] buffer = new byte[10];
                int len;
                while((len = bis.read(buffer)) != -1){
                        bos.write(buffer,0,len);
                }
        } catch (IOException e) {
                e.printStackTrace();
        } finally {
                //4.资源关闭
                //要求：先关闭外层的流，再关闭内层的流
                if(bos != null){
                        try {
                                bos.close();
                        } catch (IOException e) {
                                e.printStackTrace();
                        }
                }
                if(bis != null){
                        try {
                                bis.close();
                        } catch (IOException e) {
                                e.printStackTrace();
                        }
                }
                //说明：关闭外层流的同时，内层流也会自动的进行关闭。关于内层流的关闭，可以省略。
        }
}

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n3279" mdtype="fences" style="break-inside: unset;">字符缓冲输出流：BufferedWriter
java.io.BufferedWriter extends Writer

继承自父类的共性成员方法：
	void write(int c) 写入单个字符
	void write(char[] cbuf) 写入字符数组
	void write(char[] cbuf,int off,int len) 写入字符数组的某一部分 off为数组开始索引 len为写的字符个数
	void write(String str) 写入字符串
	void write(String str,int off,int len) 写入字符串的一部分 off为字符串开始索引 len为写的字符个数
	void flush() 刷新该流的缓冲
	void close() 关闭此流 但要先刷新它
		
构造方法：
	BufferedWriter(Writer out) 创建一个使用默认大小的输出缓冲区的缓冲字符输出流
	BufferedWriter(Writer out,int sz) 
	参数：
		Writer out 字符输出流，可以传递FileWriter 缓冲流会给FileWriter增加一个缓冲区 提高FileWriter的写入效率
		int sz 指定缓冲区的大小 不写默认大小
		
特有成员方法：
	void newLine() 写入一个行分隔符 根据不同的操作系统 获取不同的行分隔符
			
使用步骤：
	1.创建字符缓冲输出流对象 构造方法中传递字符输出流
	2.调用字符缓冲输出流的方法write 把数据写入到内存缓冲区中
	3.调用字符缓冲输出流的方法flush 把内存缓冲区的数据 刷新到文件中
	4.释放资源

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n3280" mdtype="fences" style="break-inside: unset;">字符缓冲输入流：BufferedReader：
java.io.BufferedReader extends Reader

继承自父类的共性成员方法：
	int read() 读取单个字符并返回
	int read(char[] cbuf) 一次读取多个字符 将字符读入数组
	void close() 关闭该流并释放与之关联的所有资源
	
构造方法：
	BufferedReader(Reader in) 创建一个默认大小输入缓冲区的字符缓冲输入流
	BufferedReader(Reader in,int sz) 创建一个使用指定大小输入缓冲区的字符缓冲输入流
	参数：
		Reader in 字符输入流，可以传递FileReader 缓冲流会给FileReader增加一个缓冲区 提高FileReader的读取效率
	
特有成员方法：
	String readLine() 读取一个文本行 读取一行数据
	行的终止符号：通过下列字符之一即可认为某行已终止 \r \n
	返回值：
		包含该行内容的字符串 不包含任何终止符 如果到达流末尾 则返回null

使用步骤：
	1.创建字符缓冲输入流对象 构造方法中传递字符输入流
	2.使用字符缓冲输入流对象中的方法read/readLine读取文本
	3.释放资源

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n3281" mdtype="fences" style="break-inside: unset;">    BufferedReader br = null;
    BufferedWriter bw = null;
    try {
            //创建文件和相应的流
            br = new BufferedReader(new FileReader(new File("dbcp.txt")));
            bw = new BufferedWriter(new FileWriter(new File("dbcp1.txt")));
            //读写操作
            //方式一：使用char[]数组
            /**
             * char[] cbuf = new char[1024];
             *    int len;
             *    while((len = br.read(cbuf)) != -1){
             *        bw.write(cbuf,0,len);
             *     }
             */
            //方式二：使用String
            String data;
            while((data = br.readLine()) != null){
                    //方法一：bw.write(data + "\n");//data中不包含换行符
                    //方法二：
                    bw.write(data);//data中不包含换行符
                    bw.newLine();//提供换行的操作
            }
    } catch (IOException e) {
            e.printStackTrace();
    } finally {
            //关闭资源
            if(bw != null){
                    try {
                            bw.close();
                    } catch (IOException e) {
                            e.printStackTrace();
                    }
            }
            if(br != null){
                    try {
                            br.close();
                    } catch (IOException e) {
                            e.printStackTrace();
                    }
            }
    }

</pre><p><strong>转换流</strong></p><ol start='' ><li><p>转换流：属于字符流</p><ol start='' ><li>InputStreamReader：将一个字节的输入流转换为字符的输入流</li></ol></li><li><p>OutputStreamWriter：将一个字符的输出流转换为字节的输出流</p></li><li><p>作用：提供字节流与字符流之间的转换</p></li></ol><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n3293" mdtype="fences" style="break-inside: unset;">OutputStreamWriter：
	java.io.OutputStreamWriter extends Writer
	OutputStreamWriter (编码 字符--&gt;字节)
	
继承自父类的共性成员方法：
	void write(int c) 写入单个字符
	void write(char[] cbuf) 写入字符数组
	void write(char[] cbuf,int off,int len) 写入字符数组的某一部分 off为数组开始索引 len为写的字符个数
	void write(String str) 写入字符串
	void write(String str,int off,int len) 写入字符串的一部分 off为字符串开始索引 len为写的字符个数
	void flush() 刷新该流的缓冲
	void close() 关闭此流 但要先刷新它
	
构造方法：
	OutputStreamWriter(OutputStream out) 创建使用默认字符编码的 OutputStreamWriter
	OutputStreamWriter(OutputStream out,String charsetName) 创建使用指定字符集的OutputStreamWriter
	参数：
		OutputStream out 字节输出流 可以用来写转换之后的字节到文件中 
		String charseName 指定编码名称 不区分大小写 可以是utf-8/UTF-8/gbk/... 不指定默认使用UTF-8

使用步骤：
	1.创建OutputStreamWriter对象 构造方法中传递字节输出流和指定的编码表名称
	2.使用OutputStreamWriter对象中的方法write 把字符转换为字节存储到缓冲区中(编码)
	3.使用OutputStreamWriter对象中的方法flush 把内存缓冲区中的字节刷新到文件中(使用字节流写文件的过程)
	4.释放资源

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n3294" mdtype="fences" style="break-inside: unset;">InputStreamReader：
	java.io.InputStreamReader extends Reader
	InputStreamReader (解码 字节--&gt;字符)
	
继承自父类的共性成员方法：
	int read() 读取单个字符并返回
	int read(char[] cbuf) 一次读取多个字符 将字符读入数组
	void close() 关闭该流并释放与之关联的所有资源

构造方法：
	InputStreamReader(InputStream in) 创建一个默认的字符集 InputStreamReader
	InputStreamReader(InputStream in,String charsetName) 创建使用指定字符集的InputStreamReader
	参数：
		InputStream in 字节输入流 用来读取文件中保存的字节
		String charsetName 指定编码表名称
	
使用步骤：
	1.创建InputStreamReader对象 构造方法中传递字节输入流和指定的编码表名称
	2.使用InputStreamReader对象中的方法read读取文件
	3.释放资源
	
注意事项：
	构造方法中指定的编码表名称要和文件的编码相同 否则会发生乱码

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n3295" mdtype="fences">	FileInputStream fis = new FileInputStream("dbcp.txt");
    //参数2指明了字符集，具体使用哪个字符集，取决于文件dbcp.txt保存时使用的字符集
    InputStreamReader isr = new InputStreamReader(fis,"UTF-8");//使用系统默认的字符集
    char[] cbuf = new char[20];
    int len;
    while((len = isr.read(cbuf)) != -1){
        String str = new String(cbuf,0,len);
        System.out.print(str);
    }
    isr.close();

</pre><p><strong>转换文件编码</strong></p><ul><li><p>将GBK编码文件转换为UTF-8编码文本文件</p></li><li><p>分析：</p><ol start='' ><li><p>创建InputStreamReader对象 构造方法中传递字节输入流和指定的编码表名称GBK</p><ol start='2' ><li>创建OutputStreamWriter对象 构造方法中传递字节输出流和指定的编码表名称UTF-8</li><li>使用InputStreamReader对象中的方法read读取文件</li><li>使用OutputStreamWriter对象中的方法write 把读取的数据写入到文件中</li><li>释放资源</li></ol></li></ol></li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n3314" mdtype="fences">    public static void main(String[] args) throws IOException {
        InputStreamReader isr = new InputStreamReader(new FileInputStream("000\\GBK.txt"),"GBK");
        OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream("111\\utf-8.txt"),"UTF-8");
        int len = 0;
        while ((len = isr.read())!=-1){
            osw.write(len);
        }
        osw.close();
        isr.close();
    }

</pre><p><strong>字符集</strong></p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n3316" mdtype="fences"> ASCII：美国标准信息交换码。一个字节的7位可以表示。
 ISO8859-1：拉丁码表/欧洲码表。用一个字节的8位表示。
 GB2312：中国的中文编码表。最多两个字节编码所有字符
 GBK：中国的中文编码表升级，融合了更多的中文文字符号。最多两个字节编码
 Unicode：国际标准码，融合了目前人类使用的所有字符。为每个字符分配唯一的字符码。所有的文字都用两个字节来表示。
 UTF-8：变长的编码方式，可用1-4个字节来表示一个字符。

</pre><p><strong>标准输入输出流</strong></p><ul><li><ol start='' ><li>System.in:标准的输入流，默认从键盘输入</li></ol></li><li><ol start='2' ><li>System.out:标准的输出流，默认从控制台输出</li></ol></li><li><ol start='3' ><li>System类的setIn(InputStream is) / setOut(PrintStream ps)方式重新指定输入和输出的流。</li></ol></li></ul><p>&nbsp;</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n3332" mdtype="fences">应用：从键盘输入字符串，要求将读取到的整行字符串转成大写输出。然后继续进行输入操作，直至当输入“e”或者“exit”时，退出程序。
方法一：使用Scanner实现，调用next()返回一个字符串
方法二：使用System.in实现。System.in  ---&gt;  转换流 ---&gt; BufferedReader的readLine()

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n3333" mdtype="fences" style="break-inside: unset;">	BufferedReader br = null;
    try {
        InputStreamReader isr = new InputStreamReader(System.in);
        br = new BufferedReader(isr);
        while (true) {
            System.out.println("请输入字符串：");
            String data = br.readLine();
            if ("e".equalsIgnoreCase(data) || "exit".equalsIgnoreCase(data)) {
                System.out.println("程序结束");
                break;
            }
            String upperCase = data.toUpperCase();
            System.out.println(upperCase);
        }
    } catch (IOException e) {
        e.printStackTrace();
    } finally {
        if (br != null) {
            try {
                br.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

</pre><p><strong>打印流(了解)</strong></p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n3335" mdtype="fences" style="break-inside: unset;">字节打印流概述和使用：
	java.io.PrintStream 打印流
	PrintStream 为其他输出流添加了功能 使他们能够方便地打印各种数据值的表示形式
	
PrintStream特点：
		1.只负责数据的输出 不负责数据的读取
		2.与其他输出流不同 PrintStream 永远不会抛出IOException
		3.特有的方法：
			void print(任意类型的值)
			void println(任意类型的值)
	
构造方法：	
		PrintStream(File file) 输出的目的地是一个文件
		PrintStream(OutputStream out) 输出的目的地是一个字节输出流
		PrintStream(String fileNam

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n3336" mdtype="fences" style="break-inside: unset;">    PrintStream ps = null;
    try {
        FileOutputStream fos = new FileOutputStream(new File("D:\\IO\\text.txt"));
        // 创建打印输出流,设置为自动刷新模式(写入换行符或字节 '\n' 时都会刷新输出缓冲区)
        ps = new PrintStream(fos, true);
        if (ps != null) {// 把标准输出流(控制台输出)改成文件
            System.setOut(ps);
        }
        for (int i = 0; i &lt;= 255; i++) { // 输出ASCII字符
            System.out.print((char) i);
            if (i % 50 == 0) { // 每50个数据一行
                System.out.println(); // 换行
            }
        }
    } catch (FileNotFoundException e) {
        e.printStackTrace();
    } finally {
        if (ps != null) {
            ps.close();
        }
    }

</pre><p><strong>数据流(了解)</strong></p><ul><li>DataInputStream 和 DataOutputStream：用于读取或写出基本数据类型的变量或字符串。</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n3341" mdtype="fences">将内存中的字符串、基本数据类型的变量写出到文件中：

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n3342" mdtype="fences">	DataOutputStream dos = new DataOutputStream(new FileOutputStream("data.txt"));
    dos.writeUTF("text");
    dos.flush();//刷新操作，将内存中的数据写入文件
    dos.writeInt(23);
    dos.flush();
    dos.writeBoolean(true);
    dos.flush();
    dos.close();

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n3343" mdtype="fences">将文件中存储的基本数据类型变量和字符串读取到内存中，保存在变量中：

</pre><p><code>读取不同类型的数据的顺序要与当初写入文件时，保存的数据的顺序一致！</code></p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n3345" mdtype="fences">	DataInputStream dis = new DataInputStream(new FileInputStream("data.txt"));
    String name = dis.readUTF();
    int age = dis.readInt();
    boolean isMale = dis.readBoolean();
    System.out.println("name = " + name);
    System.out.println("age = " + age);
    System.out.println("isMale = " + isMale);
    dis.close();

</pre><p><strong>序列化和反序列化</strong></p><ul><li>序列化：
<span>	</span>1. 把对象以流的方式 写入到文件中保存，叫写对象，也叫对象的序列化
<span>	</span>2. 对象中包含的不仅仅是字符 
<span>	</span>3. 对象的序列化流：ObjectOutputStream</li><li>反序列化：
<span>	</span>1. 把文件中保存的对象 以流的方式读取出来，叫读对象，也叫对象的反序列化
<span>	</span>2. 读取的文件保存的都是字节，使用字节流
<span>	</span>3. 对象的反序列化流：ObjectInputStream</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n3352" mdtype="fences" style="break-inside: unset;">序列化流：ObjectOutputStream
	java.io.ObjectOutputStream extends OutputStream
	作用：把对象以流的方式写入到文件中保存
	
构造方法：
	ObjectOutputStream(OutputStream out) 创建写入指定OutputStream的ObjectOutputStream
	参数：
		OutputStream out 字节输出流
		
特有成员方法：
	void writeObject(Object obj) 将指定的对象写入 ObjectOutputStream
	
使用步骤：
	1.创建ObjectOutputStream对象 构造方法中传递字符输出流
	2.使用ObjectOutputStream对象中的方法writeObject 把对象写入文件中
	3.释放资源

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n3353" mdtype="fences" style="break-inside: unset;">反序列化流：ObjectInputStream
	java.io.ObjectInputStream extends InputStream
	作用：把文件中保存的对象 以流的方式读取出来使用
	
构造方法：
	ObjectInputStream(InputStream in) 创建从指定InputStream读取的ObjectInputStream
	参数：
		InputStream in 字节输入流
		
特有成员方法：
	Object readObject() 从ObjectInputStream读取对象
	
使用步骤：
	1.创建ObjectInputStream对象 构造方法中传递字节输入流
	2.使用ObjectInputStream对象中的方法readObject读取保存对象的文件
	3.释放资源
	4.使用读取出来的对象(打印)

readObject方法声明抛出了ClassNotFoundException异常(class文件找不到异常)
当不存在对象的class文件时抛出该异常

反序列化的前提：
	1.类必须实现Serializable接口
	2.必须存在类对应的class文件

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n3354" mdtype="fences" style="break-inside: unset;">ObjectOutputStream oos = null;
try {
    oos = new ObjectOutputStream(new FileOutputStream("object.dat"));
    oos.writeObject(new String("String"));
    oos.flush();//刷新操作
    oos.flush();
} catch (IOException e) {
    e.printStackTrace();
} finally {
    if(oos != null){
        try {
            oos.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n3355" mdtype="fences" style="break-inside: unset;">ObjectInputStream ois = null;
try {
    ois = new ObjectInputStream(new FileInputStream("object.dat"));
    Object obj = ois.readObject();
    String str = (String) obj;
    System.out.println(str);
} catch (IOException e) {
    e.printStackTrace();
} catch (ClassNotFoundException e) {
    e.printStackTrace();
} finally {
    if(ois != null){
        try {
            ois.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}

</pre><p><strong>自定义类的序列化和反序列化</strong></p><ul><li>实现序列化接口Serializable</li><li>当前类提供一个全局常量：serialVersionUID</li><li>要进行序列化和反序列化的类必须实现Serializable接口 该类就会添加一个标记</li><li>进行序列化和反序列化的时候 就会检测类上是否有这个标记 没有就会抛出NotSerializableException异常</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n3366" mdtype="fences">public class Person implements Serializable{
	...
    public static final long serialVersionUID = 475463534532L;
}

</pre><ul><li>当前类需要实现Serializable接口之外，还必须保证其内部所有属性也必须是可序列化的。（默认情况下，基本数据类型可序列化）</li><li><code>ObjectOutputStream和ObjectInputStream不能序列化static和transient修饰的成员变量。</code></li></ul><p><strong>RandomAccessFile</strong></p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n3373" mdtype="fences"> * RandomAccessFile的使用
 * 1.RandomAccessFile直接继承于java.lang.Object类，实现了DataInput和DataOutput接口
 * 2.RandomAccessFile既可以作为一个输入流，又可以作为一个输出流
 *
 * 3.如果RandomAccessFile作为输出流时，写出到的文件如果不存在，则在执行过程中自动创建。
 *   如果写出到的文件存在，则会对原有文件内容进行覆盖。（默认情况下，从头覆盖）
 *
 * 4. 可以通过相关的操作，实现RandomAccessFile“插入”数据的效果

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n3374" mdtype="fences" style="break-inside: unset;">	RandomAccessFile raf1 = null;
    RandomAccessFile raf2 = null;
    try {
        raf1 = new RandomAccessFile(new File("1.jpg"),"r");
        raf2 = new RandomAccessFile(new File("2.jpg"),"rw");
        byte[] buffer = new byte[1024];
        int len;
        while((len = raf1.read(buffer)) != -1){
            raf2.write(buffer,0,len);
        }
    } catch (IOException e) {
        e.printStackTrace();
    } finally {
        if(raf1 != null){
            try {
                raf1.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
        if(raf2 != null){
            try {
                raf2.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

</pre><ul><li>long getFilePointer()：获取文件记录指针的当前位置。</li><li>void seek(long pos)：将文件记录指针定位到pos位置。</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n3380" mdtype="fences">    RandomAccessFile raf1 = new RandomAccessFile("hello.txt","rw");
    raf1.seek(3);//将指针调到角标为3的位置
    raf1.write("xyz".getBytes());//
    raf1.close();

</pre><p><strong>实现数据插入</strong></p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n3382" mdtype="fences" style="break-inside: unset;">	RandomAccessFile raf1 = new RandomAccessFile("hello.txt","rw");
    raf1.seek(3);//将指针调到角标为3的位置
    //保存指针3后面的所有数据到StringBuilder中
    StringBuilder builder = new StringBuilder((int) new File("hello.txt").length());
    byte[] buffer = new byte[20];
    int len;
    while((len = raf1.read(buffer)) != -1){
        builder.append(new String(buffer,0,len)) ;
    }
    //调回指针，写入“xyz”
    raf1.seek(3);
    raf1.write("xyz".getBytes());
    //将StringBuilder中的数据写入到文件中
    raf1.write(builder.toString().getBytes());
    raf1.close();

</pre><p><strong>Path、Paths和Files核心API</strong></p><ul><li><p>Paths 类提供的静态 get() 方法用来获取 Path 对象：</p><ol start='' ><li>static Path get(String first, String … more) : 用于将多个字符串串连成路径</li><li>static Path get(URI uri): 返回指定uri对应的Path路径</li></ol></li><li><p>Path接口常用方法：</p><ol start='' ><li>String toString() ： 返回调用 Path 对象的字符串表示形式</li><li>boolean startsWith(String path) : 判断是否以 path 路径开始</li><li>boolean endsWith(String path) : 判断是否以 path 路径结束</li><li>boolean isAbsolute() : 判断是否是绝对路径</li><li>Path getParent() ：返回Path对象包含整个路径，不包含 Path 对象指定的文件路径</li><li>Path getRoot() ：返回调用 Path 对象的根路径</li><li>Path getFileName() : 返回与调用 Path 对象关联的文件名</li><li>int getNameCount() : 返回Path 根目录后面元素的数量</li><li>Path getName(int idx) : 返回指定索引位置 idx 的路径名称</li><li>Path toAbsolutePath() : 作为绝对路径返回调用 Path 对象</li><li>Path resolve(Path p) :合并两个路径，返回合并后的路径对应的Path对象</li><li>File toFile(): 将Path转化为File类的对象</li></ol></li><li><p>Files 类：</p></li><li><p>java.nio.file.Files 用于操作文件或目录的工具类。</p></li><li><p>Files常用方法：</p><ol start='' ><li>Path copy(Path src, Path dest, CopyOption … how) : 文件的复制</li><li>Path createDirectory(Path path, FileAttribute&lt;?&gt; … attr) : 创建一个目录</li><li>Path createFile(Path path, FileAttribute&lt;?&gt; … arr) : 创建一个文件</li><li>void delete(Path path) : 删除一个文件/目录，如果不存在，执行报错</li><li>void deleteIfExists(Path path) : Path对应的文件/目录如果存在，执行删除</li><li>Path move(Path src, Path dest, CopyOption…how) : 将 src 移动到 dest 位置</li><li>long size(Path path) : 返回 path 指定文件的大小</li><li>boolean exists(Path path, LinkOption … opts) : 判断文件是否存在</li><li>boolean isDirectory(Path path, LinkOption … opts) : 判断是否是目录</li><li>boolean isRegularFile(Path path, LinkOption … opts) : 判断是否是文件</li><li>boolean isHidden(Path path) : 判断是否是隐藏文件</li><li>boolean isReadable(Path path) : 判断文件是否可读</li><li>boolean isWritable(Path path) : 判断文件是否可写</li><li>boolean notExists(Path path, LinkOption … opts) : 判断文件是否不存在</li><li>SeekableByteChannel newByteChannel(Path path, OpenOption…how) : 获取与指定文件的连
接，how 指定打开方式。</li><li>DirectoryStream<Path> newDirectoryStream(Path path) : 打开 path 指定的目录</li><li>InputStream newInputStream(Path path, OpenOption…how):获取 InputStream 对象</li><li>OutputStream newOutputStream(Path path, OpenOption…how) : 获取 OutputStream 对象</li></ol></li></ul><h2><a name='header-n3462' class='md-header-anchor '></a>113. 网络编程</h2><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n3463" mdtype="fences" style="break-inside: unset;"> * 一、网络编程中有两个主要的问题：
 * 		1.如何准确地定位网络上一台或多台主机；定位主机上的特定的应用
 *	 	2.找到主机后如何可靠高效地进行数据传输
 *
 * 二、网络编程中的两个要素：
 *		1.对应问题一：IP和端口号
 * 		2.对应问题二：提供网络通信协议：TCP/IP参考模型（应用层、传输层、网络层、物理+数据链路层）
 *
 *
 * 三、通信要素一：IP和端口号
 * 		1. IP:唯一的标识 Internet 上的计算机（通信实体）
 * 		2. 在Java中使用InetAddress类代表IP
 * 		3. IP分类：IPv4 和 IPv6 ; 万维网 和 局域网
 * 		4. 域名:   www.baidu.com   www.mi.com  www.sina.com  www.jd.com
 * 		5. 本地回路地址：127.0.0.1 对应着：localhost
 * 		6. 如何实例化InetAddress:两个方法：getByName(String host) 、 getLocalHost()
 *      7. 两个常用方法：getHostName() / getHostAddress()
 *		8. 端口号：正在计算机上运行的进程。
 * 			要求：不同的进程有不同的端口号
 * 			范围：被规定为一个 16 位的整数 0~65535。
 *  	9. 端口号与IP地址的组合得出一个网络套接字：Socket
 * 

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n3464" mdtype="fences" style="break-inside: unset;">try {
        InetAddress inet1 = InetAddress.getByName("192.168.10.14");
        System.out.println(inet1);
        InetAddress inet2 = InetAddress.getByName("www.baidu.com");
        System.out.println(inet2);
        InetAddress inet3 = InetAddress.getByName("127.0.0.1");
        System.out.println(inet3);
        //获取本地ip
        InetAddress inet4 = InetAddress.getLocalHost();
        System.out.println(inet4);
        //getHostName()
        System.out.println(inet2.getHostName());
        //getHostAddress()
        System.out.println(inet2.getHostAddress());
        System.out.println(inet4.getHostName());
        System.out.println(inet4.getHostAddress());
} catch (UnknownHostException e) {
        e.printStackTrace();
}

</pre><ul><li>实现TCP的网络编程：</li><li>客户端发送信息给服务端，服务端将数据显示在控制台上</li></ul><p><code>客户端</code></p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n3471" mdtype="fences" style="break-inside: unset;">Socket socket = null;
OutputStream os = null;
try {
    //1.创建Socket对象，指明服务器端的ip和端口号
    InetAddress inet = InetAddress.getByName("192.168.14.100");
    socket = new Socket(inet,8899);
    //2.获取一个输出流，用于输出数据
    os = socket.getOutputStream();
    //3.写出数据的操作
    os.write("Hello".getBytes());
} catch (IOException e) {
    e.printStackTrace();
} finally {
    //4.资源的关闭
    if(os != null){
        try {
            os.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
    if(socket != null){
        try {
            socket.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}

</pre><p><code>服务端</code></p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n3473" mdtype="fences" style="break-inside: unset;">ServerSocket ss = null;
Socket socket = null;
InputStream is = null;
ByteArrayOutputStream baos = null;
try {
    //1.创建服务器端的ServerSocket，指明自己的端口号
    ss = new ServerSocket(8899);
    //2.调用accept()表示接收来自于客户端的socket
    socket = ss.accept();
    //3.获取输入流
    is = socket.getInputStream();
    //4.读取输入流中的数据
    baos = new ByteArrayOutputStream();
    byte[] buffer = new byte[5];
    int len;
    while((len = is.read(buffer)) != -1){
        baos.write(buffer,0,len);
    }
    System.out.println(baos.toString());
    System.out.println("收到了来自于：" + socket.getInetAddress().getHostAddress() + "的数据");
} catch (IOException e) {
    e.printStackTrace();
} finally {
//5.关闭资源
    if(baos != null){
        try {
            baos.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
    if(is != null){
        try {
            is.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
    if(socket != null){
        try {
            socket.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
    if(ss != null){
        try {
            ss.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

}

</pre><ul><li>客户端发送文件给服务端，服务端将文件保存在本地。</li></ul><p><code>客户端</code></p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n3478" mdtype="fences">Socket socket = new Socket(InetAddress.getByName("127.0.0.1"),9090);
OutputStream os = socket.getOutputStream();
FileInputStream fis = new FileInputStream(new File("beauty.jpg"));
byte[] buffer = new byte[1024];
int len;
while((len = fis.read(buffer)) != -1){
    os.write(buffer,0,len);
}
fis.close();
os.close();
socket.close();

</pre><p><code>服务端</code></p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n3480" mdtype="fences" style="break-inside: unset;">ServerSocket ss = new ServerSocket(9090);
Socket socket = ss.accept();
InputStream is = socket.getInputStream();
FileOutputStream fos = new FileOutputStream(new File("beauty1.jpg"));
byte[] buffer = new byte[1024];
int len;
while((len = is.read(buffer)) != -1){
    fos.write(buffer,0,len);
}
fos.close();
is.close();
socket.close();
ss.close();

</pre><ul><li>从客户端发送文件给服务端，服务端保存到本地。并返回“发送成功”给客户端，并关闭相应的连接。</li></ul><p><code>客户端</code></p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n3485" mdtype="fences" style="break-inside: unset;">Socket socket = new Socket(InetAddress.getByName("127.0.0.1"),9090);
OutputStream os = socket.getOutputStream();
FileInputStream fis = new FileInputStream(new File("photo1.jpg"));
byte[] buffer = new byte[1024];
int len;
while((len = fis.read(buffer)) != -1){
    os.write(buffer,0,len);
}
//关闭数据的输出
socket.shutdownOutput();
//接收来自于服务器端的数据，并显示到控制台上
InputStream is = socket.getInputStream();
ByteArrayOutputStream baos = new ByteArrayOutputStream();
byte[] bufferr = new byte[20];
int len1;
while((len1 = is.read(buffer)) != -1){
    baos.write(bufferr,0,len1);
}
System.out.println(baos.toString());
fis.close();
os.close();
socket.close();
baos.close();

</pre><p><code>服务端</code></p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n3487" mdtype="fences" style="break-inside: unset;">ServerSocket ss = new ServerSocket(9090);
Socket socket = ss.accept();
InputStream is = socket.getInputStream();
FileOutputStream fos = new FileOutputStream(new File("photo2.jpg"));
byte[] buffer = new byte[1024];
int len;
while((len = is.read(buffer)) != -1){
    fos.write(buffer,0,len);
}
System.out.println("传输完成");
//6.服务器端给予客户端反馈
OutputStream os = socket.getOutputStream();
os.write("收到！".getBytes());
fos.close();
is.close();
socket.close();
ss.close();
os.close();

</pre><hr /><ul><li>实现UDP的网络编程：</li></ul><p><code>发送端</code></p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n3493" mdtype="fences">DatagramSocket socket = new DatagramSocket();
String str = "UDP方式发送";
byte[] data = str.getBytes();
InetAddress inet = InetAddress.getLocalHost();
DatagramPacket packet = new DatagramPacket(data,0,data.length,inet,9090);
socket.send(packet);
socket.close();

</pre><p><code>接收端</code></p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n3495" mdtype="fences">DatagramSocket socket = new DatagramSocket(9090);
byte[] buffer = new byte[100];
DatagramPacket packet = new DatagramPacket(buffer,0,buffer.length);
socket.receive(packet);
System.out.println(new String(packet.getData(),0,packet.getLength()));
socket.close();

</pre><ul><li>实现URL的网络编程：</li></ul><ol start='' ><li>public String getProtocol()     获取该URL的协议名</li><li>public String getHost()           获取该URL的主机名</li><li>public String getPort()            获取该URL的端口号</li><li>public String getPath()           获取该URL的文件路径</li><li>public String getFile()             获取该URL的文件名</li><li>public String getQuery()        获取该URL的查询名</li></ol><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n3512" mdtype="fences">try {
    URL url = new URL("http://localhost:8080/examples/beauty.jpg?username=Tom");
    System.out.println(url.getProtocol());
    System.out.println(url.getHost());
    System.out.println(url.getPort());
    System.out.println(url.getPath());
    System.out.println(url.getFile());
    System.out.println(url.getQuery());
} catch (MalformedURLException e) {
    e.printStackTrace();
}

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n3513" mdtype="fences" style="break-inside: unset;">HttpURLConnection urlConnection = null;
InputStream is = null;
FileOutputStream fos = null;
try {
    URL url = new URL("http://localhost:8080/examples/beauty.jpg");
    urlConnection = (HttpURLConnection) url.openConnection();
    urlConnection.connect();
    is = urlConnection.getInputStream();
    fos = new FileOutputStream("beauty.jpg");
    byte[] buffer = new byte[1024];
    int len;
    while((len = is.read(buffer)) != -1){
        fos.write(buffer,0,len);
    }
    System.out.println("下载完成");
} catch (IOException e) {
    e.printStackTrace();
} finally {
    //关闭资源
    if(is != null){
        try {
            is.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
    if(fos != null){
        try {
            fos.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
    if(urlConnection != null){
        urlConnection.disconnect();
    }
}

</pre><h2><a name='header-n3514' class='md-header-anchor '></a>114. 反射</h2><ul><li>反射的特征：动态性。</li><li>Java反射机制提供的功能：</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n3520" mdtype="fences"> 在运行时判断任意一个对象所属的类
 在运行时构造任意一个类的对象
 在运行时判断任意一个类所具有的成员变量和方法
 在运行时获取泛型信息
 在运行时调用任意一个对象的成员变量和方法
 在运行时处理注解
 生成动态代理

</pre><ul><li>反射相关的主要API：</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n3524" mdtype="fences"> java.lang.Class:代表一个类
 java.lang.reflect.Method:代表类的方法
 java.lang.reflect.Field:代表类的成员变量
 java.lang.reflect.Constructor:代表类的构造器

</pre><p><strong>Class类：</strong></p><ol start='' ><li>在Object类中定义了public final Class getClass()方法，将被所有子类继承。</li><li>Class类的常用方法：</li></ol><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n3531" mdtype="fences">2.1  static Class forName(String name) 返回指定类名 name 的 Class 对象
2.2  Object newInstance() 调用缺省构造函数，返回该Class对象的一个实例
2.3  getName() 返回此Class对象所表示的实体（类、接口、数组类、基本类型或void）名称
2.4  Class getSuperClass() 返回当前Class对象的父类的Class对象
2.5  Class [] getInterfaces() 获取当前Class对象的接口
2.6  ClassLoader getClassLoader() 返回该类的类加载器
2.7  Class getSuperclass() 返回表示此Class所表示的实体的超类的Class
2.8  Constructor[] getConstructors() 返回一个包含某些Constructor对象的数组
2.9  Field[] getDeclaredFields() 返回Field对象的一个数组
2.10 Method getMethod(String name,Class … paramTypes)返回一个Method对象，此对象的形参类型为paramType

</pre><p>&nbsp;</p><ul><li>反射之前，对于类的操作：</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n3536" mdtype="fences" style="break-inside: unset;">public class Person {

    private String name;
    public int age;

    @Override
    public String toString() {
        return "Person{" +
                "name='" + name + '\'' +
                ", age=" + age +
                '}';
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public Person(String name, int age) {

        this.name = name;
        this.age = age;
    }

    public Person() {
        System.out.println("Person()");
    }
    
    private Person(String name) {
        this.name = name;
    }
    
    public void show(){
        System.out.println("你好，我是一个人");
    }
    
    private String showNation(String nation){
        System.out.println("我的国籍是：" + nation);
        return nation;
    }
    
}

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n3537" mdtype="fences">	//1.创建Person类的对象
	Person p1 = new Person("Tom", 12);
	//2.通过对象，调用其内部的属性、方法
	p1.age = 10;
	System.out.println(p1.toString());
	p1.show();
	//在Person类外部，不可以通过Person类的对象调用其内部私有结构。

</pre><ul><li>使用反射，对于类的操作：</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n3541" mdtype="fences" style="break-inside: unset;">    Class clazz = Person.class;
    //1.通过反射，创建Person类的对象
    Constructor cons = clazz.getConstructor(String.class,int.class);
    Object obj = cons.newInstance("Tom", 12);
    Person p = (Person) obj;
    System.out.println(p.toString());
    //2.通过反射，调用对象指定的属性、方法
    //调用属性
    Field age = clazz.getDeclaredField("age");
    age.set(p,10);
    System.out.println(p.toString());
    //调用方法
    Method show = clazz.getDeclaredMethod("show");
    show.invoke(p);

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n3542" mdtype="fences" style="break-inside: unset;">    //通过反射，调用私有的构造器
    Constructor cons1 = clazz.getDeclaredConstructor(String.class);
    cons1.setAccessible(true);
    Person p1 = (Person) cons1.newInstance("Jerry");
    System.out.println(p1);
    //通过反射，调用私有的属性
    Field name = clazz.getDeclaredField("name");
    name.setAccessible(true);
    name.set(p1,"HanMeimei");
    System.out.println(p1);
    //通过反射，调用私有的方法
    Method showNation = clazz.getDeclaredMethod("showNation", String.class);
    showNation.setAccessible(true);
    String nation = (String) showNation.invoke(p1,"中国");//相当于String nation = p1.showNation("中国")
    System.out.println(nation);

</pre><ul><li>类的加载过程</li></ul><blockquote><p>程序经过javac.exe命令以后，会生成一个或多个字节码文件(.class结尾)，接着使用java.exe命令对某个字节码文件进行解释运行。相当于将某个字节码文件加载到内存中。此过程就称为类的加载。加载到内存中的类，我们就称为运行时类，此运行时类，就作为Class的一个实例。</p></blockquote><p><code>加载到内存中的运行时类，会缓存一定的时间。在此时间之内，我们可以通过不同的方式
    来获取此运行时类。</code></p><ul><li>获取Class类实例的四种方法 (获取的都是同一个运行时类) ：</li></ul><ol start='' ><li>前提：若已知具体的类，通过类的class属性获取，该方法最为安全可靠，程序性能最高。</li></ol><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n3555" mdtype="fences">Class&lt;Person&gt; clazz = Person.class;
System.out.println(clazz); // class JavaPackage_1.Person

</pre><ol start='2' ><li>前提：已知某个类的实例，调用该实例的getClass()方法获取Class对象。</li></ol><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n3559" mdtype="fences">Person person = new Person();
Class&lt;Person&gt; clazz = (Class&lt;Person&gt;) person.getClass();
System.out.println(clazz); // class JavaPackage_1.Person

</pre><ol start='3' ><li>前提：已知一个类的全类名，且该类在类路径下，可通过Class类的静态方法forName()获取，可能抛出ClassNotFoundException异常。</li></ol><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n3563" mdtype="fences">Class clazz = Class.forName("JavaPackage_1.Person");
System.out.println(clazz); // class JavaPackage_1.Person

</pre><ol start='4' ><li>使用类的加载器：ClassLoader   [了解]</li></ol><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n3567" mdtype="fences">ClassLoader classLoader = Javacode.class.getClassLoader();
Class clazz = classLoader.loadClass("JavaPackage_1.Person");
System.out.println(clazz); // class JavaPackage_1.Person

</pre><p><strong>哪些类型可以有Class对象？</strong></p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n3569" mdtype="fences">（1）class：外部类，成员(成员内部类，静态内部类)，局部内部类，匿名内部类
（2）interface：接口
（3）[]：数组
（4）enum：枚举
（5）annotation：注解@interface
（6）primitive type：基本数据类型
（7）void

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n3570" mdtype="fences" style="break-inside: unset;">Class c1 = Object.class;
Class c2 = Comparable.class;
Class c3 = String[].class;
Class c4 = int[][].class;
Class c5 = ElementType.class;
Class c6 = Override.class;
Class c7 = int.class;
Class c8 = void.class;
Class c9 = Class.class;
int[] a = new int[10];
int[] b = new int[100];
Class c10 = a.getClass();
Class c11 = b.getClass();
//只要元素类型与维度一样，就是同一个Class。
System.out.println(c10 == c11);

</pre><p><strong>类加载器</strong></p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n3572" mdtype="fences" style="break-inside: unset;">//对于自定义类，使用系统类加载器进行加载
ClassLoader classLoader = ClassLoaderTest.class.getClassLoader();
System.out.println(classLoader);
//调用系统类加载器的getParent()：获取扩展类加载器
ClassLoader classLoader1 = classLoader.getParent();
System.out.println(classLoader1);
//调用扩展类加载器的getParent()：无法获取引导类加载器
//引导类加载器主要负责加载java的核心类库，无法加载自定义类。
ClassLoader classLoader2 = classLoader1.getParent();
System.out.println(classLoader2);

ClassLoader classLoader3 = String.class.getClassLoader();
System.out.println(classLoader3);

</pre><p><strong>ClassLoder加载配置文件</strong></p><ul><li>方式一：配置文件默认在当前的module下。</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n3577" mdtype="fences">Properties pros =  new Properties();
FileInputStream fis = new FileInputStream("jdbc.properties");
FileInputStream fis = new FileInputStream("src\\jdbc1.properties");
pros.load(fis);
String user = pros.getProperty("user");
String password = pros.getProperty("password");
System.out.println("user = " + user + ",password = " + password);

</pre><ul><li>方式二：配置文件默认识别为：当前module的src下。</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n3581" mdtype="fences">Properties pros =  new Properties();
ClassLoader classLoader = ClassLoaderTest.class.getClassLoader();
InputStream is = classLoader.getResourceAsStream("jdbc1.properties");
pros.load(is);
String user = pros.getProperty("user");
String password = pros.getProperty("password");
System.out.println("user = " + user + ",password = " + password);

</pre><p><strong>反射创建运行时类的对象</strong></p><ul><li>newInstance()方法，创建对应的运行时类的对象。内部调用了运行时类的空参的构造器。</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n3586" mdtype="fences">要求：
	1.运行时类必须提供空参的构造器
	2.空参的构造器的访问权限得够。通常，设置为public。

在javabean中要求提供一个public的空参构造器。
原因：
	1.便于通过反射，创建运行时类的对象
	2.便于子类继承此运行时类时，默认调用super()时，保证父类有此构造器

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n3587" mdtype="fences">Class&lt;Person&gt; clazz = Person.class;
Person obj = clazz.newInstance();
System.out.println(obj); // Person{name='null', age=0}

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n3588" mdtype="fences">Class&lt;Person&gt; clazz = Person.class;
Person person = clazz.getDeclaredConstructor().newInstance();
System.out.println(person); // Person{name='null', age=0}

</pre><p><strong>理解反射的动态性</strong></p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n3590" mdtype="fences">public Object getInstance(String classPath) throws Exception {
   Class clazz =  Class.forName(classPath);
   return clazz.newInstance();
}

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n3591" mdtype="fences" style="break-inside: unset;">int num = new Random().nextInt(3);//0,1,2
String classPath = "";
switch(num){
    case 0:
        classPath = "java.util.Date";
        break;
    case 1:
        classPath = "java.lang.Object";
        break;
    case 2:
        classPath = "com.atguigu.java.Person";
        break;
}
try {
    Object obj = getInstance(classPath);
    System.out.println(obj);
} catch (Exception e) {
    e.printStackTrace();
}

</pre><p><strong>反射获取运行时类的完整结构</strong></p><p><code>构建结构丰富的Person类</code></p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n3594" mdtype="fences" style="break-inside: unset;">@Target({TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE})
@Retention(RetentionPolicy.RUNTIME)
@interface MyAnnotation {
        String value() default "hello";

}

class Creature&lt;T&gt; implements Serializable {
        private char gender;
        public double weight;

        private void breath(){
                System.out.println("生物呼吸");
        }

        public void eat(){
                System.out.println("生物吃东西");
        }
}

interface MyInterface {
        void info();
}

@MyAnnotation(value="hi")
class Person extends Creature&lt;String&gt; implements Comparable&lt;String&gt;,MyInterface{

        private String name;
        int age;
        public int id;

        public Person(){}

        @MyAnnotation(value="abc")
        private Person(String name){
                this.name = name;
        }

        Person(String name,int age){
                this.name = name;
                this.age = age;
        }
        @MyAnnotation
        private String show(String nation){
                System.out.println("我的国籍是：" + nation);
                return nation;
        }

        public String display(String interests,int age) throws NullPointerException,ClassCastException{
                return interests + age;
        }


        @Override
        public void info() {
                System.out.println("我是一个人");
        }

        @Override
        public int compareTo(String o) {
                return 0;
        }

        private static void showDesc(){
                System.out.println("我是一个可爱的人");
        }

        @Override
        public String toString() {
                return "Person{" +
                        "name='" + name + '\'' +
                        ", age=" + age +
                        ", id=" + id +
                        '}';
        }
}

</pre><ul><li>获取当前运行时类的属性结构：</li></ul><ol start='' ><li>getFields():获取当前运行时类及其父类中声明为public访问权限的属性</li></ol><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n3601" mdtype="fences">Class clazz = Person.class;
Field[] fields = clazz.getFields();
for(Field f : fields){
    System.out.println(f);
}

</pre><ol start='2' ><li>getDeclaredFields():获取当前运行时类中声明的所有属性。（不包含父类中声明的属性）</li></ol><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n3605" mdtype="fences">Class clazz = Person.class;
Field[] declaredFields = clazz.getDeclaredFields();
for(Field f : declaredFields){
    System.out.println(f);
}

</pre><ul><li>获取当前运行时类属性的权限修饰符 、数据类型、变量名</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n3609" mdtype="fences" style="break-inside: unset;">Class clazz = Person.class;
Field[] declaredFields = clazz.getDeclaredFields();
for(Field f : declaredFields){
    //1.权限修饰符
    int modifier = f.getModifiers();
    System.out.print(Modifier.toString(modifier) + "\t");
    //2.数据类型
    Class type = f.getType();
    System.out.print(type.getName() + "\t");
    //3.变量名
    String fName = f.getName();
    System.out.print(fName);
    System.out.println();
}

</pre><ul><li>获取当前运行时类的方法结构</li></ul><ol start='' ><li>getMethods():获取当前运行时类及其所有父类中声明为public权限的方法。</li></ol><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n3616" mdtype="fences">Method[] methods = clazz.getMethods();
for(Method m : methods){
    System.out.println(m);
}

</pre><ol start='2' ><li>getDeclaredMethods():获取当前运行时类中声明的所有方法。（不包含父类中声明的方法）</li></ol><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n3620" mdtype="fences">Method[] declaredMethods = clazz.getDeclaredMethods();
for(Method m : declaredMethods){
    System.out.println(m);
}

</pre><ul><li>获取当前运行时类方法的内部结构</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n3624" mdtype="fences" style="break-inside: unset;">Class clazz = Person.class;
Method[] declaredMethods = clazz.getDeclaredMethods();
for(Method m : declaredMethods){
        //1.获取方法声明的注解
        Annotation[] annos = m.getAnnotations();
        for(Annotation a : annos){
                System.out.println(a);
        }
        //2.权限修饰符
        System.out.print(Modifier.toString(m.getModifiers()) + "\t");
        //3.返回值类型
        System.out.print(m.getReturnType().getName() + "\t");
        //4.方法名
        System.out.print(m.getName());
        System.out.print("(");
        //5.形参列表
        Class[] parameterTypes = m.getParameterTypes();
        if(!(parameterTypes == null &amp;&amp; parameterTypes.length == 0)){
                for(int i = 0;i &lt; parameterTypes.length;i++){
                        if(i == parameterTypes.length - 1){
                                System.out.print(parameterTypes[i].getName() + " args_" + i);
                                break;
                        }
                        System.out.print(parameterTypes[i].getName() + " args_" + i + ",");
                }
        }
        System.out.print(")");
        //6.抛出的异常
        Class[] exceptionTypes = m.getExceptionTypes();
        if(exceptionTypes.length &gt; 0){
                System.out.print("throws ");
                for(int i = 0;i &lt; exceptionTypes.length;i++){
                        if(i == exceptionTypes.length - 1){
                                System.out.print(exceptionTypes[i].getName());
                                break;
                        }
                        System.out.print(exceptionTypes[i].getName() + ",");
                }
        }
        System.out.println();
}

</pre><ul><li>获取当前运行时类的构造器结构</li></ul><ol start='' ><li>getConstructors():获取当前运行时类中声明为public的构造器。</li><li>getDeclaredConstructors():获取当前运行时类中声明的所有的构造器。</li></ol><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n3633" mdtype="fences">Class clazz = Person.class;
Constructor[] constructors = clazz.getConstructors();
for(Constructor c : constructors){
    System.out.println(c);
}

Constructor[] declaredConstructors = clazz.getDeclaredConstructors();
for(Constructor c : declaredConstructors){
    System.out.println(c);
}

</pre><ul><li>获取当前运行时类的父类</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n3637" mdtype="fences">Class clazz = Person.class;
Class superclass = clazz.getSuperclass();
System.out.println(superclass);

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n3638" mdtype="fences">//获取运行时类的带泛型的父类
Class clazz = Person.class;
Type genericSuperclass = clazz.getGenericSuperclass();
System.out.println(genericSuperclass);

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n3639" mdtype="fences">//获取运行时类的带泛型的父类的泛型
Class clazz = Person.class;
Type genericSuperclass = clazz.getGenericSuperclass();
ParameterizedType paramType = (ParameterizedType) genericSuperclass;
//获取泛型类型
Type[] actualTypeArguments = paramType.getActualTypeArguments();
System.out.println(actualTypeArguments[0].getTypeName());
System.out.println(((Class)actualTypeArguments[0]).getName());

</pre><ul><li>获取当前运行时类实现的接口</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n3643" mdtype="fences">Class clazz = Person.class;
Class[] interfaces = clazz.getInterfaces();
for(Class c : interfaces){
    System.out.println(c);
}

//获取运行时类的父类实现的接口
Class[] interfaces1 = clazz.getSuperclass().getInterfaces();
for(Class c : interfaces1){
    System.out.println(c);
}

</pre><ul><li>获取当前运行时类所在的包</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n3647" mdtype="fences">Class clazz = Person.class;
Package pack = clazz.getPackage();
System.out.println(pack);

</pre><ul><li>获取当前运行时类声明的注解</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n3651" mdtype="fences">Class clazz = Person.class;
Annotation[] annotations = clazz.getAnnotations();
for(Annotation annos : annotations){
    System.out.println(annos);
}

</pre><p><strong>调用运行时类的指定结构</strong></p><ul><li>调用当前运行时类的指定属性</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n3656" mdtype="fences">Class clazz = Person.class;
//创建运行时类的对象
Person p = (Person) clazz.newInstance();
//获取指定的属性：要求运行时类中属性声明为public
Field id = clazz.getField("id");
//set():参数1：指明设置哪个对象的属性   参数2：将此属性值设置为多少
id.set(p,1001);
//get():参数1：获取哪个对象的当前属性值
int pId = (int) id.get(p);
System.out.println(pId);

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n3657" mdtype="fences">Class clazz = Person.class;
//创建运行时类的对象
Person p = (Person) clazz.newInstance();
//1. getDeclaredField(String fieldName):获取运行时类中指定变量名的属性
Field name = clazz.getDeclaredField("name");
//2.保证当前属性是可访问的
name.setAccessible(true);
//3.获取、设置指定对象的此属性值
name.set(p,"Tom");
System.out.println(name.get(p));

</pre><ul><li>调用当前运行时类的指定方法</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n3661" mdtype="fences">Class clazz = Person.class;
//创建运行时类的对象
Person p = (Person) clazz.newInstance();
//1.获取指定的某个方法
//getDeclaredMethod():参数1 ：指明获取的方法的名称  参数2：指明获取的方法的形参列表
Method show = clazz.getDeclaredMethod("show", String.class);
//2.保证当前方法是可访问的
show.setAccessible(true);
//3.调用方法的invoke():参数1：方法的调用者  参数2：给方法形参赋值的实参
//  invoke()的返回值即为对应类中调用的方法的返回值。
Object returnValue = show.invoke(p,"CHN"); //String nation = p.show("CHN");
System.out.println(returnValue);

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n3662" mdtype="fences">//调用静态方法
Method showDesc = clazz.getDeclaredMethod("showDesc");
showDesc.setAccessible(true);
//如果调用的运行时类中的方法没有返回值，则此invoke()返回null
//Object returnVal = showDesc.invoke(null);
Object returnVal = showDesc.invoke(Person.class);
System.out.println(returnVal);//null

</pre><ul><li>调用当前运行时类的指定构造器</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n3666" mdtype="fences">Class clazz = Person.class;
//private Person(String name)
//1.获取指定的构造器
//getDeclaredConstructor():参数：指明构造器的参数列表
Constructor constructor = clazz.getDeclaredConstructor(String.class);
//2.保证此构造器是可访问的
constructor.setAccessible(true);
//3.调用此构造器创建运行时类的对象
Person per = (Person) constructor.newInstance("Tom");
System.out.println(per);

</pre><h2><a name='header-n3667' class='md-header-anchor '></a>115. 代理模式与动态代理</h2><ul><li>代理设计模式的原理: 
使用一个代理将对象包装起来, 然后用该代理对象取代原始对象。任何对原
始对象的调用都要通过代理。代理对象决定是否以及何时将方法调用转到原
始对象上。</li><li>动态代理相比于静态代理的优点：
抽象角色中（接口）声明的所有方法都被转移到调用处理器一个集中的方法中
处理，这样，我们可以更加灵活和统一的处理众多的方法。</li><li>静态代理举例：</li><li>代理类和被代理类在编译期间确定</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n3677" mdtype="fences" style="break-inside: unset;">interface ClothFactory{
        void produceCloth();
}

//代理类
class ProxyClothFactory implements ClothFactory{
        private ClothFactory factory;//用被代理类对象进行实例化
        public ProxyClothFactory(ClothFactory factory){
                this.factory = factory;
        }
        @Override
        public void produceCloth() {
                System.out.println("代理工厂做一些准备工作...");
                factory.produceCloth();
                System.out.println("代理工厂做一些后续工作...");
        }
}

//被代理类
class NikeClothFactory implements ClothFactory{
        @Override
        public void produceCloth() {
                System.out.println("Nike工厂生产一批运动服");
        }
}

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n3678" mdtype="fences">//创建被代理类的对象
NikeClothFactory nikeClothFactory = new NikeClothFactory();
//创建代理类的对象
ProxyClothFactory proxyClothFactory = new ProxyClothFactory(nikeClothFactory);
proxyClothFactory.produceCloth();
/**
 * 代理工厂做一些准备工作...
 * Nike工厂生产一批运动服
 * 代理工厂做一些后续工作...
 */

</pre><ul><li>动态代理：</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n3682" mdtype="fences">* 没有在编译时期显式的定义代理类
* 而是在运行的时候根据传进来的被代理类的对象，动态的创建代理类，这体现了反射的动态性

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n3683" mdtype="fences" style="break-inside: unset;">//抽象主题类
interface Human{
        String getBelief();
        void eat(String food);
}

//被代理类
class SuperMan implements Human{
        @Override
        public String getBelief() {
                return "I believe I can fly!";
        }
        @Override
        public void eat(String food) {
                System.out.println("我喜欢吃" + food);
        }
}

/**
动态代理需要解决的问题：
        问题一：如何根据加载到内存中的被代理类，动态的创建一个代理类及其对象。
        问题二：当通过代理类的对象调用方法a时，如何动态的去调用被代理类中的同名方法a。
 */
 
class ProxyFactory{
        //调用此方法，返回一个代理类的对象。解决问题一
        public static Object getProxyInstance(Object obj){//obj:被代理类的对象
                MyInvocationHandler handler = new MyInvocationHandler();
                handler.bind(obj);
                return Proxy.newProxyInstance(obj.getClass().getClassLoader(),obj.getClass().getInterfaces(),handler);
        }
}

class MyInvocationHandler implements InvocationHandler{
        private Object obj;//需要使用被代理类的对象进行赋值
        public void bind(Object obj){
                this.obj = obj;
        }
        //当我们通过代理类的对象，调用方法a时，就会自动的调用如下的方法：invoke()
        //将被代理类要执行的方法a的功能就声明在invoke()中
        @Override
        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                //method:即为代理类对象调用的方法，此方法也就作为了被代理类对象要调用的方法
                //obj:被代理类的对象
                Object returnValue = method.invoke(obj,args);
                //上述方法的返回值就作为当前类中的invoke()的返回值。
                return returnValue;
        }
}

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n3684" mdtype="fences">SuperMan superMan = new SuperMan();
//proxyInstance:代理类的对象
Human proxyInstance = (Human) ProxyFactory.getProxyInstance(superMan);
//当通过代理类对象调用方法时，会自动的调用被代理类中同名的方法
String belief = proxyInstance.getBelief();
System.out.println(belief); // I believe I can fly!
proxyInstance.eat("四川麻辣烫"); // 我喜欢吃四川麻辣烫

</pre><ul><li><p>AOP代理：
AOP代理可代替目标对象，AOP代理包含了目标对象的全部方法。
AOP代理中的方法与目标对象的方法存在差异：</p><ul><li>AOP代理里的方法可以在执行目标方法之前、之后插入一些通用处理。</li></ul></li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n3691" mdtype="fences" style="break-inside: unset;">class MyInvocationHandler implements InvocationHandler{
        private Object obj;//需要使用被代理类的对象进行赋值
        public void bind(Object obj){
                this.obj = obj;
        }
        //当我们通过代理类的对象，调用方法a时，就会自动的调用如下的方法：invoke()
        //将被代理类要执行的方法a的功能就声明在invoke()中
        @Override
        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                HumanUtil util = new HumanUtil();
                util.method1();
                //method:即为代理类对象调用的方法，此方法也就作为了被代理类对象要调用的方法
                //obj:被代理类的对象
                Object returnValue = method.invoke(obj,args);
                util.method2();
                //上述方法的返回值就作为当前类中的invoke()的返回值。
                return returnValue;
        }
}

class HumanUtil{
        public void method1(){
                System.out.println("通用方法1...");
        }
        public void method2(){
                System.out.println("通用方法2...");
        }
}

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n3692" mdtype="fences">SuperMan superMan = new SuperMan();
//proxyInstance:代理类的对象
Human proxyInstance = (Human) ProxyFactory.getProxyInstance(superMan);
//当通过代理类对象调用方法时，会自动的调用被代理类中同名的方法
proxyInstance.eat("Fruit"); // 我喜欢吃Fruit
/*
通用方法1...
我喜欢吃Fruit
通用方法2...
 */

</pre><h2><a name='header-n3693' class='md-header-anchor '></a>116. Lambda表达式</h2><ul><li>冗余的Runnable代码</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n3697" mdtype="fences" style="break-inside: unset;">//创建Runnable接口的实现类 重写run方法 设置线程任务
public class RunnableImpl implements Runnable{
    @Override
    public void run() {
        System.out.println(Thread.currentThread().getName()+"新线程创建执行");
    }
}
public static void main(String[] args) {
    //创建Runnable接口的实现类对象
    RunnableImpl run = new RunnableImpl();
    //创建Thread类对象 构造方法中传递Runnable接口的实现类
    Thread t = new Thread(run);
    //调用start方法开启新线程 执行run方法
    t.start();
}

</pre><ul><li>代码简化</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n3701" mdtype="fences">//简化代码 使用匿名内部类 实现多线程程序
Runnable r = new Runnable() {
    @Override
    public void run() {
        System.out.println(Thread.currentThread().getName()+"新线程创建执行");
    }
};
new Thread(r).start();       

</pre><ul><li>代码简化</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n3705" mdtype="fences">//简化代码
new Thread(new Runnable() {
    @Override
    public void run() {
        System.out.println(Thread.currentThread().getName()+"新线程创建执行");
    }
}).start();

</pre><ul><li>Lambda表达式代码简化</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n3709" mdtype="fences">new Thread(()-&gt;{
        System.out.println(Thread.currentThread().getName()+"新线程创建执行");
    }
).start();

</pre><ul><li>Lambda表达式的格式</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n3713" mdtype="fences">(参数列表)-&gt;{一些重写方法的代码}：

	() 接口中抽象方法的参数列表 没有参数空着 有参数写参数 多个参数逗号分隔
	-&gt; 把参数传递给方法体
	{} 重写接口抽象方法的方法体，（接口中只能有一个抽象方法）

</pre><ul><li>Lambda表达式的使用</li></ul><ol start='' ><li>无参数，无返回值：</li></ol><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n3720" mdtype="fences">Runnable r1 = new Runnable() {
    @Override
    public void run() {
        System.out.println("成功执行！");
    }
};
r1.run();

</pre><p><code>//Lambda表达式改进</code></p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n3722" mdtype="fences">Runnable r2 = () -&gt; {
    System.out.println("成功执行！");
};
r2.run();

</pre><ol start='2' ><li>有参数，无返回值：</li></ol><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n3726" mdtype="fences">Consumer&lt;String&gt; consumer = new Consumer&lt;String&gt;() {
    @Override
    public void accept(String s) {
        System.out.println(s);
    }
};
consumer.accept("成功执行！");

</pre><p><code>//Lambda表达式改进</code></p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n3728" mdtype="fences">Consumer&lt;String&gt; consumer = (String s) -&gt; {
    System.out.println(s);
};
consumer.accept("成功执行！");

</pre><p><code>//类型推断</code></p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n3730" mdtype="fences">Consumer&lt;String&gt; consumer = (s) -&gt; {
    System.out.println(s);
};
consumer.accept("成功执行！");

</pre><p><code>//只有一个参数</code></p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n3732" mdtype="fences">Consumer&lt;String&gt; consumer = s -&gt; {
    System.out.println(s);
};
consumer.accept("成功执行！");

</pre><ol start='3' ><li>多个参数，多条语句，有返回值</li></ol><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n3736" mdtype="fences">Comparator&lt;Integer&gt; com1 = new Comparator&lt;Integer&gt;() {
    @Override
    public int compare(Integer o1, Integer o2) {
        System.out.println(o1);
        System.out.println(o2);
        return o1.compareTo(o2);
    }
};
System.out.println(com1.compare(12,21));

</pre><p><code>//Lambda表达式改进</code></p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n3738" mdtype="fences">Comparator&lt;Integer&gt; com2 = (o1,o2) -&gt; {
    System.out.println(o1);
    System.out.println(o2);
    return o1.compareTo(o2);
};
System.out.println(com2.compare(12,6));

</pre><ol start='4' ><li>只有一条执行语句
<code>//若有返回值，则return也可省略</code></li></ol><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n3742" mdtype="fences">Comparator&lt;Integer&gt; com1 = (o1,o2) -&gt; {
    return o1.compareTo(o2);
};
System.out.println(com1.compare(12,6));

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n3743" mdtype="fences">Comparator&lt;Integer&gt; com2 = (o1,o2) -&gt; o1.compareTo(o2);
System.out.println(com2.compare(12,21));

</pre><h2><a name='header-n3744' class='md-header-anchor '></a>117. 函数式接口</h2><ul><li>一个接口中，只声明了一个抽象方法，则此接口就称为函数式接口。</li><li>可以在接口上使用 @FunctionalInterface 注解，检查是否为函数式接口。</li><li>四大核心接口： </li></ul><ol start='' ><li>消费型接口 Consumer<T>     void accept(T t) 对类型为T的对象应用操作</li><li>供给型接口 Supplier<T>     T get() 返回类型为T的对象</li><li>函数型接口 Function&lt;T,R&gt;   R apply(T t) 对类型为T的对象应用操作，并返回结果。结果是R类型的对象。</li><li>断定型接口 Predicate<T>    boolean test(T t) 确定类型为T的对象是否满足某约束，并返回boolean 值。</li></ol><ul><li>其他函数式接口：</li></ul><blockquote><p>BiFunction&lt;T, U, R&gt;：对类型为 T, U 参数应用操作，返回 R 类型的结果。包含方法为： R apply(T t, U u);
UnaryOperator&lt; T &gt;(Function子接口)：对类型为T的对象进行一元运算，并返回T类型的
结果。包含方法为：T apply(T t);
BinaryOperator&lt; T &gt;(BiFunction 子接口)：对类型为T的对象进行二元运算，并返回T类型的
结果。包含方法为： T apply(T t1, T t2);
BiConsumer&lt;T, U&gt;：对类型为T, U 参数应用操作。包含方法为： void accept(T t, U u);
BiPredicate&lt;T,U&gt; ：包含方法为： boolean test(T t,U u)；
ToIntFunction&lt; T &gt;、ToLongFunction&lt; T &gt;、ToDoubleFunction&lt; T &gt; ：分别计算int、long、double值的函数；
IntFunction&lt; R &gt;、LongFunction&lt; R &gt;、DoubleFunction&lt; R &gt;：参数分别为int、long、double 类型的函数；</p></blockquote><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n3766" mdtype="fences">public void happyTime(double money, Consumer&lt;Double&gt; con){
    con.accept(money);
}

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n3767" mdtype="fences">happyTime(500, new Consumer&lt;Double&gt;() {
    @Override
    public void accept(Double aDouble) {
        System.out.println("成功执行 -&gt; " + aDouble);
    }
});

happyTime(400,money -&gt; System.out.println("成功执行 -&gt; " + money));

</pre><p><code>//根据给定的规则，过滤集合中的字符串。此规则由Predicate的方法决定</code></p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n3769" mdtype="fences">public List&lt;String&gt; filterString(List&lt;String&gt; list, Predicate&lt;String&gt; pre){
    ArrayList&lt;String&gt; filterList = new ArrayList&lt;&gt;();
    for(String s : list){
        if(pre.test(s)){
            filterList.add(s);
        }
    }
    return filterList;
}

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n3770" mdtype="fences">List&lt;String&gt; list = Arrays.asList("北京","南京","天津","东京","西京","普京");
List&lt;String&gt; filterStrs = filterString(list, new Predicate&lt;String&gt;() {
    @Override
    public boolean test(String s) {
        return s.contains("京");
    }
});
System.out.println(filterStrs);

List&lt;String&gt; filterStrs1 = filterString(list,s -&gt; s.contains("京"));
System.out.println(filterStrs1);

</pre><ul><li>自定义函数式接口</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n3774" mdtype="fences">@FunctionalInterface
interface Func1{
    public int getInt();
}

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n3775" mdtype="fences">@FunctionalInterface
interface Func2&lt;T&gt;{
    public T getT(T t);
}

</pre><h2><a name='header-n3776' class='md-header-anchor '></a>118. 方法引用与构造器引用</h2><ul><li>方法引用：</li><li>使用：当要传递给Lambda体的操作，已经有实现的方法，可以使用方法引用！</li><li>本质上就是Lambda表达式，而Lambda表达式作为函数式接口的实例。</li></ul><ol start='' ><li>对象 :: 非静态方法</li></ol><p><code>要求：要求接口中的抽象方法的形参列表和返回值类型与方法引用的方法的形参列表和返回值类型相同！</code></p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n3788" mdtype="fences">Consumer&lt;String&gt; consumer = str -&gt; System.out.println(str);
consumer.accept("成功执行！");

//Consumer中的void accept(T t)
//PrintStream中的void println(T t)
PrintStream ps = System.out;
Consumer&lt;String&gt; consumer = ps::println;
consumer.accept("成功执行！");

</pre><ol start='2' ><li>类 :: 静态方法</li></ol><p><code>要求：要求接口中的抽象方法的形参列表和返回值类型与方法引用的方法的形参列表和返回值类型相同！</code></p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n3793" mdtype="fences">Comparator&lt;Integer&gt; com1 = (t1,t2) -&gt; Integer.compare(t1,t2);
System.out.println(com1.compare(12,21));

//Comparator中的int compare(T t1,T t2)
//Integer中的int compare(T t1,T t2)
Comparator&lt;Integer&gt; com2 = Integer::compare;
System.out.println(com2.compare(12,3));

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n3794" mdtype="fences">Function&lt;Double,Long&gt; func1 = d -&gt; Math.round(d);
System.out.println(func1.apply(12.3));

//Function中的R apply(T t)
//Math中的Long round(Double d)
Function&lt;Double,Long&gt; func2 = Math::round;
System.out.println(func2.apply(12.6));

</pre><ol start='3' ><li>类 :: 实例方法</li></ol><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n3798" mdtype="fences">Comparator&lt;String&gt; com1 = (s1,s2) -&gt; s1.compareTo(s2);
System.out.println(com1.compare("abc","abd"));

// Comparator中的int comapre(T t1,T t2)
// String中的int t1.compareTo(t2)
Comparator&lt;String&gt; com2 = String :: compareTo;
System.out.println(com2.compare("abd","abm"));

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n3799" mdtype="fences">BiPredicate&lt;String,String&gt; pre1 = (s1,s2) -&gt; s1.equals(s2);
System.out.println(pre1.test("abc","abc"));

//BiPredicate中的boolean test(T t1, T t2);
//String中的boolean t1.equals(t2)
BiPredicate&lt;String,String&gt; pre2 = String :: equals;
System.out.println(pre2.test("abc","abd"));

</pre><ul><li>构造器引用：</li><li>函数式接口的抽象方法的形参列表和构造器的形参列表一致。</li><li>抽象方法的返回值类型即为构造器所属的类的类型。</li></ul><p><code>空参数</code></p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n3808" mdtype="fences" style="break-inside: unset;">Supplier&lt;Employee&gt; sup = new Supplier&lt;Employee&gt;() {
    @Override
    public Employee get() {
        return new Employee();
    }
};

Supplier&lt;Employee&gt;  sup1 = () -&gt; new Employee();
System.out.println(sup1.get());

//Supplier中的T get()
//Employee的空参构造器：Employee()
Supplier&lt;Employee&gt;  sup2 = Employee :: new;
System.out.println(sup2.get());

</pre><p><code>一个参数</code></p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n3810" mdtype="fences">Function&lt;Integer,Employee&gt; func1 = id -&gt; new Employee(id);
Employee employee = func1.apply(1001);
System.out.println(employee);

//Function中的R apply(T t)
Function&lt;Integer,Employee&gt; func2 = Employee :: new;
Employee employee1 = func2.apply(1002);
System.out.println(employee1);

</pre><p><code>二个参数</code></p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n3812" mdtype="fences">BiFunction&lt;Integer,String,Employee&gt; func1 = (id,name) -&gt; new Employee(id,name);
System.out.println(func1.apply(1001,"Tom"));

//BiFunction中的R apply(T t,U u)
BiFunction&lt;Integer,String,Employee&gt; func2 = Employee :: new;
System.out.println(func2.apply(1002,"Tom"));

</pre><ul><li>数组引用：</li><li>把数组看做是一个特殊的类，则写法与构造器引用一致。</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n3818" mdtype="fences">Function&lt;Integer,String[]&gt; func1 = length -&gt; new String[length];
String[] arr1 = func1.apply(5);
System.out.println(Arrays.toString(arr1));

//Function中的R apply(T t)
Function&lt;Integer,String[]&gt; func2 = String[] :: new;
String[] arr2 = func2.apply(10);
System.out.println(Arrays.toString(arr2));

</pre><h2><a name='header-n3819' class='md-header-anchor '></a>119. Stream流</h2><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n3820" mdtype="fences"> * ①Stream 自己不会存储元素。
 * ②Stream 不会改变源对象。相反，他们会返回一个持有结果的新Stream。
 * ③Stream 操作是延迟执行的。这意味着他们会等到需要结果的时候才执行
 *
 * 说明：
 *     一个中间操作链，对数据源的数据进行处理
 *     一旦执行终止操作，就执行中间操作链，并产生结果。之后，不会再被使用

</pre><ul><li>创建Stream流</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n3824" mdtype="fences" style="break-inside: unset;">//通过集合创建Stream
List&lt;Integer&gt; list = new ArrayList&lt;&gt;();
list.add(1);
list.add(2);
list.add(3);
System.out.println(list);
Stream&lt;Integer&gt; stream = list.stream(); // 顺序流
Stream&lt;Integer&gt; parallelStream = list.parallelStream(); // 并行流


//通过数组创建Stream
int[] arr = new int[]{1,2,3,4,5,6};
//调用Arrays类的static &lt;T&gt; Stream&lt;T&gt; stream(T[] array): 返回一个流
IntStream stream = Arrays.stream(arr);


//通过Stream的of()创建Stream
Stream&lt;Integer&gt; stream = Stream.of(1, 2, 3, 4, 5, 6);


//创建无限流Stream
//1.迭代：public static&lt;T&gt; Stream&lt;T&gt; iterate(final T seed, final UnaryOperator&lt;T&gt; f)
Stream.iterate(0, t -&gt; t + 2).limit(10).forEach(System.out::println); // 遍历前10个偶数

//2.生成：public static&lt;T&gt; Stream&lt;T&gt; generate(Supplier&lt;T&gt; s)
Stream.generate(Math::random).limit(10).forEach(System.out::println);

</pre><ul><li>中间操作：</li></ul><p><code>筛选与切片：</code>
<span>		</span></p><ol start='' ><li>filter(Predicate p)——接收 Lambda ， 从流中排除某些元素。</li><li>limit(n)——截断流，使其元素不超过给定数量。</li><li>skip(n) —— 跳过元素，返回一个扔掉了前 n 个元素的流。若流中元素不足 n 个，则返回一个空流。与 limit(n) 互补。</li><li>distinct()——筛选，通过流所生成元素的 hashCode() 和 equals() 去除重复元素。</li></ol><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n3838" mdtype="fences">//通过集合创建Stream
List&lt;Integer&gt; list = new ArrayList&lt;&gt;();
list.add(1);
list.add(2);
list.add(3);
list.add(3);
System.out.println(list);
Stream&lt;Integer&gt; stream = list.stream(); // 顺序流
stream.filter(integer -&gt; integer &gt;= 2).forEach(System.out::println); // 2 3 3
stream.limit(3).forEach(System.out::println); // 1 2 3
stream.distinct().forEach(System.out::println); // 1 2 3
stream.skip(2).forEach(System.out::println); // 3 3

</pre><p><code>映射：</code></p><ol start='' ><li>map(Function f)——接收一个函数作为参数，将元素转换成其他形式或提取信息，该函数会被应用到每个元素上，并将其映射成一个新的元素。</li><li>flatMap(Function f)——接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连接成一个流。</li></ol><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n3845" mdtype="fences" style="break-inside: unset;">public class JavaCode {
    public static void main(String[] args) {
 
        List&lt;String&gt; list = Arrays.asList("aa", "bb", "cc", "dd");
        list.stream().map(str -&gt; str.toUpperCase()).forEach(System.out::println); // AA BB CC DD
        
        Stream&lt;Stream&lt;Character&gt;&gt; streamStream = list.stream().map(JavaCode::fromStringToStream);
        streamStream.forEach(s -&gt;{
            s.forEach(System.out::println);
        }); // a a b b c c d d

        Stream&lt;Character&gt; characterStream = list.stream().flatMap(JavaCode::fromStringToStream);
        characterStream.forEach(System.out::println);

    }

    //将字符串中的多个字符构成的集合转换为对应的Stream的实例
    public static Stream&lt;Character&gt; fromStringToStream(String str){//aa
        ArrayList&lt;Character&gt; list = new ArrayList&lt;&gt;();
        for(Character c : str.toCharArray()){
            list.add(c);
        }
        return list.stream();
    }
}

</pre><p><code>排序：</code></p><ol start='' ><li>sorted()——自然排序</li><li>orted(Comparator com)——定制排序</li></ol><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n3852" mdtype="fences">List&lt;Integer&gt; list = Arrays.asList(12, 43, 65, 34, 87, 0, -98, 7);
//自然排序
list.stream().sorted().forEach(System.out::println);
//定制排序
list.stream().sorted((e1,e2) -&gt; -Integer.compare(e1,e2)).forEach(System.out::println);

</pre><ul><li>终止操作：</li></ul><p><code>匹配与查找：</code></p><ol start='' ><li>allMatch(Predicate p)——检查是否匹配所有元素。</li><li>anyMatch(Predicate p)——检查是否至少匹配一个元素。</li><li>noneMatch(Predicate p)——检查是否没有匹配的元素。</li><li>findFirst——返回第一个元素。</li><li>findAny——返回当前流中的任意元素。</li><li>count——返回流中元素的总个数。</li><li>max(Comparator c)——返回流中最大值。</li><li>min(Comparator c)——返回流中最小值。</li><li>forEach(Consumer c)——内部迭代。</li></ol><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n3876" mdtype="fences" style="break-inside: unset;">List&lt;Integer&gt; list = Arrays.asList(12, 43, 65, 34, 87, 0, -98, 7);
boolean allMatch = list.stream().allMatch(e -&gt; e &gt; 18);
System.out.println(allMatch); // false
boolean anyMatch = list.stream().anyMatch(e -&gt; e &gt; 10);
System.out.println(anyMatch); // true
boolean noneMatch = list.stream().noneMatch(e -&gt; e == 0);
System.out.println(noneMatch); // false
Optional&lt;Integer&gt; first = list.stream().findFirst();
System.out.println(first); // Optional[12]
Optional&lt;Integer&gt; any = list.parallelStream().findAny();
System.out.println(any); // Optional[0]
long count = list.stream().filter(integer -&gt; integer &gt; 20).count();
System.out.println(count); // 4
Optional&lt;Integer&gt; max = list.stream().max(Integer::compareTo);
System.out.println(max); // Optional[87]
Optional&lt;Integer&gt; min = list.stream().min(Integer::compareTo);
System.out.println(min); // Optional[-98]
//集合遍历
list.stream().forEach(System.out::println);

</pre><p><code>规约：</code></p><ol start='' ><li>reduce(T identity, BinaryOperator)——可以将流中元素反复结合起来，得到一个值。返回 T。</li><li>reduce(BinaryOperator) ——可以将流中元素反复结合起来，得到一个值。返回 Optional<T>。</li></ol><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n3883" mdtype="fences">List&lt;Integer&gt; list = Arrays.asList(12, 43, 65, 34, 87, 0, -98, 7);
Integer sum = list.stream().reduce(10, Integer::sum); // 初始值，求和
System.out.println(sum); // 160
Optional&lt;Integer&gt; reduce = list.stream().reduce(Integer::sum);
System.out.println(reduce); // Optional[150]

</pre><p> <code>收集：</code></p><ol start='' ><li>collect(Collector c)——将流转换为其他形式。接收一个 Collector接口的实现，用于给Stream中元素做汇总的方法。</li></ol><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n3888" mdtype="fences">List&lt;Integer&gt; list = Arrays.asList(12, 43, 65, 34, 87, 0, -98, 7);
List&lt;Integer&gt; collect = list.stream().filter(integer -&gt; integer &gt; 20).collect(Collectors.toList());
collect.forEach(System.out::println); // 43 65 34 87

</pre><h2><a name='header-n3889' class='md-header-anchor '></a>120. Stream API : Collectors</h2><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n3890" mdtype="fences" style="break-inside: unset;">方法 toList 
返回 List&lt;T&gt;
作用 把流中元素收集到List
使用 List&lt;T&gt; list= list.stream().collect(Collectors.toList());

方法 toSet 
返回 Set&lt;T&gt; 
作用 把流中元素收集到Set
使用 Set&lt;Employee&gt; emps= list.stream().collect(Collectors.toSet());

方法 toCollection 
返回 Collection&lt;T&gt; 
作用 把流中元素收集到创建的集合
使用 Collection&lt;Employee&gt; emps =list.stream().collect(Collectors.toCollection(ArrayList::new));

方法 counting 
返回 Long 
作用 计算流中元素的个数
使用 long count = list.stream().collect(Collectors.counting());

方法 summingInt 
返回 Integer 
作用 对流中元素的整数属性求和
使用 int total=list.stream().collect(Collectors.summingInt(Employee::getSalary));

方法 averagingInt 
返回 Double 
作用 计算流中元素Integer属性的平均值
使用 double avg = list.stream().collect(Collectors.averagingInt(Employee::getSalary));

方法 summarizingInt 
返回 IntSummaryStatistics 
作用 收集流中Integer属性的统计值。如：平均值
使用 int SummaryStatisticsiss= list.stream().collect(Collectors.summarizingInt(Employee::getSalary));

方法 joining 
返回 String 
作用 连接流中每个字符串
使用 String str= list.stream().map(Employee::getName).collect(Collectors.joining());

方法 maxBy 
返回 Optional&lt;T&gt; 
作用 根据比较器选择最大值
使用 Optional&lt;Emp&gt;max= list.stream().collect(Collectors.maxBy(comparingInt(Employee::getSalary)));

方法 minBy 
返回 Optional&lt;T&gt; 
作用 根据比较器选择最小值
使用 Optional&lt;Emp&gt; min = list.stream().collect(Collectors.minBy(comparingInt(Employee::getSalary)));

方法 reducing 
返回 归约产生的类型
作用 从一个作为累加器的初始值开始，利用BinaryOperator与流中元素逐个结合，从而归约成单个值
使用 int total=list.stream().collect(Collectors.reducing(0, Employee::getSalar, Integer::sum));

方法 collectingAndThen 
返回 转换函数返回的类型 
作用 包裹另一个收集器，对其结果转换函数
使用 int how= list.stream().collect(Collectors.collectingAndThen(Collectors.toList(), List::size));

方法 groupingBy 
返回 Map&lt;K, List&lt;T&gt;&gt; 
作用 根据某属性值对流分组，属性为K，结果为V
使用 Map&lt;Emp.Status, List&lt;Emp&gt;&gt; map= list.stream().collect(Collectors.groupingBy(Employee::getStatus));

方法 partitioningBy 
返回 Map&lt;Boolean, List&lt;T&gt;&gt; 
作用 根据true或false进行分区
使用 Map&lt;Boolean,List&lt;Emp&gt;&gt; vd = list.stream().collect(Collectors.partitioningBy(Employee::getManage));

</pre><ul><li>Java9的加强</li></ul><ol start='' ><li>takeWhile 返回从开头开始的按照指定规则尽量多的元素。</li><li>dropWhile():与 takeWhile 相反，返回剩余的元素。</li></ol><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n3899" mdtype="fences">List&lt;Integer&gt; list = Arrays.asList(23, 43, 45, 55, 61, 54, 32, 2, 45, 89, 7);
//takeWhile 返回从开头开始的按照指定规则尽量多的元素
list.stream().takeWhile(x -&gt; x &lt; 60).forEach(System.out::println); // 23 43 45 55
//dropWhile():与 takeWhile 相反，返回剩余的元素。
list.stream().dropWhile(x -&gt; x &lt; 60).forEach(System.out::println);

</pre><ol start='3' ><li>of()参数中的多个元素，可以包含null值。</li><li>ofNullable()：形参变量是可以为null值的单个元素。</li></ol><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n3905" mdtype="fences">//of()参数中的多个元素，可以包含null值
Stream&lt;Integer&gt; stream1 = Stream.of(1, 2, 3,null);
stream1.forEach(System.out::println); // 1 2 3 null
//of()参数不能存储单个null值。否则，报异常
Integer i = 10;
i = null;
//ofNullable()：形参变量是可以为null值的单个元素
Stream&lt;Integer&gt; stream3 = Stream.ofNullable(i);
long count = stream3.count();
System.out.println(count); // 0

</pre><ol start='5' ><li>新增的重载的方法：iterate()</li></ol><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n3909" mdtype="fences">Stream.iterate(0,x -&gt; x + 1).limit(10).forEach(System.out::println);
Stream.iterate(0,x -&gt; x &lt; 10,x -&gt; x + 1).forEach(System.out::println);

</pre><h2><a name='header-n3910' class='md-header-anchor '></a>121. Properties</h2><ul><li><p>Properties集合存储数据：</p><ol start='' ><li>java.util.Properties集合 extends Hashtable&lt;k,v&gt; implements Map&lt;k,v&gt;</li><li>Properties类表示了一个持久的属性集 Properties可保存在流中或从流中加载</li><li>Properties集合是唯一一个和IO流相结合的集合
1.可以使用Properties集合中的方法store 把集合中的临时数据 持久化写入到硬盘中存储
<span>	</span>2.可以使用Properties集合中的方法load 把硬盘中保存的文件(键值对)读取到集合中使用</li><li>Properties集合是一个双列集合 key和value默认都是字符串</li><li>使用Properties集合存储数据 遍历取出Properties集合中的数据</li></ol><ul><li>Properties集合是一个双列集合 key和value默认都是字符串</li><li>Properties集合有提携操作字符串的特有方法</li><li>Object setProperty(String key,String value) 调用Hashtable的方法put</li><li>String getProperty(String key) 通过key找value 此方法相当于Map集合中的get(key)方法</li><li>Set<String> stringPropertyNames() 返回此属性列表中的键集 其中该键及其对应值是字符串 此方法相当于Map集合中的keySet方法</li></ul></li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n3936" mdtype="fences" style="break-inside: unset;"> public static void demo10(){
    //创建Properties集合对象
    Properties prop = new Properties();
    //使用setProperty向集合中添加数据
    prop.setProperty("name1","111");
    prop.setProperty("name2","222");
    prop.setProperty("name3","333");
    //prop.put(1,true);//错误
    //使用stringPropertyName把Properties集合中的键取出存储到一个Set集合中
    Set&lt;String&gt; set = new prop.stringPropertyNames();
    //遍历Set集合 取出Properties集合的每一个键
    for(String key : set){
        //使用getProperty方法通过key获取value
        String value = prop.getProperty(key);
        System.out.println(key+"--&gt;"+value);
    }
}

</pre><p><code>Properties集合中的store方法：</code></p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n3938" mdtype="fences" style="break-inside: unset;">把集合中的临时数据 持久化写入到硬盘中存储
	void store(OutputStream out,Stirng comments)
	void store(Writer writer,String comments)
	参数：	
		OutputStream out 字节输出流 不能写入中文
		Writer writer 字符输出流 可以写中文
		String comments 注释 解释说明保存的文件干什么用
			不能使用中文 会产生乱码 默认是Unicode编码
			一般使用""空字符串

使用步骤：
	1.创建Properties集合对象 添加数据
	2.创建字节输出流/字符输出流对象 构造方法中绑定要输出的目的地
	3.使用Properties集合中的方法store 把集合中的临时数据 持久化写入到硬盘中存储
	4.释放资源

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n3939" mdtype="fences" style="break-inside: unset;">public static void main(String[] args) throws IOException {
        test();
    }
public static void test() throws IOException {
    //使用setProperty向集合中添加数据
    Properties prop = new Properties();
    prop.setProperty("name1","111");
    prop.setProperty("name2","222");
    prop.setProperty("name3","333");
    FileWriter fw = new FileWriter("000\\dada.txt");
    prop.store(fw,"save data");
    fw.close();
}

</pre><p><code>Properties集合中的load方法：</code></p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n3941" mdtype="fences" style="break-inside: unset;">把硬盘中保存的文件(键值对)读取到集合中使用
	可以使用Properties集合中的方法load 把硬盘中保存的文件(键值对)读取到集合中使用
	void load(InputStream inStream)
	void load(Reader reader) 
	参数：
		InputStream inStream 字节输入流 不能读取含有中文的键值对
		Reader reader 字符输入流 能读取含有中文的键值对
	使用步骤：
		创建Properties集合对象
		使用Properties集合中的方法load读取保存键值对的文件
		便利Properties集合
	注意：
		存储键值对的文件中 键与值默认连接符号可以使用= 空格(其他符号)
		存储键值对的文件中 可以使用#进行注释 被注释的键值对不会再被读取
		存储键值对的文件中 键与值默认都是字符串 不用再加引号

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n3942" mdtype="fences">public static void test() throws IOException {
    Properties prop = new Properties();
    prop.load(new FileReader("000\\00.txt"));
    Set&lt;String&gt; set = prop.stringPropertyNames();
    for (String key : set){
        String value = prop.getProperty(key);
        System.out.println(key+"--&gt;"+value);
    }
}

</pre><h2><a name='header-n3943' class='md-header-anchor '></a>122. Optional类</h2><ul><li><p>Optional类：解决程序中的空指针异常问题。</p></li><li><p>创建Optional类对象的方法：</p><ol start='' ><li>Optional.of(T t) : 创建一个 Optional 实例，t必须非空；</li><li>Optional.empty() : 创建一个空的 Optional 实例 </li><li>Optional.ofNullable(T t)：t可以为null</li><li>判断Optional容器中是否包含对象：</li><li>boolean isPresent() : 判断是否包含对象</li><li>void ifPresent(Consumer&lt;? super T&gt; consumer) ：如果有值，就执行Consumer</li></ol></li><li><p>接口的实现代码，并且该值会作为参数传给它。</p><ol start='' ><li>获取Optional容器的对象：</li><li>T get(): 如果调用对象包含值，返回该值，否则抛异常</li><li>T orElse(T other) ：如果有值则将其返回，否则返回指定的other对象。</li><li>T orElseGet(Supplier&lt;? extends T&gt; other) ：如果有值则将其返回，否则返回由Supplier接口实现提供的对象。</li><li>T orElseThrow(Supplier&lt;? extends X&gt; exceptionSupplier) ：如果有值则将其返回，否则抛出由Supplier接口实现提供的异常。</li></ol></li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n3975" mdtype="fences" style="break-inside: unset;">class Girl {

    private String name;

    @Override
    public String toString() {
        return "Girl{" +
                "name='" + name + '\'' +
                '}';
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Girl() {

    }

    public Girl(String name) {

        this.name = name;
    }
}

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n3976" mdtype="fences" style="break-inside: unset;">class Boy {
	
    private Girl girl;

    @Override
    public String toString() {
        return "Boy{" +
                "girl=" + girl +
                '}';
    }

    public Girl getGirl() {
        return girl;
    }

    public void setGirl(Girl girl) {
        this.girl = girl;
    }

    public Boy() {

    }

    public Boy(Girl girl) {

        this.girl = girl;
    }
}

</pre><p>&nbsp;</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n3978" mdtype="fences">Girl girl = new Girl();
Optional&lt;Girl&gt; girl1 = Optional.ofNullable(girl);
System.out.println(girl1); // Optional[Girl{name='null'}]

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n3979" mdtype="fences">Girl girl = new Girl();
Optional&lt;Girl&gt; girlOptional = Optional.ofNullable(girl);
System.out.println(girlOptional); // Optional[Girl{name='null'}]
Girl anElse = girlOptional.orElse(new Girl("beauty"));
System.out.println(anElse); // Girl{name='null'}

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n3980" mdtype="fences">//orElse(T t1):如果当前的Optional内部封装的t是非空的，则返回内部的t。
//如果内部的t是空的，则返回orElse()方法中的参数t1。
Girl girl = new Girl();
girl = null;
Optional&lt;Girl&gt; girlOptional = Optional.ofNullable(girl);
System.out.println(girlOptional); // Optional.empty
Girl anElse = girlOptional.orElse(new Girl("beauty"));
System.out.println(anElse); // Girl{name='beauty'}

</pre><hr /><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n3982" mdtype="fences">Boy boy = new Boy();
// NullPointerException
//System.out.println(boy.getGirl().getName());

</pre><p><code>优化：</code></p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n3984" mdtype="fences">if (boy!=null){
    Girl girl2 = boy.getGirl();
    if(girl2!=null){
        System.out.println(boy.getGirl().getName());
    } else {
        System.out.println("Null");
    }
}

</pre><p><code>Optional类优化防止空指针异常：</code></p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n3986" mdtype="fences">Boy boy = new Boy();
boy = null;
//使用Optional类优化：
Optional&lt;Boy&gt; boyOptional = Optional.ofNullable(boy);
Boy boy1 = boyOptional.orElse(new Boy(new Girl("girl"))); // 执行boy一定非空
Girl boy1Girl = boy1.getGirl();
Optional&lt;Girl&gt; girlOptional = Optional.ofNullable(boy1Girl);
Girl girl1 = girlOptional.orElse(new Girl("girl1")); // 执行boy1Girl一定非空
System.out.println(girl1.getName()); // girl

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n3987" mdtype="fences">Boy boy = new Boy();
//使用Optional类优化：
Optional&lt;Boy&gt; boyOptional = Optional.ofNullable(boy);
Boy boy1 = boyOptional.orElse(new Boy(new Girl("girl"))); // 执行boy一定非空
Girl boy1Girl = boy1.getGirl();
Optional&lt;Girl&gt; girlOptional = Optional.ofNullable(boy1Girl);
Girl girl1 = girlOptional.orElse(new Girl("girl1")); // 执行boy1Girl一定非空
System.out.println(girl1.getName()); // girl1

</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n3988" mdtype="fences">Boy boy = new Boy(new Girl("myGirl"));
//使用Optional类优化：
Optional&lt;Boy&gt; boyOptional = Optional.ofNullable(boy);
Boy boy1 = boyOptional.orElse(new Boy(new Girl("girl"))); // 执行boy一定非空
Girl boy1Girl = boy1.getGirl();
Optional&lt;Girl&gt; girlOptional = Optional.ofNullable(boy1Girl);
Girl girl1 = girlOptional.orElse(new Girl("girl1")); // 执行boy1girl一定非空
System.out.println(girl1.getName()); // myGirl

</pre><ul><li>Optional中Stream的使用</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n3992" mdtype="fences">List&lt;String&gt; list = new ArrayList&lt;&gt;();
list.add("Tom");
list.add("Jerry");
list.add("Tim");
Optional&lt;List&lt;String&gt;&gt; optional = Optional.ofNullable(list);
Stream&lt;List&lt;String&gt;&gt; stream = optional.stream();
//long count = stream.count(); // 1
stream.flatMap(x -&gt; x.stream()).forEach(System.out::println); // Tom Jerry Tim

</pre><ul><li><p>其他方法：</p><ol start='' ><li>boolean isEmpty() 判断value是否为空</li><li>ifPresentOrElse​(Consumer&lt;? super T&gt; action, Runnable emptyAction)
value非空，执行参数1功能；如果value为空，执行参数2功能</li><li>Optional<T> or​(Supplier&lt;? extends Optional&lt;? extends T&gt;&gt; supplier)
value非空，返回对应的Optional；value为空，返回形参封装的Optional</li><li>Stream<T> stream() 
value非空，返回仅包含此value的Stream；否则，返回一个空的Stream</li><li>T orElseThrow() 
value非空，返回value；否则抛异常NoSuchElementException</li></ol></li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n4007" mdtype="fences" style="break-inside: unset;">var op = Optional.empty();
System.out.println(op.isPresent());//判断内部的value是否存在 false
System.out.println(op.isEmpty());//判断内部的value是否为空 true

op = Optional.of("abc");
//orElseThrow():value非空，返回value；否则抛异常NoSuchElementException
var obj = op.orElseThrow();
System.out.println(obj); // abc

Optional&lt;String&gt; op1 = Optional.of("hello");
op = Optional.empty();
//or:value非空，返回对应的Optional；value为空，返回形参封装的Optional
Optional&lt;Object&gt; op2 = op.or(() -&gt; op1);
System.out.println(op2); // Optional[abc]

</pre><h2><a name='header-n4008' class='md-header-anchor '></a>123. 集合工厂方法创建只读集合</h2><ul><li>方式一：</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n4012" mdtype="fences">List&lt;Integer&gt; list = new ArrayList&lt;&gt;();
list.add(1);
list.add(2);
list.add(3);
List&lt;Integer&gt; integerList = Collections.unmodifiableList(list);
System.out.println(integerList);
//integerList.add(4); // UnsupportedOperationException

</pre><ul><li>方式二：</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n4016" mdtype="fences">List&lt;Integer&gt; list = Arrays.asList(1, 2, 3, 4);
//list.add(5); // UnsupportedOperationException

</pre><ul><li>方式三：</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n4020" mdtype="fences">List&lt;Integer&gt; list = List.of(1, 2, 3);
System.out.println(list);
//list.add(4); // UnsupportedOperationException

</pre><ul><li>方式四：集合中新增的copyOf()，用于创建一个只读的集合。</li></ul><p><code>//结论：copyOf(Xxx coll):如果参数coll本身就是一个只读集合，则copyOf()返回值即为当前的coll</code>
    <code>//如果参数coll不是一个只读集合，则copyOf()返回一个新的集合，这个集合是只读的。</code></p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n4025" mdtype="fences">var list1 = List.of("Java", "Python", "C");
var copy1 = List.copyOf(list1);
System.out.println(list1 == copy1); // true

var list2 = new ArrayList&lt;String&gt;();
list2.add("aaa");
var copy2 = List.copyOf(list2);
System.out.println(list2 == copy2); // false

</pre><h2><a name='header-n4026' class='md-header-anchor '></a>124. InputStream中的transferTo方法</h2><ul><li>transferTo()：把输入流中的数据直接自动地复制到输出流中。</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n4030" mdtype="fences">ClassLoader classLoader = this.getClass().getClassLoader();
try (InputStream inputStream = classLoader.getResourceAsStream("a.txt");
     OutputStream outputStream = new FileOutputStream("src\\b.txt")){
    inputStream.transferTo(outputStream);
} catch (IOException e){
    e.printStackTrace();
}

</pre><h2><a name='header-n4031' class='md-header-anchor '></a>125. 局部变量类型推断</h2><ul><li>声明变量时，根据所附的值，推断变量的类型。</li><li>var不是一个关键字！！</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n4037" mdtype="fences">var num = 10;
var list = new ArrayList&lt;Integer&gt;();
list.add(123);
//2.遍历操作
for (var i : list) {
    System.out.println(i);
    System.out.println(i.getClass()); // class java.lang.Integer
}
//3.普通的遍历操作
for (var i = 0; i &lt; 2; i++) {
    System.out.println(i);
}

</pre><ul><li><p>局部变量不赋值，就不能实现类型推断。</p></li><li><p>lambda表示式中，左边的函数式接口不能声明为var</p></li><li><p>方法引用中，左边的函数式接口不能声明为var</p></li><li><p>数组的静态初始化中，var arr = {1,2,3,4};不被允许</p></li><li><p>其他不能类型推断的情况：</p><ol start='' ><li>没有初始化的局部变量声明</li><li>方法的返回类型</li><li>方法的参数类型</li><li>构造器的参数类型</li><li>属性</li><li>catch块</li></ol></li><li><p>在var上添加注解：</p></li></ul><p><code>使用var的好处是在使用lambda表达式时给参数加上注解。</code></p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="java" contenteditable="false" cid="n4065" mdtype="fences">Consumer&lt;String&gt; con2 = (@Deprecated var t) -&gt; System.out.println(t.toUpperCase());

</pre><h2><a name='header-n4066' class='md-header-anchor '></a>126. Java11String中的新增方法</h2><ol start='' ><li>isBlank():判断字符串是否为空白。</li><li>strip():去除首尾空白。</li><li>stripTrailing():去除尾部空格。</li><li>stripLeading():去除首部空格。</li><li>repeat(int count):复制字符串。</li><li>lines().count():行数统计。</li></ol><h1><a name='header-n4080' class='md-header-anchor '></a>后会有期</h1><blockquote><p>路漫漫其修远兮，吾将上下而求索</p><p>纸上得来终觉浅，绝知此事要躬行</p></blockquote></div>
</body>
</html>